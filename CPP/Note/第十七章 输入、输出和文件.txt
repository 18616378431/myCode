第十七章 输入、输出和文件

1.C++输入和输出(简称I/O),使用istream和ostream进行标准输入和输出,使用ifstream和ofstream进行文件输入和输出
2.用于文件输入和输出的C++工具都是基于cin和cout所基于的基本类定义

17.1 C++输入和输出概述
1.对数计算机语言的输入和输出是以语言本身为基础实现的,BASIC、Pascal等语言的关键字列表中有输出关键字
    PRINT、Writeln都是语言词汇表的组成部分,C/C++都没有将输入和输出建立在语言中
    这两种语言都包括for和if关键字,但不包括与I/O有关的内容
    C语言最初是将I/O留给了编译器实现人员,这样编译器实现人员可自由设计I/O函数
    使之最适合于目标计算机的硬件要求
    实际上,多数实现人员都把I/O建立在最初为UNIX环境开发的库函数基础之上
    ANSI正式承认这个I/O软件包时,将其称为标准输入/输出包,并将其作为标准C库不可或缺的组成部分
    C++也认可这个软件包,熟悉stdio.h文件中声明的C函数,则可在C++程序中使用它们(cstdio)
    不过C++依赖于C++的I/O解决方案,而不是C语言的I/O解决方案
    前者是在头文件iostream(iostream.h)和fstream(fstream.h)中定义一组类
    这个类库不是正式语言定义的组成部分(cin和istream不是关键字)
    计算机语言定义了如何工作(如如何创建类)的规则,但没有定义要按照这些规则创建哪些东西
    正如C实现自带了一个标准库函数一样,C++也自带了一个标准类库
    首先,标准类库是一个非正式的标准,只是由头文件iostream和fstream中定义的类组成
    ANSI/ISO C++标准委员会决定把这个类正式作为一个标准类库,并添加一些其它标准类,如STL
    先看看C++I/O概念框架

17.1.1 流和缓冲区
1.C++程序把输入和输出看做字节流
    输入时,程序从输入流中抽取字节,输出时,程序将字节插入到输出流中
    对于面向文本的程序,每个字节代表一个字符,字节可以构成字符或数值数据的二进制表示
2.输入流中的字节可能来自键盘,也可能来自存储设备,硬盘或其他设备
    同样,输出流中的字节可以流向屏幕、打印机、存储设备或其他程序
    流充当了程序和流源或流目标之间的桥梁
    这使得C++程序可以用相同的方式对待来自键盘的输入和来自文件的输入
    C++程序只是检查字节流,而不需要知道字节来自何方
    通过使用流,C++程序处理输出的方式将独立于其去向,因此管理输入包含两步:
    [1]将流与输入去向的程序关联起来
    [2]将流与文件连接起来
    输入流需要两个连接,每端各一个
    文件端连接提供了流的来源,程序端将流的流出部分转存到程序中(文件端连接可以是文件、设备(键盘))
    对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来
3.通常,通过使用缓冲区可以更高效地处理输入和输出
    缓冲区是用作中介的内存块,它是将信息从设备传输到程序或从程序传输给设备的临时存储工具
    通常像磁盘驱动器这样的设备以512字节(或更多)的块为单位来传输信息,而程序通常每次只能处理一个字节的信息
    缓冲区帮助匹配这两种不同的信息传输速率
    eg: 程序要计算记录在硬盘文件中的金额
        程序可以从文件中读取一个字符,处理它,再从文件中读取下一个字符,再处理,依此类推
        从文件中每次读取一个字符需要大量的硬件活动,速度非常慢
        缓冲方法则从磁盘上读取大量信息,将这些信息存储在缓冲区中,然后每次从缓冲区中读取一个字节
        因为从内存中读取单个字节的速度比从硬盘上读取快很多,所以这种方法更快,也更方便
        当然,到达缓冲区末尾后,程序将从磁盘上读取另一块数据
        输出时,程序首先填满缓冲区,然后把整块数据传递给硬盘,并清空缓冲区,以备下一批输出使用
        这被称为刷新缓冲区(flushing the buffer)
4.键盘输入每次提供一个字符,程序无需缓冲区来帮助匹配不同的数据传输速率
    对键盘输入进行缓冲可以让用户在将输入传输给程序之前返回并更正
    C++通常在用户按下回车键时刷新输入缓冲区
    对于屏幕输出,C++程序通常在用户发送换行符时刷新缓冲区
    程序也可能在其他情况下刷新输入,输入即将到来时,这取决于实现
    当程序到达输入语句时,它将刷新输出缓冲区中当前所有的输出
    与ANSI C一致的C++实现是这样工作的

17.1.2 流、缓冲区和iostream文件
1.iostream(iostream.h)中专门设计了用来管理流和缓冲区的类
    最新版本C++I/O定义了一些模板,以支持char和wchar_t数据
    通过typedef工具,C++使得这些模板char具体化能够模仿传统的非模板I/O实现
    提供的一些类
    [1]streambuf类为缓冲区提供了内存,并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的方法
    [2]ios_base类表示流的一般特征,如是否可读取、是二进制流还是文本流等
    [3]ios类基于ios_base,其中包括了一个指向streambuf对象的指针成员
    [4]ostream类是从ios类派生而来的,提供了输出方法
    [5]istream类也是从ios类派生而来的,提供了输入方法
    [6]iostream类是基于istream和ostream类的,因此继承了输入方法和输出方法
    要使用这些工具,必须使用适当的类对象,使用ostream对象cout来处理输出,
    创建这样的对象将打开一个流,自动创建缓冲区,并将其与流关联起来,同时使得能够使用类成员函数
    char(8位),wchar_t(16位)
    为支持16位国际字符集,开发了一套I/O类模板,其中包括basic_istream<charT,traits<charT> >和basic_ostream<charT,traits<charT> >
    traits<charT>模板是一个模板类,为字符类型定义了具体特性,如何比较字符是否相等、字符的EOF值等
    该C++标准提供了I/O的char和wchar_t具体化
    istream和ostream都是char具体化的typedef
    wistream和wostream都是wchar_t具体化
    wcout用于输出宽字符流
    这些定义都包含在ostream头文件
    ios基类中的一些独立于类型的信息被移动到新的ios_base类中,包括各种格式化常量,ios::fixed(ios_base::fixed)
    ios_base还包含一些老式ios中没有的选项
2.C++的iostream类库管理了很多细节,在程序中包含iostream将自动创建8个流对象,4个用于窄字符流,4个用于宽字符流
    [1]cin:对应于标准输入流,在默认情况下这个流被关联到标准输入流(通常为键盘),wcin与此类似,但处理的是wchar_t类型
    [2]cout:对象与标准输出流相对应,在默认情况下,这个流被关联到标准输出流(通常为显示器),wcout与此类似,但处理的是wchar_t类型
    [3]cerr:对象与标准错误流相对应,可用于显示错误消息,在默认情况下这个流被关联到标准输出设备(通常为显示器)
        这个流没有被缓冲,这意味着信息将被直接发送给屏幕,而不会等到缓冲区填满或新的换行符,wcerr对象与此类似,但处理的是wchar_t类型
    [4]clog:对象也对应着标准错误流,在默认情况下,这个流被关联到标准输出设备(通常为显示器),这个流被缓冲,wclog对象与此类似,但处理的是wchar_t类型
3.对象代表流,iostream文件为程序声明一个cout对象时,该对象将包含存储了与输出有关的信息的数据成员
    如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法、以及描述用来处理输出流的缓冲区的streambuf对象的地址
    eg: cout << "Bjarne free";
        通过指向的streambuf对象将字符串中的字符放置到cout管理的缓冲区中,ostream类定义了operator<< ()函数
        ostream还支持cout数据成员及其他大量类方法
        来自缓冲区的输出被引导到标准输出
        流的一端与程序相连,另一端与标准输出相连,cout对象凭借streambuf对象的帮助,管理者流中的字节流

17.1.3 重定向
1.标准输入和输出流通常连接着键盘和屏幕,但很多操作系统(UNIX、Linux、MS-DOS)都支持重定向
    这个工具使得能够改变标准输入和输出
    eg: 将输入重定向到文件并将输出重定向另一个文件
        读取文件中的字符数
        counter <oklahoma >cow_cnt
        命令行中<oklahoma将标准输入与文件关联起来,使cin从文件而不是键盘读取输入
        操作系统改变了输入流的流入端连接,而流出端仍然与程序相连
        命令行中>cow_cnt将标准输出与文件关联起来,导致cout将输出发送到文件而不是屏幕
        操作系统改变了输出流的流出端连接,而流入端仍与程序相连
2.cout代表的标准输出流是程序输出的常用通道
    标准错误流由cerr和clog代表,用于程序的错误消息
    默认情况下这三个对象都被发送给显示器
    但是对标准输出重定向并不会影响cerr和clog
    当常规的cout标准输出被重定向到其他地方,使用其中一个对象来打印错误消息,程序将在屏幕上显示错误消息
    eg: if(success)
            std::cout << "Here come the goodies!\n";
        else
        {
            std::cerr << "Something horrible has happened.\n";
            exit(1);
        }
        未重定向则所有消息都将显示在屏幕上,如果程序输出被重定向到文件,则第一条消息将被发送到文件中
        而第二条将被发送到屏幕
        有些系统允许对标准错误进行重定向,UNIX、Linux中,操作符2>重定向标准错误

17.2 使用cout进行输出
1.C++将输出看做字节流(16位或32位字节),但在程序中很多数据被组织成比字节更大的单位
    int由16位或32位的二进制值表示,double由64位的二进制数据表示
    但在将字节流发送给屏幕时,希望每个字节表示一个字符值
    要在屏幕上显示-2.34,需要将5个字符(-,2,.,3,4),而不是这个值的64位内部浮点表示发送到屏幕上
    ostream最重要的任务之一是将数值类型(int/float)转换为以文本形式表示的字符流
    ostream类将数据内部表示(二进制位模式)转换为由字符字节组成的输出流
    为执行这些转换任务,ostream类提供了多个类方法

17.2.1 重载的<<操作符
(1)在C++中,与C一样,<<操作符的默认含义是按位左移操作符
    表达式x << 3将x的二进制表示中所有的位向左移动3位
    ostream类重新定义了<<操作符,方法是将其重载为输出,这种情况下<<叫做插入操作符
    而不是左移操作符,插入操作符被重载以支持C++中所有的基本类型
    基本类型:
    unsigned char
    signed char
    char 
    short
    unsigned short
    int
    unsigned int
    long
    unsigned long
    float
    double
    long double
    上述每种类型,ostream类都提供了operator<< ()函数的定义
    eg: cout << value;//value为前面列出的类型之一
        则C++程序将其对应于有相应特征的操作符函数
        cout << 88;
        对应于下面的方法原型
        ostream & operator<< (int);
        该原型表明,operator<< (int)接受一个int参数,这与上述语句相匹配
        并且该函数返回一个ostream对象的引用,以便可以进行链式调用
        cout << "I'm feeling sedimental over " << boundary << "\n";
1.输出和指针
(1)ostream类还为下面的指针类型定义了插入操作符函数
    [1]const signed char *
    [2]const unsigned char *
    [3]const char *
    [4]void *
(2)C++使用指向字符串存储位置的指针来表示字符串
    指针的形式可以是char数组名或显式的point-to-char或引号括起的字符串
    eg: char name[20] = "Dudly Diddlemore";
        char *pn = "Violet D'Amore";
        cout << "Hello!";
        cout << name;
        cout << pn;
        方法使用字符串中的终止空字符来确定何时停止显式字符
        对于其他类型的指针,C++将其对应于void *,并打印地址的数值表示,如果要获得字符串的地址,则必须将其强制转换为其他类型
        int eggs = 12;
        char *amount = "dozen";
        cout << &eggs;//print address of eggs variable
        cout << amount;//print the string dozen
        cout << (void *)amount;//print the address of the "dozen" string
        老式C++实现没有接受void *的原型,要打印地址值,必须将指针强制转换为unsigned或unsigned long
2.拼接输出
(1)插入操作符的所有化身的返回类型都是ostream &,其原型如下
    ostream & operator<< (type);
    type为要显示的数据类型,返回类型ostream &意味着使用该操作符将返回一个指向ostream对象的引用
    引用将指向调用该操作符的对象,操作符函数的返回值为调用操作符的对象
    这种特性使得能够通过插入连接输出
    eg: cout << "We have " << count << " unhatched chickens.\n";
        =>
        cout << count << " unhatched chickens.\n";
        =>
        cout << " unhatched chickens.\n";

17.2.2 其他ostream方法
1.除了各种operator<< ()函数外,ostream类还提供了put()方法和write()方法,前者用于显示字符,后者用于显示字符串
2.最初put()的原型如下
    ostream & put(char);
    当前标准尊与此相同,但被模板化,以适用于wchar_t,可以用类方法表示法来调用它
    cout.put('W');//display the W character
    cout是调用方法的对象,put()是类成员函数,和<<操作符一样,该函数也返回指向调用对象的引用
    因此可以用它拼接输出
    cout.put('I').put('t');//displaying It with two put() calls
    函数调用cout.put("I")返回cout,然后cout被用作put('t')的调用对象
    在原型合适的情况下,可以将数值型参数(int)用于put(),让函数原型将参数值自动转换为正确的char值
    cout.put(65);//display the A character
    cout.put(66.3);//display the B character
    第一条语句将int值65转换为char值,然后显示ASCII码为65的字符
    第二条语句将double值66.3转换为char值66,并显示对应的字符
    这种行为在C++2.0之前可以派上用场
    在这些版本中,C++语言用int值表示字符常量
    cout << 'W';
    将'W'解释为int值,因此将其作为整数87(ASCII)显示出来
    cout.put('W');
    当前C++将char常量表示为char类型
    一些老式编译器错误地为char、unsigned char、signed char3中参数类型重载了put()
    这使得将int用于put()时具有二义性,int可被转换为这3中类型中的任何一种
3.write()方法:显示整个字符串,其模板原型
    basic_ostream<charT,traits> & write(const char_type *s,streamsize n);
    第一个参数提供了要显式字符串的地址
    第二个参数指出要显式多少个字符
    使用cout调用write()时将调用char具体化,因此返回类型为ostream &
    cout.write()调用返回cout对象,write()方法返回一个指向调用它的对象的引用‘
    这使得可以将输出拼接起来,cout.write()将被其返回值cout替换
    cout.write(state2,i) << endl;
    write()方法并不会在遇到空字符时自动停止打印字符,而只是打印指定数目的字符,即使超出的字符串的边界
    state2前后声明了亮娃两个字符串,以便相邻内存中有数据
    编译器在内存中存储数据的顺序以及调整内存的方式各不相同
    占用6个字节的字符串,由于编译器使用4个字节的倍数调整字符串,因此6个字节的字符串填充为占用8个字节
    write()方法也可以用于数值数据,可以将数字的地址强制转换为char *,然后传递给它
    long val = 560031841;
    cout.write((char *)&val,sizeof(long));
    long变量的4个字节中的每个字节将被作为单独的字节被传输
    输出设备将把每个字节作为ASCII码进行解释,因此在屏幕上这4个字节将被显式为4个字符组合

17.2.3 刷新输出缓冲区
1.ostream类对cout对象处理的输出进行缓冲,所以输出不会立即发送到目标地址,而是被存储在缓冲区中,直到缓冲区填满
    然后程序将刷新(flush)缓冲区,把内容发送出去,并清空缓冲区,以存储新的数据
    通常缓冲区为512字节或其整数倍
    当标准输出连接的是硬盘上的文件时,缓冲可以节省大量时间,以免程序为发送512字节而存取磁盘512次
    将512字节收集到缓冲区中,然后将它们一次性写入硬盘的效率要高得多
    对于屏幕输出,首先填满缓冲区的重要性要低得多
    屏幕输出时程序不必等到缓冲区被填满,将换行符发送到缓冲区将刷新缓冲区
    多数C++实现都会在输入即将发生时刷新缓冲区
    eg: cout << "Enter a number:";
        float num;
        cin >> num;
        程序期待输入这一事实,将导致它立刻显示cout消息,即使输出字符串中没有换行符
        如果没有这种特性,程序将等待输入,而无法通过cout来提示用户
        如果程序不能所希望的时候刷新输出,可以使用两个控制字符中的一个来强行进行刷新
        控制符flush刷新缓冲区,而控制符endl刷新缓冲区并插入一个换行符
        这两个控制符的使用方式与变量名相同
        cout << "Something" << flush;
        cout << "Something" << endl;
        事实上,控制符也是函数,可以直接使用flush()刷新cout缓冲区,flush(cout)
        ostream类对<<插入操作符进行了重载,使得表达式
        cout << flush;
        将被替换为函数调用flush(cout)
        可以使用更方便的插入表示法来成功进行刷新

17.2.4 使用cout进行格式化
(1).ostream插入操作符将值转换为文本格式
    默认情况下格式化值的方式如下:
    (1)对于char值,如果它代表的是可打印字符,则将被作为一个字符显示在宽度为一个字符的字段中
    (2)对于数值整型,将以十进制方式显示在一个刚好容纳该数字及负号(如果有)的字段中
    (3)字符串被显示在宽度等于该字符串长度的字段中
(2).浮点数的默认行为变化
    [1]新式:浮点类型被显示为6位,末尾的0不显示(显示的数字位数与数字被存储时的精度没有任何关系)
        数字以定点表示法显示还是以科学计数法表示,取决于它的值
        具体来说,当指数大于等于6或小于等于-5时,将使用科学计数法表示
        字段宽度恰好容纳数字和负号(如果有)
        默认的行为对应于带%g的说明符的标准C库函数fprintf()
    [2]老式:浮点类型显示为带6位小数,末尾的0不显示(显示的数字位数与数字被存储时的精度没有任何关系)
        数字以定点表示法还是以科学计数法表示,取决于它的值
        另外,字段宽度恰好容纳数字和负号(如果有)
        因为每个值的显示宽度都等于它的长度,因此必须显式地在值之间提供空格,否则相邻的值将不会被分开
    并非所有编译器都能生成符合当前C++标准格式的输出,当前标准允许区域性变化
    欧洲实现可能遵循欧洲人的风格:使用逗号,而不是句点来表示小数
    2.54将被些成2,54
    区域库(头文件locale)提供了用特定的风格影响(imbuing)输入或输出流的机制
    所以同一个编译器能够提供多个区域选项
    末尾不带0的浮点值后面将有6个空格,科学计数法的指数显示为3位,有些实现可能为2位
1.修改显示时使用的计数系统
    ostream类是从ios类派生而来的,而后者是从ios_base类派生而来的,ios_base类存储了描述格式状态的信息
    eg: 一个类的成员中某些位决定了使用的计数系统,而另一个成员则决定了字段宽度
    通过控制符(manipulator),可以控制显示整数时使用的计数系统
    通过使用ios_base的成员函数,可以控制字段宽度和小数位数
    ios_base类是ostream类的间接基类,可以将其方法应用于ostream对象(或子代),cout
    注:
        ios_base类中的成员和方法以前位于ios类中,现在ios_base是ios的基类
        在新系统中,ios是包含char和wchar_t具体化的模板,而ios_base包含了非模板特性
    eg: 显示整数时使用的计数系统
        要控制整数以十进制、十六进制、八进制显式,可以使用dec、hex、oct控制符
        hex(cout);
        将cout对象的计数系统格式状态设置为十六进制,程序将以十六进制形式打印整数值
        直到将格式状态设置为其他选项为止
    注:控制符不是成员函数,因此不必通过对象来调用
        控制符实际上是函数,但它们通常的使用方式为:
        cout << hex;
        ostream类重载了<<操作符,这使得上述用法与hex(cout)等效
        控制符位于名称空间std中
        可以单独使用控制符,也可以作为一系列插入的组成部分
2.调整字段宽度
    可以使用width()成员函数将长度不同的数字放到宽度相同的字段中,其原型:
    int width();
    int width(int i);
    第一种格式返回字段宽度的当前设置
    第二种格式将字段宽度设置为i个空格,并返回以前的字段宽度值,这使得能够保存以前的值,以便以后恢复宽度值时使用
    注:width()方法只影响将要显示的下一个项目,然后字段宽度将恢复为默认值,
    width()是成员函数,必须使用cout(或其他ostream类及子类对象)调用它
    eg: cout << "#";
        cout.width(12);
        cout << 12 << "#" << 24 << "#\n";//#       12#24#
        12被放到宽段为12的字段最右边,这杯称为右对齐
        然后字段宽度被恢复为默认值,并将其余项目放到宽度与其程度相等的字段中
    C++永远不会截短数据,因此如果试图在宽度为2的字段中打印一个7位值,C++将增宽字段以容纳该数据
    C++中显示所有的数据比保持列整洁更重要
    有些语言如果数据长度与字段宽度不匹配,将使用星号填充
    cout通过加入空格来填满整个字段,右对齐时空格被插入到值的左侧
    用来填充的字符叫做填充字符(fill character),右对齐时默认的
    默认字段宽度为0
3.填充字符
    在默认情况下,cout用空格填充字段中未被使用的部分,可以用fill()成员函数来改变填充字符
    eg: cout.fill('*');//将填充字段改为星号,对于检查打印结果防止接收添加数字很有用
    与字段宽度不同的是,新的填充字符将一直有效,直到它更改为止
4.设置浮点数的显示精度
    浮点数精度的含义取决于输出模式,默认模式下,它指的是显示的总位数
    在定点模式和科学模式下,精度指的是小数点后面的位数
    C++默认精度为6位(末尾的0不显示)
    precision()成员函数使得能够选择其他值
    eg: cout.precision(2);//将cout的精度设置为2
        和width()的情况不同,但与fill()类似,新的精度设置将一直有效,直到被重新设置
    注:老式C++版本将默认模式的精度解释为小数点后面的位数,而不是总位数
5.打印末尾的0和小数点
    iostream系列类没有提供专门用于完成在末尾显示小数点或0的函数
    但ios_base类提供了一个setf()函数,用于set标记,能够控制多种格式化特性
    这个类还定义了多个常量,可用作该函数的参数
    eg: cout.setf(ios_base::showpoint);//使cout显式末尾小数点
        在以前,在使用默认浮点格式时,上述语句还将导致末尾的0被显示出来
        如果使用默认的6位精度,cout不会将2.00显示为2,而是将它显示为2.000000
        如果编译器使用iostream.h头文件,而不是iostream,很可能需要在setf()中使用ios参数,而不是ios_base
        ios_base::showpoint是ios_base类级常量,在类成员函数外面使用需要作用域解析操作符(::)
6.再谈setf()
    ios_base类有一个受保护的数据成员,其中的各位(标记)分别控制着格式化的各个方面
    如计数系统、是否显示末尾的0等
    打开一个标记被称为设置标记(或位),并意味着相应的位被设置为1
    位标记是编程开关,相当于设置DIP开关以配置计算机硬件
    hex、dec、oct控制符调整计数系统的3个标记位
    setf()件数提供了另一种调整标记位的途径
    setf()函数有两个原型:
        ftmflags setf(fmtflags);
        其中fmtflags是bitmask类型的typedef名,用于存储格式标记,该名称是在ios_base类中定义的
        这个版本的setf()用来设置单个位控制的格式信息
        参数是一个fmtflags值,指出要设置哪一位,返回值是类型为fmtflags的数字,指出所有标记以前的设置
        如果打算恢复以前的设置,可以保存这个值
        ios_base类定义了代表位值的常量
    注:bitmask类型是一种用来存储各个位值的类型,它可以是整型、枚举,也可以是STL bitset容器
        这里的主要思想是每一位都可以单独访问,都有自己的含义,iostream软件包使用bitmask来存储状态信息
    表:
                    格式常量
    常量                                  意义
    ios_base::boolalpha                 输入和输出bool值,可以为true或false
    ios_base::showbase                  对于输出,使用C++基数前缀(0,0x)
    ios_base::showpoint                 显示末尾的小数点
    ios_base::uppercase                 对于16进制输出,使用大写字母,E表示法
    ios_base::showpos                   在正数前面加上+
    这些格式常量都是在ios_base类中定义的,使用时需加上作用域解析操作符,ios_base::uppercase
    格式的修改将一直有效,直到被覆盖为止

    ios_base::showpos仅当基数为10时才使用加号,C++将十六进制和八进制都视为无符号的,因此对它们无需使用符号
    
    第二个setf()原型接受两个参数,并返回以前的设置
        fmtflags setf(fmtflags,fmtflags);
        函数的这种重载格式用于设置由多位控制的格式选项
        第一个参数和以前一样,也是一个包含所需设置的fmtflags值
        第二个参数指出要清除第一个参数中的哪些位
    清除位(clearing the bit):
        如:将第3位设置为1表示以10位基数,将第4位设置为1表示以8为基数,将第5位设置为1表示以16为基数
            输出是以10位基数的,要将其设置为以16为基数,则需要将第5位设置为1,并且需要将第3位设置为0
    十六进制控制符hex可以自动完成这项工作
    setf()的第一个参数指出要设置哪些位,第二个参数指出要清除哪些位
    ios_base类定义了常量用于设置及清除位
    eg: 修改基数
        cout.setf(ios_base::hex,ios_base::basefield);
        上述操作与使用十六进制控制符的作用相同

            setf(long,long)的参数
    第二个参数               第一个参数               含义
    ios_base::basefield     ios_base::dex           使用基数10
                            ios_base::oct           使用基数8
                            ios_base::hex           使用基数16
    ios_base::floatfield    ios_base::fixed         使用定点计数法
                            ios_base::scientific    使用科学计数法
    ios_base::adjustfield   ios_base::left          使用左对齐
                            ios_base::right         使用右对齐
                            ios_base::internal      符号或基数前缀左对齐,值右对齐
    
    ios_base类定义了可按这种方式处理的3组格式标记
    每组标记都由一个可用作第二个参数的常量和2-3个可用作第一个参数的常量组成
    第二个参数清除一些相关的位,第一个参数将其中一位设置为1
    C++没有提供自动对齐模式
    定点表示法意味着使用123.4来表示浮点值,而不管数字长度如何,科学表示法意味着使用格式1.23e04,而不考虑数字的长度
    C++默认的模式对应于printf的%g说明符,定点表示法对应于%f说明符,科学表示法对应于%e说明符
    C++中定点表示和科学表示法的特征:
        [1]精度指的是小数点的位数,而不是总位数
        [2]显示末尾的0
    在老式用法中,末尾的0都不显示,除非ios_base::showpoint被设置
    老式用法中,精度总是指的小数位数,即使在默认情况下也是如此
    setf()是iso_base类的成员函数,由于这个类时ostream类的基类,因此可以使用cout对象来调用
    eg: 左对齐
        ios_base::fmtflags old = cout.setf(ios_base::left,ios_base::adjustfield);    
        恢复以前的设置
        cout.setf(old,ios_base::adjustfield);
    UNIX搜索数学库函数
        CC setf2.c -lm
        -lm选项命令链接程序搜索数学库
    cout.precision(3)使得默认浮点显示总共显示3位,而定点模式和科学模式只显示3位小数
    setf()的效果可以使用unsetf()消除,其原型如下:
        void unsetf(fmtflags mask);
        mask是位模式,mask中所有的位都为1,将使得对应的位被复位
        setf()将位设置为1,unsetf()将位恢复为0
    eg: cout.setf(ios_base::showpoint);//show trailing decimal point
        cout.unsetf(ios_base::showpoint);//don't show trailing decimal point
        cout.setf(ios_base::boolalpha);//display true,false
        cout.unsetf(ios_base::boolalpha);//display 1,0
    没有专门指示浮点数默认显示模式的标记
    系统的工作原理:
        仅当只有定点位被设置时使用定点表示法,仅当只有科学位被设置时使用科学表示法
        对于其他组合,如果没有位被设置或两位都被设置,将使用默认模式
    启用默认模式的方式之一是将所有位都设置为0
        cout.setf(0,ios_base::floatfield);
        第二个参数用来关闭这两位,第一个参数不设置任何位
        第二种方法是使用ios_base::floatfield参数调用unsetf()函数
        cout.unsetf(ios_base::floatfield);//go to default mode
        如果已知cout当前处于定点模式,可以使用cout.unsetf(ios_base::fixed)来切换到默认模式
        无论当前cout状态如何,使用cout.unsetf(ios_base::floatfield)都将切换到默认模式
        这是一种更好的选择
7.标准控制符
    使用setf()不是进行格式化的、对用户最友好的方法,C++提供了多个控制符,能够调用setf(),并自动提供正确的参数
    dec、oct、hex,这些控制符(多数都不适用于老式C++实现)的工作方式都与hex类似
    eg: cout << left << fixed;
        打开左对齐和定点选项
    注:如果系统支持这些控制符则请使用,否则仍可以使用setf()
                
                一些标准控制符
    操纵符             调用
    boolalpha       setf(ios_base::boolalpha);
    noboolalpha     unsetf(ios_base::boolalpha);
    showbase        setf(ios_base::showbase);
    noshowbase      unsetf(ios_base::showbase);
    showpoint       setf(ios_base::showpoint);
    noshowpoint     unsetf(ios_base::showpoint);
    showpos         setf(ios_base::shwopos);
    noshowpos       unsetf(ios_base::showpos);
    uppercase       setf(ios_base::uppercase);
    nouppercase     unsetf(ios_base::uppercase);
    internal        setf(ios_base::internal,ios_base::adjustfield);
    left            setf(ios_base::left,ios_base::adjustfield);
    right           setf(ios_base::right,ios_base::adjustfield);
    dec             setf(ios_base::dec,ios_base::basefield);
    hex             setf(ios_base::hex,ios_base::basefield);
    oct             setf(ios_base::oct,ios_base::basefield);
    fixed           setf(ios_base::fixed,ios_base::floatfield);
    scientific      setf(ios_base::scientific,ios_base::floatfield);
8.iomanip头文件
    使用iostream工具设置一些格式值(字段宽度)不太方便,为简化工作
    C++在iomanip头文件中提供了其他一些控制符,它们能够提供前面讨论过的服务,但表示起来更方便
    3个最常用的控制符分别是:setprecision()、setfill()、setw()
    它们分别用来设置精度、填充字符和字段宽度
    与前面讨论的控制符不同的是,这3个控制符带参数
    setprecision()控制符接受一个指定精度的整数参数
    setfill()控制符接受一个指定填充字符的char参数
    setw()控制符接受一个指定字段宽度的整数参数
    由于他们都是控制符,因此可以用cout语句链接起来,这样setw()控制符在显示多列值时尤为方便
    注:UNIX系统中使用数学库函数需要添加编译参数-lm以搜索数学库
        CC iomanip.c -lm
        老式编译器可能无法识别shwopoint这样的新标准控制符,可以使用等价的setf()
        老式实现中,使用showpoint控制符可以显示末尾的0
        新式实现中,使用fixed控制符可以显示末尾的0
        使用fixed在两种系统中都将以定点方式显示
        在新式统中,它使精度指的是小数位数
        在老式系统中,精度总是这个含义,而不管是否为浮点显示模式

                格式化方便的变化
    特性                          老式C++                   当前C++
    precision(n)                显示n位小数                在默认模式下,显示的总位数为n;在定点模式和科学模式下,显示n位小数
    ios::showpoint              显示末尾的小数点和末尾的0   显示末尾的小数点
    ios::fixed,ios::scientific                            显示末尾的0(precision())

17.3 使用cin进行输入
1.cin对象将标准输入表示为字节流,通常由键盘来生成这种字节流
    如果键入字符序列2005,cin对象将从输入流中抽取这几个字符
    输入可以是字符串的一部分、int值、float值,也可以是其他类型
    因此,抽取还涉及类型转换
    cin对象根据接收值的变量类型,使用其方法将字符序列转换为其所需的类型
    eg: cin >> value_holder;
        value_holder为存储输入的内存单元,它可以是变量、引用、被解除引用的指针,也可以是类或结构的成员
    cin解释输入的方式取决于value_holder的数据类型
    istream类重载了抽取操作符>>,使之能够识别下面这些基本类型:
        signed char &;
        unsigned char &;
        char &;
        short &;
        unsigned short &;
        int &;
        unsigned int &;
        long &;
        unsigned long &;
        float &;
        double &;
        long double &;
    这些操作符函数被称为格式化输入函数(formatted input functions),因为它们可以将输入数据转换为目标指定的格式
    典型的操作符函数原型如下:
        istream & operator>> (int &);
        参数和返回值都是引用
        引用参数将导致operator>> ()函数处理变量的本身,而不是像常规参数那样处理它的副本
        cin >> staff_size;
        由于参数为引用,因此cin可以直接修改用作参数的变量的值
2.抽取操作符的类型转换
    对于上述类型,抽取操作符将字符输入转换为指定类型的值
    eg: staff_size的类型为int,则编译器将
        cin >> staff_size;
        与下面的原型匹配
        istream & operator>> (int &);
        该函数将读取发送给程序的字符流(假设为字符2、3、1、8和4)
        对于使用2字节的int系统来说,函数将把这些字符转换为整数23184的2字节二进制表示
        如果staff_size的类型为double,则cin将使用operator>> (double &)将上述输入转换为值23184.0的8字节浮点表示
        可以将hex、oct、dec控制符与cin一起使用,来指定将整数输入解释为十六进制、八进制、还是十进制格式
        cin >> hex;
        将输入的12或0x12解释为十六进制的12或十进制的18,而将ff或FF解释为十进制的255
        istream类还为下列字符指针类型重载了>>抽取操作符:
        signed char *;
        char *;
        unsigned char *;
        对于这种类型的参数,抽取操作符将读取输入中的下一个单词,将它放置到指定的地址,并加上一个空值字符
        使之成为一个字符串
        cout << "Enter your first name:\n";
        char name[20];
        cin >> name;
        如果键入Liz做为响应,则抽取操作符将把字符Liz\0放到name数组中
        name标识符是一个char数组名,可做为数组第一个元素的地址,这使name的类型为char *
        每个抽取操作符都返回调用对象的引用,这使得能够将输入拼接起来,像拼接输出一样
        char name[20];
        float free;
        int group;
        cin >> name >> fee >>group;
        cin >> name的返回值cin对象成为处理fee的对象

17.3.1 cin如何检查输入
1.不同版本的抽取操作符查看输入流的方法是相同的
    它们跳过空白(空格、换行符、制表符),直到遇到非空白字符
    即使对于单字符模式(char,unsigned char,signed char)也是如此
    但对于C语言的字符输入函数,情况并非如此
    在单字符模式下,>>操作符将读取该字符并放到指定的位置
    在其它模式下,>>操作符将读取一个指定类型的数据
    它读取从非空白字符开始,到与目标类型不匹配的第一个字符之间的全部内容
    eg: int elevation;
        cin >> elevation;
        键入:-123Z
        操作符将读取-、1、2、3,因为它们都是整数的有效部分,但Z不是有效字符,因此输入中最后一个可接受的字符是3
        Z将留在输入流中,下一个cin语句将从这里开始读取
        与此同时,操作符将字符序列-123转换为一个整数值,并将其赋值给elevation
        输入有时可能没有满足程序的期望
        如果键入Zcar而不是-123Z,这种情况下,抽取操作符将不会修改elevation的值,并返回0
        (如果istream对象的错误状态被设置,if或while语句将判定该对象为false)
        返回值false让程序能够检查输入是否满足要求
        输入可以被缓冲,可以在按下回车之前输入多个值,在此之前输入不会发送给程序
        
17.3.2 流状态
(1).cin或cout对象包含一个描述流状态(stream state)的数据成员(继承自ios_base)
    流状态(被定义为iostate类型,而iostate是一种bitmask类型)由3个ios_base元素组成:
    eofbit、badbit或failbit,其中每个元素都是一位,可以是1(设置)或0(清除)
    当cin操作到达文件末尾时,它将设置eofbit;
    当cin操作未能读取到预期的字符时,它将设置failbit,IO(读取不可访问的文件或试图写入保护的磁盘)失败也可能将failbit设置为1
    在一些无法诊断的失败破坏流时,badbit元素将被设置
    当全部3个状态都设置为0时,说明一切顺利
    程序可以检查流状态并决定下一步做什么

                    流状态
    成员              描述
    eofbit          如果到达文件末尾则设置为1
    badbit          如果流被破坏,则设置为1;例,文件读取错误
    failbit         如果输入没有读取到预期的字符或输出没有写入预期的字符,则设置为1
    goodbit         另一种表示0的方法
    good()          如果流可以使用(所有的位都被清除),则返回true
    eof()           如果eofbit被设置,则返回true
    bad()           如果badbit被设置,则返回true
    fail()          如果badbit或failbit被设置,则返回true
    rdstate()       返回流状态
    exceptions()    返回一个位掩码,指出哪些标记导致异常被引发
    exceptions(iostate ex)  设置哪些状态将导致clear()引发异常;例,如果ex是eofbit,则如果eofbit被设置,clear()将引发异常
    clear(iostate s)    将流的状态设置为s,s的默认值是0(goodbit);如果(restate() & exceptions() != 0),则引发异常basic_ios::failure
    setstate(iostate s) 调用clear(rdstate() | s).这将设置与s中设置的位对应的流状态位,其他流状态位保持不变
1.设置状态
    (1)clear()和setstate()很相似,它们都重置状态,但采取不同的方式
        clear()方法将状态设置为它的参数:
        clear();//将使用默认参数0,这将清除全部3个状态位(eofbit,badbit,failbit)
        clear(eofbit);//eofbit将被设置,其他两个状态位将被清除
    (2)setstate()方法只影响其参数中已设置的位
        setstate(eofbit);//只设置eofbit位,而不会影响其他位,failbit如果被设置了,则其相应位的值将不会被改变
    为什么需要重新设置流状态,在输入不匹配或到达文件末尾时,需要使用不带参数的clear()重新打开输入
    setstate()主要用途是为输入和输出函数提供一种修改状态的途径
    eg: cin >> num;//int num;
        将可能导致operator>> (int &);使用setstate()设置failbit或eofbit
2.I/O异常
    (1)假设某个输入函数设置了eofbit,这是否会导致异常被引发呢?
        默认情况下,答案是否定的,但可以使用exceptions()方法来控制异常如何被处理
    (2)exceptions()返回一个位字段,它包含3位,分别对应于eofbit、failbit和badbit
        修改流状态涉及到clear()或setstate(),这都将使用clear()
        修改流状态后,clear()方法将当前的流状态与exceptions()返回的值进行比较
        如果在返回值中某一位被设置,而当前状态中的对应位也被设置,则clear()将引发ios_base::failure异常
        如果两个值都设置了badbit,将引发这种情况
        如果exceptions()返回goodbit,则不会引发任何异常
        ios_base::failure异常类是从std::exception类派生而来的,因此包含一个what()方法
        exceptions()的默认设置是goodbit,没有引发异常
        重载的exceptions(iostate)函数使得能够控制其行为
        eg: cin.exceptions(badbit);//setting badbit causes exception to be thrown
            位操作OR(|)使得能够指定多位
            cin.exceptions(badbit | eofbit);
            如果badbit或eofbit随后被设置,将引发异常
3.流状态的影响
    (1)只有在流状态良好(所有的位都被清除)的情况下,下面的if、while测试才会返回true
        while(cin >> input)
        如果测试失败,则可以使用流状态表中的成员函数来判断可能的原因
        while(cin >> input)
        {
            sum += input;
        }
        if(cin.eof())
            cout << "Loop terminated because EOF encountered\n";
        设置流状态有一个非常重要的后果,流将会对后面的输入或输出关闭,直到位被清除
        下面的代码将不能工作
        while(cin >> input)
        {
            sum += input;
        }
        cout << "Last value entered = " << input << endl;
        cout << "Sum = " << sum << endl;
        cout << "Now enter a new number:";
        cin >> input;//won't work
        如果希望在流状态位被设置后能够读取后面的输入,必须将流状态重置为良好,可以通过调用clear()方法来实现
        while(cin >> input)
        {
            sum += input;
        }
        cout << "Last value entered = " << input << endl;
        cout << "Sum = " << sum << endl;
        cout << "Now enter a new number:";
        cin.clear();//reset stream state
        while(!isspace(cin.get()))
            continue;//get rid of bad input
        cin >> input;//will work now
        注意,这还不足以重新设置流状态,导致输入循环终止的不匹配输入仍留在输入队列中
        程序必须跳过它,可以一直读取字符直到到达空白字符为止,使用cctype的isspace()函数
        其参数为空白字符时返回true
        另一种方法是丢弃行中的剩余部分,而不仅仅是下一个单词
        while(cin.get() != '\n')
            continue;
        上例是在不恰当的输入的情况下的,如果循环是由于到达文件末尾或者由于硬件故障而终止的
        这样的错误处理将毫无意义
        可以使用fail()成员函数来检测并修复问题,fail()在failbit或badbit被设置时返回true
        因此必须排除后一种情况
        while(cin >> input)
        {
            sum += input;
        }
        cout << "Last value entered = " << input << endl;
        cout << "Sum = " << sum << endl;
        if(cin.fail() && !cin.eof())//failed because of mismatched input
        {
            cin.clear();
            while(!isspace(cin.get()))
                continue;
        }
        else//else bail out
        {
            cout << "I cannot go on!\n";
            exit(1);
        }
        cout << "Now enter a new number:";
        cin >> input;//will work now

17.3.3 其他istream类方法
(1)istream类获取字符输入的函数
    [1]get(char &)和get(void)方法提供不跳过空白字符的单字符输入
    [2]get(char *,int,char)和getline(char *,int,char)函数在默认情况下读取整行而不是一个单词
    它们被称为非格式化输入函数(unformatted input functions),因此它们只读取字符输入,而不会跳过空白,也不进行数据转换
1.单字符输入
    (1)在使用char参数或没有参数的情况下,get()方法读取下一个输入字符,即使该字符是空格、制表符或换行符
        get(char &)版本将输入字符赋给其参数,而get(void)版本将输入字符转换为整型(int),并将其返回
    eg: //get(char &)
        int ct = 0;
        char ch;
        cin.get(ch);
        while(ch != '\n')
        {
            cout <<ch;
            ct++;
            cin.get(ch);
        }
        cout << ct << endl;
        cin.get(char &)将逐个读取输入缓冲区中的字符,直到读到换行符
        //cin >> ch版本
        int ct = 0;
        char ch;
        cin >> ch;
        while(ch != '\n')//FAILS
        {
            cout << ch;
            ct++;
            cin >> ch;
        }
        cout << ct << endl;
        代码将跳过空格,使输入变为压缩版本,并且循环不会终止,抽取操作符跳过了换行符
        代码不会将换行符赋给ch
    (2)get(char &)成员函数返回一个指向调用它的istream对象的引用,这意味着可以拼接get(char &)后面的其他抽取操作
        eg: char c1,c2,c3;
            cin.get(c1).get(c2) >> c3;
            代码缩减为
            cin.get(c2) >>c3;
            cin >> c3;
            c1、c2的值可为空白字符,但c3将会跳过空白符而读入非空白字符
        
        cin.get(char &)到达文件末尾或键盘模拟仿真的文件末尾(DOS Ctrl + z,UNIX Ctrl + d),它都不会给其参数赋值
        这是完全正确的,因为到达文件末尾,就没有值可供赋给参数了
        该方法还将调用setstate(failbit),导致cin的测试结果为false
        char ch;
        while(cin.get(ch))
        {
            //process input
        }
        只要存在有效输入,cin.get(char &)的返回值都将是cin,此时判定结果为true,到达文件末尾时,将返回值判定为false
    (3)get(void)成员函数还读取空白,但使用返回值来将值传递给程序
        eg: int ct = 0;
            char ch;
            ch = cin.get();
            while(ch != '\n')
            {
                cout << ch;
                ct++;
                ch = cin.get();
            }
            cout << ct << endl;
            //注:有些老式C++实现不提供这个成员函数
        get(void)成员函数的返回值为int(或其他更大的整型,取决于字符集和区域)
        这使得无法进行下面的链式调用
        eg: char c1,c2,c3;
            cin.get().get() >> c3;
            由于cin.get()的返回值是int,而不是cin对象,因此不能对它使用成员操作符
            可以在cin.get(char &)抽取序列的最后使用cin.get(void)
            char c1;
            cin.get(c1).get();//该表达式将返回最后一个get返回的int值
            cin.get(void)的返回值为int,这使得它后面不能跟抽取操作符
            上述表达式读取第一个字符赋给c1,然后读取并丢弃第二个输入字符
        到达文件末尾后,cin.get(void)豆浆返回值EOF--iostream头文件提供的一个符号常量
        eg: //这种设计使得可以这样读取输入
            int ch;
            while((ch = cin.get()) != EOF)
            {
                //process input
            }
            应将ch声明为int,而不是char,因为值EOF可能无法使用char类型来表示

                    cin.get(char &)与cin.get(void)
        特征                      cin.get(ch)                 ch = cin.get()
        传输输入字符的方法           赋给参数ch                将函数返回值赋给ch
        字符输入时函数的返回值       指向istream对象的引用      字符编码(int值)
        到达文件末尾时函数的返回值   转换为false                EOF
2.采用哪种单字符输入形式
    (1)get(char &)、get(void)、>>
        希望跳过空格则使用抽取操作符,显示菜单选项时,跳过空白更为方便
        eg: cout << "a. annoy client    b. bill client\n"
                    "c. calm client     d. deceive client\n"
                    "q.\n";
            cout << "Enter a,b,c,d or q:";
            char ch;
            cin >> ch;
            while(ch != 'q')
            {
                switch(q)
                {
                    ...
                }
                cout << "Enter a,b,c,d or q:";
                cin >> ch;
            }
            键入b并按回车键,则将生成两个字符相应:b\n
            如果使用get()则必须添加处理\n的代码,而抽取操作符可以跳过它
            如果希望程序检查每个字符,则可以使用get()
            例如判断以空格分隔的单词个数
        get()方法中,get(char &)接口更佳
        get(void)的主要优点是:它与标准C语言中的getchar()函数极其类似,这意味着
        可以通过包含iostream头文件而不是stdio.h,并用cin.get()替换所有的getchar()
        用cin.put(ch)替换所有的putchar(ch),来将C程序转换为C++程序
3.字符串输入:getline()、get()和ignore()
    三者均为cin成员函数(有一个非成员函数版本getline(string...))
    getline()成员函数和get()的字符串读取版本都读取字符串,它们的函数特征标相同
    (其原型为从更通用的模板声明简化而来)
    istream & get(char *,int,char);
    istream & get(char *,int);
    istream & getline(char *,int,char);
    istream & getline(char *,int);
    第一个参数为放置输入字符的内存单元地址
    第二个参数比要读取的最大字符数大1(额外一个字符用于存储结尾的空字符,以便将输入存储为一个字符串)
    第三个参数指定用作分界符的字符,两个参数的版本将以换行符为分界符
    上述函数都在读取了最大数目的字符或遇到换行符后为止
    eg: char line[50];
        cin.get(line,50);
        将字符输入读取到char数组中,在到达第49个字符或遇到换行符后停止将输入读取到数组中
    get()和getline()的主要区别在于,get()将换行符留在输入流中,这样接下来的输入操作首先看到的将是换行符
    而getline()抽取并丢弃输入流中的换行符
    三个参数的版本,遇到分界字符后,输入将停止读取,即使还未读取最大数目的字符
    默认情况下,如果在读取指定数目的字符之前到达行尾,将停止读取输入
    和默认情况下一样,get()将分界符留在输入队列中,getline()不保留
    ignore()成员函数,该函数接受两个参数,一个是数字,指定要读取的最大字节数,另一个是字符,用作输入分界符
    eg: cin.ignore(255,'\n');
        将读取并丢弃接下来的255个字符或直到到达第一个换行符
        其原型为两个参数提供默认值1和EOF,该函数的返回类型为istream &
        istream & ignore(int = 1,int = EOF);
        默认参数EOF使其读取指定数目的字符或读取到文件末尾
        该函数返回调用对象,可以拼接函数调用
        cin.ignore(255,'\n').ignore(8255,'\n');
        第一次调用地区并丢弃一行,第二行读取并丢弃一行,读取共二行
    注:在一些老式C++实现中,iostream版本的getline()有错误,导致下一行的输出被延迟到了输入了未显示行请求的数据后才显示
    iostream.h则正常
4.意外字符串输入
    (1)get(char *,int)和getline(cahr *,int)的某些输入形式将影响流状态
        这两个函数在遇到文件尾时将设置eofbit,遇到流被破坏(设备故障)时将设置badbit
        另外两种特殊情况是无输入以及输入到达或超过函数调用指定的最大字符数
        上述两种方法如果不能抽取字符,它们将把空值字符放置到输入字符串中,并使用setstate()设置failbit
        老式C++中如果没有读取字符将不会设置failbit
        方法在什么时候无法抽取字符呢?
        一种可能的情况是输入方法立刻到达文件末尾
        对于get(char *,int)来说,另一种肯能是输入了一个空行
        eg: char temp[80];
            while(cin.get(temp,80))//terminates on empty line
                ...
        空行并不会导致getline(char *,int)设置failbit,因为getline()将抽取换行符,虽然不会存储它
        如果希望getline(char *,int)在遇到换行符时终止,可以这样编写
        eg: char temp[80];
            while(cin.getline(temp,80) && temp[0] != '\0')//terminates on empty line
                ...
    (2)假设输入队列中输入的字符数等于或超过了输入方法中指定的最大字符数
        [1]首先来看getline(char *,int)
            eg: char temp[30];
                while(cin.getline(temp,30))
            getline(char *,int)从输入队列中读取字符,将它们放置到temp数组中
            直到到达文件末尾、将要读取的字符是换行符或读取了29个字符为止
            如果遇到文件末尾,则设置eofbit
            如果将要读取的字符是换行符,则该字符将被读取并丢弃
            如果读取了29个字符,并且下一个字符不是换行符,则设置failbit
            因此包含30个或更多字符的输入行将终止输入
        [2]再来看get(char *,int)
            它首先测试字符数,然后测试是否是文件尾以及下一个字符是否为换行符
            如果它读取了最大数目的字符,则不设置failbit
            由此可以知道,终止读取是否由于输入字符过多引起的
            可以使用peek()来查看下一个输入字符
            如果它是换行符,则说明get()已读取了整行
            如果不是换行符,则说明get()是到达行尾前停止的
            这种技术对getline()不适用,因为getline()读取并丢弃换行符,因此查看下一个字符无法知道任何情况
            使用get()则可以知道是否读取了一整行
        
                老式C++和当前标准输入行为的变化
        方法                  老式的C++                              当前的C++
        getline(char *,int)   如果没有读取任何字符,则不设置failbit    如果没有读取任何字符(换行符被视为读取了一个字符)
                                                                    则设置failbit
                              如果读取了最大数目的字符,则不设置failbit 如果读取了最大数目的字符,且行中还有其他字符
                                                                    则设置failbit                                                                    
        get(char *,int)       如果没有读取任何字符,则不设置failbit    如果没有读取任何字符,则设置failbit

17.3.4 其他istream方法
1.其他istream方法包括read()、peek()、gcount()和putback()
    (1)read函数读取指定数目的字节,并将它们存储在指定的位置中
        与get()、getline()不同
        read函数不会在输入后加上空值字符,因此不能将输入转换为字符串
        read()方法不是专为键盘输入设计的,它最常与ostream的write()函数结合使用,来完成文件输入和输出
        该方法的返回类型是istream &,可以链式调用
        eg: char gross[144];
            cin.read(gross,144);
            从标准输入中读取144个字符并将它们存储在数组gross中
            //链式调用
            char gross[144];
            char score[20];
            cin.read(gross,144).read(score,20);
    (2)peek()函数返回输入中的下一个字符,但不抽取输入流中的字符,它使得能够查看下一个字符
        读取输入直到换行符或句点,可以使用peek()查看输入流中的下一个字符,以此来判断是否继续读取
        eg: char great_input[80];
            char ch;
            int i = 0;
            while((ch = cin.peek()) != '.' && ch != '\n')
                cin.get(great_input[i++]);
            great_input[i] = '\0';
            cin.peek()查看下一个输入字符,并将其赋给ch,循环条件测试ch是否为句点或换行符
            如果不是句点或换行符,则循环将字符读入到数组中并更新数组索引
            循环终止时,句点和换行符将留在输入队列中,作为下一次输入操作读取的第一个字符
            最后将空值字符放在数组末尾,使其成为一个字符串
    (3)gcount()方法返回最后一个非格式化抽取方法读取的字符数
        这意味着字符是由get()、getline()、ignore()或read()方法读取的,而不是>>抽取操作符读取的
        抽取操作符将对输入进行格式化,使之与特定的数据类型匹配
        假如使用cin.get(myarray,80)将一行读取到数组中,并想知道读取了多少个字符,则可以使用strlen()来计算数组中的字符数
        这种方法比使用gcount()计算从输入流总读取了多少个字符的速度要快
    (4)putback()函数将一个字符插入到输入字符串中,被插入的字符将是下一条输入语句读取的第一个字符
        putback()方法接受一个char参数--要插入的字符,其返回类型为istream &,可以进行链式调用
        使用peek()方法的操作相当于使用cin.get(ch)读取一个字符到ch中,然后使用putback(ch)将字符放回到输入流中
        putback()允许将字符放回到不是刚才读取的位置

17.4 文件输入和输出
(1)字处理程序创建文件,数据库程序创建和搜索信息文件,编译器读取源文件并生成可执行文件
(2)文件本身是存储在某种设备(磁带、光盘、软盘或硬盘)上的一系列字节
(3)通常操作系统管理文件,并追踪它们的位置、大小、创建时间等
(4)通常不需要关心这些事情,除非在操作系统级别上编程
    需要的只是将程序与文件相连的途径,让程序读取文件内容的途径,以及让程序创建和写入文件的途径
(5)重定向可以提供一些文件支持,但它比显式程序I/O的局限性要大
    重定向来自操作系统,而非C++,因此并非所有系统都有这样的功能
(6)C++I/O软件包处理文件输入和输出的方式与处理标准输入和输出的方式非常相似
    需要写入文件,需要创建一个ofstream对象,并使用ostream方法,如<<插入操作符或write()
    要读取文件,需要创建一个ifstream对象,并使用istream方法,如>>抽取操作符或get()
    不过,与标准输入和输出相比,文件的管理更为复杂
    eg: 必须将新打开的文件和流关联起来,可以以只读模式、只写模式或读写模式打开文件
        写文件时,可能想创建新文件、取代旧文件或添加到旧文件中,还可能在文件中来回移动
        C++在头文件fstream(fstream.h)中定义了多个新类,其中包括用于文件输入的ifstream和文件输出的ofstream
        C++还定义了fstream类用于同步文件I/O
        这些类都是从头文件iostream派生而来,因此这些新类可以使用继承而来的方法

17.4.1 简单的文件I/O
1.要让程序写入文件:
    (1)创建一个ofstream对象来管理输出流
    (2)将该对象与特定文件关联起来
    (3)以使用cout的方式使用该对象,唯一的区别是:输出将进入文件而不是屏幕

    首先要包含头文件fstream,对于大多数实现来说,包含了该头文件则自动包括了iostream,因此不必显式包含iostream
    然后声明一个ofstream对象
    ofstream fout;//create an ofstream object named fout
    对象名称可以是任意有效的C++名称
    接下来必须将这个文件与特定的文件关联起来,为此,可以使用open()方法
    fout.open("jar.txt");//associate fout with jar.txt
    可以使用另一个构造函数来简化步骤
    ofstream fout("jar.txt");//create an ofstream object,associate it with jar.txt
    然后,以使用cout的方式使用fout
    fout << "Dull Data";//output to file jar.txt with "Dull Data"
    由于ostream是ofstream类的基类,因此可以使用所有ostream方法,包括各种插入操作符定义、格式化方法和控制符
    ofstream类使用被缓冲的输出,因此程序在创建fout这样的ofstream对象时,将为输出缓冲区分配空间
    如果创建了两个ofstream对象,程序将创建两个缓冲区,每个对象各一个
    fout这样的ofstream对象从程序逐字节地收集输出,当缓冲区填满后,它便将缓冲区内容一同传输给目标文件
    由于磁盘被设计成以大块的方式传输数据,而不是逐字节地传输,因此通过缓冲区可以大大提高从程序到文件传输数据的速度
    以这种方式打开的文件来进行输出时,如果没有这样的文件,将创建一个新文件;
    如果有这样的文件,则打开文件将清空文件,输出将进入到一个空文件中
    注:以默认模式打开文件进行输出将自动将文件的长度截短为0,这相当于删除已有文件
2.读取文件,与写入文件相似
    (1)创建一个ifstream对象来管理输入流
    (2)将该对象与特定文件关联起来
    (3)以使用cin的方式使用该对象
    需要包含头文件fstream,声明一个ifstream对象,将它与文件关联起来
    ifstream fin;
    fin.open("jellyjar.dat");//create ifstream object called fin
    //another
    ifstream fis("jamjar.dat");//create fis and associate with jamjar.dat
    现在可以像使用cin那样使用fin/fis
    char ch;
    fin >> ch;//read a character from the jellyjar.txt file
    char buf[80];
    fin >> buf;//read a word from the file
    fin.getline(buf,80);//rad a line from the file
    string line;
    getline(fin,line);//read from a file to a string object
    输入和输出一样,也是被缓冲的,因此创建ifstream对象与fout一样,将创建一个由fin管理的输入缓冲区
    与输出一样,通过缓冲,传输数据的速度比逐字节传输要快得多
    大概输入和输出流对象过期时,到文件的连接将自动关闭
    另外也可以使用close()来显式地关闭到文件的连接
    fout.close();//close output connection to file
    fin.close();//close input connection to file
    关闭这样的连接并不会删除流,而只是断开流到文件的连接,流管理装置仍被保留
    close()后fin对象与它管理的输入缓冲区仍然存在,可以将流重新连接到同一个文件或另一个文件
    关闭文件将刷新缓冲区,从而确保文件被更新

17.4.2 流状态检查和is_open()
1.C++文件流类从ios_base类那里继承了一个流状态成员,该成员存储了指出流状态的信息
    一切顺利、已到达未见尾、I/O操作失败等
    如果一切顺利,流状态为零
    其他状态都是将特定位设置为1来记录的
    文件流类还继承了ios_base类中报告流状态的方法
    可以通过检查流状态来判断最后一个流操作是否成功
    对于文件流,这包括检查试图打开文件时是否成功
    eg: 试图打开一个不存在的文件进行输入,将设置failbit位
        fin.open(argv[file]);
        if(fin.fail())//open attempt failed
        {
            ...
        }
        ifstream和istream类对象一样,被放在需要bool值的地方,将被转换为bool值
        fin.open(argv[file]);
        if(!fin)//open attempt failed
        {
            ...
        }
        较新的C++实现提供了更好的方式来检查文件是否被打开--is_open()
        if(!fin.is_open())//open attempt failed
        {
            ...
        }
        这种方式可以检测出其他方法无法检测出的问题
        注:以前检查文件是否打开的常见方式
            if(fin.fail())...//failed to open
            if(!fin.good())...//failed to open
            if(!fin)...//failed to open
            fin对象被用于测试条件中时,如果fin.good()为false,则将被转换为false,否则转换为true
            上面三种方式等价
            这些测试无法检测到这样一种情况:试图以不合适的文件模式打开文件时失败
            方法is_open()能够检测到这种错误以及good()能够检测到的错误
            老式C++实现没有is_open()

17.4.3 打开多个文件
1.打开多个文件的策略取决于它们将被如何使用
    如果需要同时打开两个文件,则需要为每个文件创建一个流
    eg: 要将两个排序后的文件拼接为第三个文件
        需要为两个输入文件创建两个ifstream对象,并为输出文件创建一个ofstream对象
        可以同时打开文件的数量取决于操作系统,但通常为20个左右
2.可能需要一次处理一组文件
    eg: 要统计某个名称在10个文件中出现的次数,这种情况下可以打开一个流,并将其依次关联到各个文件
        这比为每一个文件打开一个流更高效
        使用这种方法需要先声明一个ifstream对象,不初始化,然后使用open()方法将这个流与文件关联起来
        依次读取两个文件:
        ifstream fin;//create stream using default constructor
        fin.open("fat.dat");//associate stream with fat.dat file
        ...//do stuff
        fin.close();//terminate associating with fat.dat
        fin.clear();//reset fin(my not bo needed)
        fin.open("rat.dat");//associate stream with rat.dat file

17.4.4 命令行处理技术
1.文件处理程序通常使用命令行参数来指定文件,命令行参数是用户在输入命令时,在命令行输入的参数
    eg: 在UNIX/Linux中统计文件中包含的字数
        wc report1 report2 report3
        wc为程序名,report1、report2和report3是作为命令行参数传递给程序的文件名
2.C++有一种让在命令行环境中运行的程序能够访问命令行参数的机制,方法是添加main函数命令行参数
    int main(int argc,char *argv[])
    argc为命令行中参数的个数,其中包括命令本身
    argv为一个char *指针数组,其元素指向命令行的参数字符串
    argv[0]为指向命令行参数的第一个字符串
    eg: wc report1 report2 report3
        argc为4,argv[0]为wc,argv[1]为report1
        for(int i = 1;i < argc;i++)
            cout << argv[i] << endl;
        i为1将只打印命令行参数,为0则打印命令名
3.命令行参数与命令行系统(UNIX、DOS、Linux)紧密相关
    很多DOS和Windows IDE都有一个提供命令行参数的选项,通常补习选择一系列菜单,才能够打开可以输入命令行参数的对话框
    DOS IDE和很多Windows IDE都可以生成可执行文件,这些文件能够在DOS下或以DOS命令行模式在DOS窗口些运行
    在Metrowerks CodeWarrior for the Macintosh下,可以通过包含console.h来支持命令行参数
    eg: #include <console.h>//for emulating command-line arguments
        int main(int argc,char *argv[])
        {
            argc = ccommand(&argv);//ccommand
        }
        运行时,ccommand()将在屏幕上显示一个对话框,其中包含一个可以输入命令行参数的框
        并且可以模拟重定向
4.是否在关闭文件后使用fin.clear()来清除流状态,这取决于将文件与ifstream对象关联时是否自动重置流状态
    使用fin.clear()是无害的

17.4.5 文件模式
(1).文件模式是描述文件如何被使用:读、写、追加等
    将流与文件关联时(构造函数或open方法),都可以提供指定文件模式的第二个参数
    eg: ifstream fin("banjo",mode1);//constructor woth mode argument
        ofstream fout();
        fout.open("harp",mode2);//open with mode argument
(2).ios_base类定义了一个openmode类型,用于表示模式:与fmtflags和iostate类型一样,它也是一种bitmask类型(以前为int)
    可以选择ios_base类中定义的多个常量来指定模式
    C++文件I/O做了一些改动,以便于ANSI C文件I/O兼容

                    文件模式常量
    常量                  含义
    ios_base::in          打开文件,以便读取
    ios_base::out         打开文件,以便写入
    ios_base::ate         打开文件,并移到文件尾
    ios_base::app         追加到文件尾
    ios_base::turnc        如果文件存在,则截短文件
    ios_base::binary      二进制文件
(3).ifstream和ofstream类的构造函数及open()方法都接受两个参数,且为第二个模式参数提供了默认值
    ifstream open()方法和构造函数使用ios_base::in作为模式参数的默认值
    ofstream open()方法和构造函数使用ios_base::out|ios_base::trunc作为默认值
    位操作符用于将两个位值合并成一个可用于同时设置两个位的值
    fstream类不提供默认的模式值,因此在创建这种类对象时,需显式指定模式
(4).ios_base::trunc意味着打开已有文件将删除其原有内容,极大地降低了磁盘空间耗尽的危险
    在打开文件时不删除其内容,保留文件内容并在其后追加:ios_base::app
    eg: ofstream fout("bagels",ios_base::out | ios_base::app);
        向文件中追加输出
(5).老式C++实现之间有一些差异,有些实现允许省略4中例子的ios_base::out,有些则不允许
    如果不使用默认模式,则最安全的方法是显式地提供所有的模式元素
    有些不支持上表中的选项,有些则提供了其他选项,C++标准提供了更高的统一性
(6).标准C++根据ANSI C标准I/O定义了部分文件I/O
    ifstream fin(filename,c++mode);
    fopen(filename,cmode);
    其中C++mode是一个openmode值,如ios_base::in,而cmode是相应的C模式字符串,如"r"
    下表列出了C++模式和C模式的对应关系
    注:ios_base::out本身将导致文件被截短,但与ios_base::in配合使用将不会被截短
        ios_base::in | ios_base::trunc将禁止文件被打开,is_open()将用于检测这种情况

                    C++和C的文件打开模式
    C++模式                                 C模式                 含义
    ios_base::in                            "r"                   打开以读取
    ios_base::out                           "w"                   等价于ios_base::out | ios_base::trunc
    ios_base::out | ios_base::trunc         "w"                   打开以写入,如果已经存在,则截短文件
    ios_base::out | ios_base::app           "a"                   打开以写入,只追加
    ios_base::out | ios_base::in            "r+"                  打开以读写,在文件允许的位置写入
    ios_base::out | ios_base::in | ios_base::trunc  "w+"          打开以读写,如果已经存在,则首先截短文件
    ios_base::out | ios_base::binary        "cmodeb"              以C++mode(或相应的Cmode)和二进制模式打开,例如,ios_base::in | ios_base::binary称为"rb"
    ios_base::out | ios_base::ate           "cmode"               以指定的模式打开,并移动到文件尾,C使用一个独立的函数调用而不是模式编码,例如,ios_base::in | ios_base::ate转换为"r"模式和C函数调用fseek(file,0,SEEK_END);
    注:ios_base::app和ios_base::ate都将文件指针指向打开文件的末尾,二者的区别在于,ios_base::app只允许将数据添加到文件尾
        而ios_base::ate模式将指针放到文件尾
1.追加文件
(1)在早期,C++的I/O是其最不标准的部分,很多老式C++都不遵循当前标准
    有些编译器使用nocreate等模式,而这些模式不是当前标准的组成部分
    只有一部分编译器要求在第二次打开同一个文件进行读取前调用fin.clear()
2.二进制文件
(1)将数据存储在文件中时,可以将其存储为文本格式或二进制格式
    文本格式是将所有内容都存储为文本(包括数字)
    eg: 将-2.324216e+07存储为文本格式时,将存储包该数字包含的13个字符
        这需要将浮点数的计算机内部表示转换为字符格式,这正是<<插入操作符完成的工作
    二进制格式指的是存储值的计算机内部表示
    eg: 计算机不存储字符串,而是存储这个值的64位double表示
    对于字符来说,二进制表示与文本表示是一样的,即字符的ASCII码的二进制表示
    对于数字来说,二进制表示与文本表示有很大差别
(2)每种格式都有自己的优点
    文本格式便于读取,可以是用编辑器或字处理器来读取文本文件,可以很方便的将文本文件从一个系统传输到另一个系统
    二进制格式对于数字来说比较精确,因为它存储的值是数值的内部表示,因此不会有转换误差或舍入误差
    以二进制格式保存数据更快,因为不需要转换,可以大块地存储数据
    二进制格式通常占用空间较小,这取决于数据的特征
    如果另一个系统使用另一种内部表示,则无法互相进行数据传输
    同一系统上的不同编译器也可能使用不同的内部结构布局表示
    这种情况下,必须编写一个将一种数据结构转换为另一种的程序
    eg: const int LIM = 20;
        struct planet{
            char name[LIM];
            double population;
            double g;
        };
        planet pl;
        要将结构以文本格式保存:
        ofstream fout("planet.dat",ios_base::out | ios_base::app);
        fout << pl.name << " " << pl.population << " " << pl.g << "\n";
        这样必须显式地提供每个结构成员以及将数据区分
        以二进制格式存储相同的信息:
        ofstream fout("planet.dat",ios_base::out | ios_base::app | ios_base::binary);
        fout.write((char *)pl,sizeof(pl));
        使用计算机的内部数据表示,将结构体做为一个整体保存
        不能将该文件做为文本文件读取,与文本相比,信息保存的更为紧凑、精确
        [1]使用二进制文件
        [2]使用write(data,size)成员函数
        有些系统DOS支持两种格式:文本格式和二进制格式
        如果要以二进制格式保存数据,应使用二进制文件格式ios_base::binary
        注:二进制文件和文本文件
        使用二进制文件模式时,程序将数据从内存传输给文件(反之亦然)时,将不会发生任何隐藏的转换
        而默认的文本模式并非如此
        对于DOS文本文件,它们使用两个字符的组合(回车和换行)表示换行符
        Macintosh文本文件使用回车来表示换行符
        而UNIX和Linux文件使用换行(linefeed)来表示换行符
        C++是从UNIX系统上发展而来的,因此也使用换行(linefeed)来表示换行符
        为增加可移植性,C++DOS程序在写文本文件时,自动将C++换行符转换为回车和换行符
        Maintosh C++程序在写文件时,自动将回车转换为换行符
        在读取文本文件时,这些程序将本地换行符转换为C++格式
        对于二进制数据,文本格式会引起问题,因此double值中间的字节可能与换行符的ASCII码有相同的位模式
        另外,在文件尾的检测方式也有区别
        因此以二进制格式保存数据时,应使用二进制文件模式
        (UNIX系统只有一种文件模式,二进制模式和文本模式是一样的)
(3)要以二进制格式(不是文本格式)存储数据,可以使用write()成员函数
    这种方法将内存中指定字节数的数据复制到文件中,仅进行逐字节地复制而不进行任何转换
    例如将long类型变量的地址传递给write,并命令它复制4个字节,它将复制long值中的4个字节,而不会将它转换为文本
    且必须将地址强制转换为char *
    eg: fout.write((char *)&pl,sizeof(pl));
        将pl所占字节数以二进制格式复制到文件中
        可以使用ifstream对象和read()方法读取write()方法写入的二进制格式数据
        ifstream fin("planets.dat",ios_base::in | ios_base::binary);
        fin.read((char *)pl,sizeof(pl));
        这将从文件中赋值sizeof(pl)个字节到结构体pl中
        同样的方法也适用于不适用虚函数的类
        这种情况下,只有数据成员将被保存,而方法不会保存
        如果类有虚方法,则也将复制隐藏指针(该指针指向虚函数表)
        程序在下一次运行时,虚函数表可能在不同的位置,将就指针复制到对象中,是没有意义的
    注:read()和write()成员函数的功能是相反的
        虽然二进制文件概念是ANSI C的组成部分,但一些C和C++实现并没有提供对二进制文件模式的支持
        原因在于:有些系统只有一种文件类型,因此可以将二进制操作(read()和write())用于标准文件格式
        不能够使用string对象进行文本或二进制的读取写入,string对象本身并没有包含字符串
        而是包含一个指向字符串的指针成员,因此将结构复制到文件中,复制的不是字符串数据,而是字符串的地址
        再次运行时,该地址将毫无意义

17.4.6 随机存取
1.随机存储指的是直接移动到文件的任何位置,而不是依次移动
2.随机存取常被用于数据库文件,程序维护一个独立的索引文件,该文件指出数据在主数据文件中的位置
    这样程序便可以直接跳到这个位置,读取或修改其中的数据
    如果文件由相同长度的记录组成,这种方法实现起来最简单
    每条记录表示一组相关的数据,文件记录对应与程序结构或类
3.fstream类是从iostream类派生而来的,而后者是基于istream和ostream两个类的
    因此iostream和fstream继承了它们的方法,并且继承了两个缓冲区
    一个用于输入,一个用于输出,并且能够同步化这两个缓冲区的处理
    当程序读写文件时,它将能够协调地移动输入缓冲区的输入指针和输出缓冲区中的输出指针
    eg: 范例将完成以下工作
        [1]显式文件的当前内容
        [2]询问要修改哪条记录
        [3]修改该记录
        [4]显式修改后的文件
        二进制文件由binary.cpp创建
        需要使用的文件模式:
            读取文件:ios_base::in
            执行二进制I/O:ios_base::binary
            写入文件:ios_base::out |ios_base::app
                ios_base::app模式将只允许向文件尾追加数据,其余部分为只读的
            同时使用in和out模式将得到读写模式,添加ios_base::binary模式获取二进制读写模式
            finout.open(file,ios_base::in | ios_base::out | ios_base::binary);
            需要在文件中移动的方式
            fstream类继承了两个方法:seekg()、seekp()
            前者将输入指针移动到指定的位置
            后者将输出指针移动到指定的位置
            由于fstream类使用缓冲区来存储中间数据,因此指针指向的是缓冲区中的位置,而不是实际的文件
            可以将seekg()应用于ifstream对象,将seekp()应用于ofstream对象
            seekg()的原型:
            basic_istream<charT,traits> & seekg(off_type,ios_base::seekdir);
            basic_istream<charT,traits> & seekg(pos_type);
            它们都是模板,使用char具体化,其原型等价于
            istream & seekg(streamoff,ios_base::seekdir);
            istream & seekg(streampos);
            第一个原型定位到离第二个参数指定的文件位置特定距离(单位为字节)的位置
            第二个原型定位到离文件开头特定距离(单位为字节)的位置
4.类型升级
    C++早期,seekg()方法比较简单,streamoff和streapos类型时一些标准整型(long)的typedef
    但为了创建可移植性,必须处理这样的现实情况
    对于有些系统,整数参数无法提供足够的信息,因此streamoff和streapos允许是结构或类类型
    条件是它们允许一些基本操作,如使用整数值做为初始值
    随后,老版本的istream类被basic_istream模板取代,streamoff和streampos被basic_istream模板取代
    不过streamoff和streampos仍然存在,作为pos_type、off_type的char的具体化
    同样,如果将seekg()应用于wistream对象,则可以使用wstreamoff和wstreampos类型
5.seekg()的第一个原型的参数
    streamoff被用来度量相对于文件特定位置的偏移量(单位为字节)
    streamoff表示相对于三个位置之一的偏移量为特定值(字节单位)的文件位置(类型可为整型或类)
    seekdir是ios_base定义的另一种整型,有3个可能的值
    ios_base::beg   //相对于文件开始位置的偏移量
    ios_base::cur   //相对于当前位置的偏移量
    ios_base::end   //相对于文件尾的偏移量
    eg: fin;//ifstream
        fin.seekg(30,ios_base::beg);//30 bytes beyond the beginning
        fin.seekg(-1,ios_base::cur);//back up one byte
        fin.seekg(0,ios_base::end);//go to the end of file
6.seekg()的第二个原型
    streampos类型的值定位到文件中的一个位置
    它可以是类,这个类将包含一个接受streamoff参数和一个整数参数的构造函数
    以便将两种类型转换为streampos值
    streampos表示文件中的绝对位置,从文件开始处算起
    可以将streampos看做是相对于文件开始处的位置
    eg: fin.seekg(112);
        文件指针移动112个字节,实际指向的是第113个字节
7.获取文件指针的当前位置
    对于输入流可以使用tellg(),对于输出流可以使用tellp()
    它们都返回一个表示当前位置的streampos值(相对于文件开始的字节数)
8.创建fstream对象时,输入和输出指针将一前一后地移动,tellg()和tellp()的返回值相同
    如果使用istream对象来管理输入流,使用ostream对象来管理同一个文件的输出流,则输入和输出指针将彼此独立地移动
    tellg()和tellp()将返回不同的值
    eg: [1]打开文件并将指针移动到文件开头显示内容
        fstream finout;
        finout.open(file,ios_base::in | ios_base::out | ios_base::binary);
        int ct = 0;
        if(finout.is_open())
        {
            finout.seekg(0);//go to beginning
            cout << "Here are the current content of the "
                << file << "file:\n";
                while(finout.read((char *)pl,sizeof(pl)))
                {
                    cout << ct++ << ":" << setw(LIM) << pl.name
                        << setprecision(0) << setw(12) << pl.population
                        << setprecision(2) << setw(6) << pl.g << endl;
                }
                if(finout.eof())
                    finout.clear();//clear eof flag
                else
                {
                    cerr << "Error in reading " << file << ".\n";
                    exit(EXIT_FAILURE);
                }
        }
        else
        {
            cerr << file << " could not be opened -- bye.\n";
            exit(EXIT_FAILURE);
        }
        读取并显示整个文件后,将设置efobit元素,这使得程序认为已处理完文件并禁止进一步读写
        使用clear()方法重置流状态,打开eofbit,程序便可以再次访问文件
        [2]修改指定记录编号的记录
            将编号与记录包含的字节数相乘,得到该记录的第一个字节编号
            record * sizeof(pl)
            cout << "Enter the record number you wish to change:";
            long rec;
            cin >> rec;
            eatline();
            if(rec < 0 || rec >= ct)
            {
                cerr << "Invalid record number --bye\n";
                exit(EXIT_FAILURE);
            }
            streampos place = rec * sizeof(pl);//conver to streampos type
            finout.seekg(streampos);//random access
            ct表示记录号,超出文件尾程序将终止
        [3]显示当前的记录
            finout.read((char *)pl,sizeof(pl));
            cour << "Your selection:\n";
            cout << rec << ":" << setw(LIM) << pl.name
                << setprecision(0) << setw(12) << pl.population
                << setprecision(2) << setw(6) << pl.g << endl;
            if(finout.eof())
                finout.clear();
        [4]显示当前记录后进行修改
            cout << "Enter planet name:";
            cin.get(pl.name,LIM);
            eatline();
            cout << "Enter planetary population:";
            cin >> pl.population;
            cout << "Enter planet's acceleration of gravity:";
            cin >> pl.g;
            finout.seekp(place);//go back
            finout.write((char *)pl,sizeof(pl)) << flush;
            if(finput.fail())
            {
                cerr << "Error on attempted write\n";
                exit(EXIT_FAILURE);
            }
            程序刷新输出,以便进入下一步之前文件被更新
            使用seekp()将输出指针指向当前记录的开头
9.使用临时文件
    (1)为临时文件指定唯一的名称,cstdio中的tmpnam()函数
        char *tmpnam(char *pszName);
        tmpnam()创建一个临时文件名,将其放置到pszName指定的C风格字符串中
        常量L_tmpnam和TMP_MAX都是在头文件cstdio中定义的
        限制了文件名称包含的字符数以及确保在当前目录中不生成重复的文件名的情况下tmpnam()可被调用的最多次数
        eg: #include <cstdio>
            #include <iostream>

            int main()
            {
                using namespace std;

                cout << "This system can generate up to " << TMP_MAX
                    << " temporary names of up to " << L_tmpnam
                    << " characters.\n";
                char pszName[L_tmpnam] = {'\0'};
                cout << "Here are ten names:\n";
                for(int i = 0;i < 10;i++)
                {
                    tmpnam(pszName);
                    cout << pszName << endl;
                }

                return 0;
            }
            tmpnam可以生成TMP_MAX个不同的文件名,其中每个文件名包含的字符不超过L_tmpnam个

17.5 内核格式化
1.iostream提供了程序与终端之间的IO,fstream使用相同的接口提供程序与文件之间的IO
    C++还提供了sstream,它们使用相同的接口提供程序和string对象之间的IO
    可以使用于cout的ostream方法将格式化信息写入到string对象中
    并使用istream方法(getline())来读取string对象中的信息
2.读取string对象中的格式化信息或将格式化信息写入string对象中被称为内核格式化(incore formatting)
    string的sstream族支持取代了char数组的strstream.h族支持
3.sstream头文件定义了一个从ostream类派生而来的ostringstream类(还有一个基于wostream的wostringstream类,这个类用于宽字符集)
    如果创建了ostringstream对象,则可以将信息写入其中,它将存储这些信息
    可以将用于cout的方法用于ostringstream对象
    eg: ostringstream outstr;
        double price = 281.00;
        char *ps = " for a copy of the ISO/EIC C++ standard!";
        outstr.precision(2);
        outstr << fixed;
        outstr << "Pay only $" << price << ps << endl;
        格式化文本进入缓冲区,必要情况下,该对象将使用动态内存分配来增大缓冲区
        ostringstream有一个str()成员函数,该函数返回一个被初始化为缓冲区内容的字符串对象
        string msg = outstr.str();//returns string with formatted information
        使用str()方法可以冻结该对象,这样便不能将信息写入到该对象中
4.istringstream类允许使用istream方法读取istringstream对象中的数据,istringstream对象可以使用string对象进行初始化
    eg: istringstream instr(facts);//string facts
        可以使用istringstream对象来读取facts的内容
        instr包含字符格式的整数
        int n,sum = 0;
        while(instr >> n)
            sum += n;
6.ostringstream和istringstream使得可以使用istream和ostream类的方法来管理string对象存储的数据












            


    






            





        




    




        





    





















        



    
