第十七章 输入、输出和文件

1.C++输入和输出(简称I/O),使用istream和ostream进行标准输入和输出,使用ifstream和ofstream进行文件输入和输出
2.用于文件输入和输出的C++工具都是基于cin和cout所基于的基本类定义

17.1 C++输入和输出概述
1.对数计算机语言的输入和输出是以语言本身为基础实现的,BASIC、Pascal等语言的关键字列表中有输出关键字
    PRINT、Writeln都是语言词汇表的组成部分,C/C++都没有将输入和输出建立在语言中
    这两种语言都包括for和if关键字,但不包括与I/O有关的内容
    C语言最初是将I/O留给了编译器实现人员,这样编译器实现人员可自由设计I/O函数
    使之最适合于目标计算机的硬件要求
    实际上,多数实现人员都把I/O建立在最初为UNIX环境开发的库函数基础之上
    ANSI正式承认这个I/O软件包时,将其称为标准输入/输出包,并将其作为标准C库不可或缺的组成部分
    C++也认可这个软件包,熟悉stdio.h文件中声明的C函数,则可在C++程序中使用它们(cstdio)
    不过C++依赖于C++的I/O解决方案,而不是C语言的I/O解决方案
    前者是在头文件iostream(iostream.h)和fstream(fstream.h)中定义一组类
    这个类库不是正式语言定义的组成部分(cin和istream不是关键字)
    计算机语言定义了如何工作(如如何创建类)的规则,但没有定义要按照这些规则创建哪些东西
    正如C实现自带了一个标准库函数一样,C++也自带了一个标准类库
    首先,标准类库是一个非正式的标准,只是由头文件iostream和fstream中定义的类组成
    ANSI/ISO C++标准委员会决定把这个类正式作为一个标准类库,并添加一些其它标准类,如STL
    先看看C++I/O概念框架

17.1.1 流和缓冲区
1.C++程序把输入和输出看做字节流
    输入时,程序从输入流中抽取字节,输出时,程序将字节插入到输出流中
    对于面向文本的程序,每个字节代表一个字符,字节可以构成字符或数值数据的二进制表示
2.输入流中的字节可能来自键盘,也可能来自存储设备,硬盘或其他设备
    同样,输出流中的字节可以流向屏幕、打印机、存储设备或其他程序
    流充当了程序和流源或流目标之间的桥梁
    这使得C++程序可以用相同的方式对待来自键盘的输入和来自文件的输入
    C++程序只是检查字节流,而不需要知道字节来自何方
    通过使用流,C++程序处理输出的方式将独立于其去向,因此管理输入包含两步:
    [1]将流与输入去向的程序关联起来
    [2]将流与文件连接起来
    输入流需要两个连接,每端各一个
    文件端连接提供了流的来源,程序端将流的流出部分转存到程序中(文件端连接可以是文件、设备(键盘))
    对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来
3.通常,通过使用缓冲区可以更高效地处理输入和输出
    缓冲区是用作中介的内存块,它是将信息从设备传输到程序或从程序传输给设备的临时存储工具
    通常像磁盘驱动器这样的设备以512字节(或更多)的块为单位来传输信息,而程序通常每次只能处理一个字节的信息
    缓冲区帮助匹配这两种不同的信息传输速率
    eg: 程序要计算记录在硬盘文件中的金额
        程序可以从文件中读取一个字符,处理它,再从文件中读取下一个字符,再处理,依此类推
        从文件中每次读取一个字符需要大量的硬件活动,速度非常慢
        缓冲方法则从磁盘上读取大量信息,将这些信息存储在缓冲区中,然后每次从缓冲区中读取一个字节
        因为从内存中读取单个字节的速度比从硬盘上读取快很多,所以这种方法更快,也更方便
        当然,到达缓冲区末尾后,程序将从磁盘上读取另一块数据
        输出时,程序首先填满缓冲区,然后把整块数据传递给硬盘,并清空缓冲区,以备下一批输出使用
        这被称为刷新缓冲区(flushing the buffer)
4.键盘输入每次提供一个字符,程序无需缓冲区来帮助匹配不同的数据传输速率
    对键盘输入进行缓冲可以让用户在将输入传输给程序之前返回并更正
    C++通常在用户按下回车键时刷新输入缓冲区
    对于屏幕输出,C++程序通常在用户发送换行符时刷新缓冲区
    程序也可能在其他情况下刷新输入,输入即将到来时,这取决于实现
    当程序到达输入语句时,它将刷新输出缓冲区中当前所有的输出
    与ANSI C一致的C++实现是这样工作的

17.1.2 流、缓冲区和iostream文件
1.iostream(iostream.h)中专门设计了用来管理流和缓冲区的类
    最新版本C++I/O定义了一些模板,以支持char和wchar_t数据
    通过typedef工具,C++使得这些模板char具体化能够模仿传统的非模板I/O实现
    提供的一些类
    [1]streambuf类为缓冲区提供了内存,并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的方法
    [2]ios_base类表示流的一般特征,如是否可读取、是二进制流还是文本流等
    [3]ios类基于ios_base,其中包括了一个指向streambuf对象的指针成员
    [4]ostream类是从ios类派生而来的,提供了输出方法
    [5]istream类也是从ios类派生而来的,提供了输入方法
    [6]iostream类是基于istream和ostream类的,因此继承了输入方法和输出方法
    要使用这些工具,必须使用适当的类对象,使用ostream对象cout来处理输出,
    创建这样的对象将打开一个流,自动创建缓冲区,并将其与流关联起来,同时使得能够使用类成员函数
    char(8位),wchar_t(16位)
    为支持16位国际字符集,开发了一套I/O类模板,其中包括basic_istream<charT,traits<charT> >和basic_ostream<charT,traits<charT> >
    traits<charT>模板是一个模板类,为字符类型定义了具体特性,如何比较字符是否相等、字符的EOF值等
    该C++标准提供了I/O的char和wchar_t具体化
    istream和ostream都是char具体化的typedef
    wistream和wostream都是wchar_t具体化
    wcout用于输出宽字符流
    这些定义都包含在ostream头文件
    ios基类中的一些独立于类型的信息被移动到新的ios_base类中,包括各种格式化常量,ios::fixed(ios_base::fixed)
    ios_base还包含一些老式ios中没有的选项
2.C++的iostream类库管理了很多细节,在程序中包含iostream将自动创建8个流对象,4个用于窄字符流,4个用于宽字符流
    [1]cin:对应于标准输入流,在默认情况下这个流被关联到标准输入流(通常为键盘),wcin与此类似,但处理的是wchar_t类型
    [2]cout:对象与标准输出流相对应,在默认情况下,这个流被关联到标准输出流(通常为显示器),wcout与此类似,但处理的是wchar_t类型
    [3]cerr:对象与标准错误流相对应,可用于显示错误消息,在默认情况下这个流被关联到标准输出设备(通常为显示器)
        这个流没有被缓冲,这意味着信息将被直接发送给屏幕,而不会等到缓冲区填满或新的换行符,wcerr对象与此类似,但处理的是wchar_t类型
    [4]clog:对象也对应着标准错误流,在默认情况下,这个流被关联到标准输出设备(通常为显示器),这个流被缓冲,wclog对象与此类似,但处理的是wchar_t类型
3.对象代表流,iostream文件为程序声明一个cout对象时,该对象将包含存储了与输出有关的信息的数据成员
    如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法、以及描述用来处理输出流的缓冲区的streambuf对象的地址
    eg: cout << "Bjarne free";
        通过指向的streambuf对象将字符串中的字符放置到cout管理的缓冲区中,ostream类定义了operator<< ()函数
        ostream还支持cout数据成员及其他大量类方法
        来自缓冲区的输出被引导到标准输出
        流的一端与程序相连,另一端与标准输出相连,cout对象凭借streambuf对象的帮助,管理者流中的字节流

17.1.3 重定向
1.标准输入和输出流通常连接着键盘和屏幕,但很多操作系统(UNIX、Linux、MS-DOS)都支持重定向
    这个工具使得能够改变标准输入和输出
    eg: 将输入重定向到文件并将输出重定向另一个文件
        读取文件中的字符数
        counter <oklahoma >cow_cnt
        命令行中<oklahoma将标准输入与文件关联起来,使cin从文件而不是键盘读取输入
        操作系统改变了输入流的流入端连接,而流出端仍然与程序相连
        命令行中>cow_cnt将标准输出与文件关联起来,导致cout将输出发送到文件而不是屏幕
        操作系统改变了输出流的流出端连接,而流入端仍与程序相连
2.cout代表的标准输出流是程序输出的常用通道
    标准错误流由cerr和clog代表,用于程序的错误消息
    默认情况下这三个对象都被发送给显示器
    但是对标准输出重定向并不会影响cerr和clog
    当常规的cout标准输出被重定向到其他地方,使用其中一个对象来打印错误消息,程序将在屏幕上显示错误消息
    eg: if(success)
            std::cout << "Here come the goodies!\n";
        else
        {
            std::cerr << "Something horrible has happened.\n";
            exit(1);
        }
        未重定向则所有消息都将显示在屏幕上,如果程序输出被重定向到文件,则第一条消息将被发送到文件中
        而第二条将被发送到屏幕
        有些系统允许对标准错误进行重定向,UNIX、Linux中,操作符2>重定向标准错误

17.2 使用cout进行输出
1.C++将输出看做字节流(16位或32位字节),但在程序中很多数据被组织成比字节更大的单位
    int由16位或32位的二进制值表示,double由64位的二进制数据表示
    但在将字节流发送给屏幕时,希望每个字节表示一个字符值
    要在屏幕上显示-2.34,需要将5个字符(-,2,.,3,4),而不是这个值的64位内部浮点表示发送到屏幕上
    ostream最重要的任务之一是将数值类型(int/float)转换为以文本形式表示的字符流
    ostream类将数据内部表示(二进制位模式)转换为由字符字节组成的输出流
    为执行这些转换任务,ostream类提供了多个类方法

17.2.1 重载的<<操作符
(1)在C++中,与C一样,<<操作符的默认含义是按位左移操作符
    表达式x << 3将x的二进制表示中所有的位向左移动3位
    ostream类重新定义了<<操作符,方法是将其重载为输出,这种情况下<<叫做插入操作符
    而不是左移操作符,插入操作符被重载以支持C++中所有的基本类型
    基本类型:
    unsigned char
    signed char
    char 
    short
    unsigned short
    int
    unsigned int
    long
    unsigned long
    float
    double
    long double
    上述每种类型,ostream类都提供了operator<< ()函数的定义
    eg: cout << value;//value为前面列出的类型之一
        则C++程序将其对应于有相应特征的操作符函数
        cout << 88;
        对应于下面的方法原型
        ostream & operator<< (int);
        该原型表明,operator<< (int)接受一个int参数,这与上述语句相匹配
        并且该函数返回一个ostream对象的引用,以便可以进行链式调用
        cout << "I'm feeling sedimental over " << boundary << "\n";
1.输出和指针
(1)ostream类还为下面的指针类型定义了插入操作符函数
    [1]const signed char *
    [2]const unsigned char *
    [3]const char *
    [4]void *
(2)C++使用指向字符串存储位置的指针来表示字符串
    指针的形式可以是char数组名或显式的point-to-char或引号括起的字符串
    eg: char name[20] = "Dudly Diddlemore";
        char *pn = "Violet D'Amore";
        cout << "Hello!";
        cout << name;
        cout << pn;
        方法使用字符串中的终止空字符来确定何时停止显式字符
        对于其他类型的指针,C++将其对应于void *,并打印地址的数值表示,如果要获得字符串的地址,则必须将其强制转换为其他类型
        int eggs = 12;
        char *amount = "dozen";
        cout << &eggs;//print address of eggs variable
        cout << amount;//print the string dozen
        cout << (void *)amount;//print the address of the "dozen" string
        老式C++实现没有接受void *的原型,要打印地址值,必须将指针强制转换为unsigned或unsigned long
2.拼接输出
(1)插入操作符的所有化身的返回类型都是ostream &,其原型如下
    ostream & operator<< (type);
    type为要显示的数据类型,返回类型ostream &意味着使用该操作符将返回一个指向ostream对象的引用
    引用将指向调用该操作符的对象,操作符函数的返回值为调用操作符的对象
    这种特性使得能够通过插入连接输出
    eg: cout << "We have " << count << " unhatched chickens.\n";
        =>
        cout << count << " unhatched chickens.\n";
        =>
        cout << << " unhatched chickens.\n";



        



    
