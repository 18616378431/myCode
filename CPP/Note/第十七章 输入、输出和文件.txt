第十七章 输入、输出和文件

1.C++输入和输出(简称I/O),使用istream和ostream进行标准输入和输出,使用ifstream和ofstream进行文件输入和输出
2.用于文件输入和输出的C++工具都是基于cin和cout所基于的基本类定义

17.1 C++输入和输出概述
1.对数计算机语言的输入和输出是以语言本身为基础实现的,BASIC、Pascal等语言的关键字列表中有输出关键字
    PRINT、Writeln都是语言词汇表的组成部分,C/C++都没有将输入和输出建立在语言中
    这两种语言都包括for和if关键字,但不包括与I/O有关的内容
    C语言最初是将I/O留给了编译器实现人员,这样编译器实现人员可自由设计I/O函数
    使之最适合于目标计算机的硬件要求
    实际上,多数实现人员都把I/O建立在最初为UNIX环境开发的库函数基础之上
    ANSI正式承认这个I/O软件包时,将其称为标准输入/输出包,并将其作为标准C库不可或缺的组成部分
    C++也认可这个软件包,熟悉stdio.h文件中声明的C函数,则可在C++程序中使用它们(cstdio)
    不过C++依赖于C++的I/O解决方案,而不是C语言的I/O解决方案
    前者是在头文件iostream(iostream.h)和fstream(fstream.h)中定义一组类
    这个类库不是正式语言定义的组成部分(cin和istream不是关键字)
    计算机语言定义了如何工作(如如何创建类)的规则,但没有定义要按照这些规则创建哪些东西
    正如C实现自带了一个标准库函数一样,C++也自带了一个标准类库
    首先,标准类库是一个非正式的标准,只是由头文件iostream和fstream中定义的类组成
    ANSI/ISO C++标准委员会决定把这个类正式作为一个标准类库,并添加一些其它标准类,如STL
    先看看C++I/O概念框架

17.1.1 流和缓冲区
1.C++程序把输入和输出看做字节流
    输入时,程序从输入流中抽取字节,输出时,程序将字节插入到输出流中
    对于面向文本的程序,每个字节代表一个字符,字节可以构成字符或数值数据的二进制表示
2.输入流中的字节可能来自键盘,也可能来自存储设备,硬盘或其他设备
    同样,输出流中的字节可以流向屏幕、打印机、存储设备或其他程序
    流充当了程序和流源或流目标之间的桥梁
    这使得C++程序可以用相同的方式对待来自键盘的输入和来自文件的输入
    C++程序只是检查字节流,而不需要知道字节来自何方
    通过使用流,C++程序处理输出的方式将独立于其去向,因此管理输入包含两步:
    [1]将流与输入去向的程序关联起来
    [2]将流与文件连接起来
    输入流需要两个连接,每端各一个
    文件端连接提供了流的来源,程序端将流的流出部分转存到程序中(文件端连接可以是文件、设备(键盘))
    对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来
3.通常,通过使用缓冲区可以更高效地处理输入和输出
    缓冲区是用作中介的内存块,它是将信息从设备传输到程序或从程序传输给设备的临时存储工具
    通常像磁盘驱动器这样的设备以512字节(或更多)的块为单位来传输信息,而程序通常每次只能处理一个字节的信息
    缓冲区帮助匹配这两种不同的信息传输速率
    eg: 程序要计算记录在硬盘文件中的金额
        程序可以从文件中读取一个字符,处理它,再从文件中读取下一个字符,再处理,依此类推
        从文件中每次读取一个字符需要大量的硬件活动,速度非常慢
        缓冲方法则从磁盘上读取大量信息,将这些信息存储在缓冲区中,然后每次从缓冲区中读取一个字节
        因为从内存中读取单个字节的速度比从硬盘上读取快很多,所以这种方法更快,也更方便
        当然,到达缓冲区末尾后,程序将从磁盘上读取另一块数据
        输出时,程序首先填满缓冲区,然后把整块数据传递给硬盘,并清空缓冲区,以备下一批输出使用
        这被称为刷新缓冲区(flushing the buffer)
4.键盘输入每次提供一个字符,程序无需缓冲区来帮助匹配不同的数据传输速率
    对键盘输入进行缓冲可以让用户在将输入传输给程序之前返回并更正
    C++通常在用户按下回车键时刷新输入缓冲区
    对于屏幕输出,C++程序通常在用户发送换行符时刷新缓冲区
    程序也可能在其他情况下刷新输入,输入即将到来时,这取决于实现
    当程序到达输入语句时,它将刷新输出缓冲区中当前所有的输出
    与ANSI C一致的C++实现是这样工作的

17.1.2 流、缓冲区和iostream文件
1.iostream(iostream.h)中专门设计了用来管理流和缓冲区的类
    最新版本C++I/O定义了一些模板,以支持char和wchar_t数据
    通过typedef工具,C++使得这些模板char具体化能够模仿传统的非模板I/O实现
    提供的一些类
    [1]streambuf类为缓冲区提供了内存,并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的方法
    [2]ios_base类表示流的一般特征,如是否可读取、是二进制流还是文本流等
    [3]ios类基于ios_base,其中包括了一个指向streambuf对象的指针成员
    [4]ostream类是从ios类派生而来的,提供了输出方法
    [5]istream类也是从ios类派生而来的,提供了输入方法
    [6]iostream类是基于istream和ostream类的,因此继承了输入方法和输出方法
    要使用这些工具,必须使用适当的类对象,使用ostream对象cout来处理输出,
    创建这样的对象将打开一个流,自动创建缓冲区,并将其与流关联起来,同时使得能够使用类成员函数
    char(8位),wchar_t(16位)
    为支持16位国际字符集,开发了一套I/O类模板,其中包括basic_istream<charT,traits<charT> >和basic_ostream<charT,traits<charT> >
    traits<charT>模板是一个模板类,为字符类型定义了具体特性,如何比较字符是否相等、字符的EOF值等
    该C++标准提供了I/O的char和wchar_t具体化
    istream和ostream都是char具体化的typedef
    wistream和wostream都是wchar_t具体化
    wcout用于输出宽字符流
    这些定义都包含在ostream头文件
    ios基类中的一些独立于类型的信息被移动到新的ios_base类中,包括各种格式化常量,ios::fixed(ios_base::fixed)
    ios_base还包含一些老式ios中没有的选项
2.C++的iostream类库管理了很多细节,在程序中包含iostream将自动创建8个流对象,4个用于窄字符流,4个用于宽字符流
    [1]cin:对应于标准输入流,在默认情况下这个流被关联到标准输入流(通常为键盘),wcin与此类似,但处理的是wchar_t类型
    [2]cout:对象与标准输出流相对应,在默认情况下,这个流被关联到标准输出流(通常为显示器),wcout与此类似,但处理的是wchar_t类型
    [3]cerr:对象与标准错误流相对应,可用于显示错误消息,在默认情况下这个流被关联到标准输出设备(通常为显示器)
        这个流没有被缓冲,这意味着信息将被直接发送给屏幕,而不会等到缓冲区填满或新的换行符,wcerr对象与此类似,但处理的是wchar_t类型
    [4]clog:对象也对应着标准错误流,在默认情况下,这个流被关联到标准输出设备(通常为显示器),这个流被缓冲,wclog对象与此类似,但处理的是wchar_t类型
3.对象代表流,iostream文件为程序声明一个cout对象时,该对象将包含存储了与输出有关的信息的数据成员
    如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法、以及描述用来处理输出流的缓冲区的streambuf对象的地址
    eg: cout << "Bjarne free";
        通过指向的streambuf对象将字符串中的字符放置到cout管理的缓冲区中,ostream类定义了operator<< ()函数
        ostream还支持cout数据成员及其他大量类方法
        来自缓冲区的输出被引导到标准输出
        流的一端与程序相连,另一端与标准输出相连,cout对象凭借streambuf对象的帮助,管理者流中的字节流

17.1.3 重定向
1.标准输入和输出流通常连接着键盘和屏幕,但很多操作系统(UNIX、Linux、MS-DOS)都支持重定向
    这个工具使得能够改变标准输入和输出
    eg: 将输入重定向到文件并将输出重定向另一个文件
        读取文件中的字符数
        counter <oklahoma >cow_cnt
        命令行中<oklahoma将标准输入与文件关联起来,使cin从文件而不是键盘读取输入
        操作系统改变了输入流的流入端连接,而流出端仍然与程序相连
        命令行中>cow_cnt将标准输出与文件关联起来,导致cout将输出发送到文件而不是屏幕
        操作系统改变了输出流的流出端连接,而流入端仍与程序相连
2.cout代表的标准输出流是程序输出的常用通道
    标准错误流由cerr和clog代表,用于程序的错误消息
    默认情况下这三个对象都被发送给显示器
    但是对标准输出重定向并不会影响cerr和clog
    当常规的cout标准输出被重定向到其他地方,使用其中一个对象来打印错误消息,程序将在屏幕上显示错误消息
    eg: if(success)
            std::cout << "Here come the goodies!\n";
        else
        {
            std::cerr << "Something horrible has happened.\n";
            exit(1);
        }
        未重定向则所有消息都将显示在屏幕上,如果程序输出被重定向到文件,则第一条消息将被发送到文件中
        而第二条将被发送到屏幕
        有些系统允许对标准错误进行重定向,UNIX、Linux中,操作符2>重定向标准错误

17.2 使用cout进行输出
1.C++将输出看做字节流(16位或32位字节),但在程序中很多数据被组织成比字节更大的单位
    int由16位或32位的二进制值表示,double由64位的二进制数据表示
    但在将字节流发送给屏幕时,希望每个字节表示一个字符值
    要在屏幕上显示-2.34,需要将5个字符(-,2,.,3,4),而不是这个值的64位内部浮点表示发送到屏幕上
    ostream最重要的任务之一是将数值类型(int/float)转换为以文本形式表示的字符流
    ostream类将数据内部表示(二进制位模式)转换为由字符字节组成的输出流
    为执行这些转换任务,ostream类提供了多个类方法

17.2.1 重载的<<操作符
(1)在C++中,与C一样,<<操作符的默认含义是按位左移操作符
    表达式x << 3将x的二进制表示中所有的位向左移动3位
    ostream类重新定义了<<操作符,方法是将其重载为输出,这种情况下<<叫做插入操作符
    而不是左移操作符,插入操作符被重载以支持C++中所有的基本类型
    基本类型:
    unsigned char
    signed char
    char 
    short
    unsigned short
    int
    unsigned int
    long
    unsigned long
    float
    double
    long double
    上述每种类型,ostream类都提供了operator<< ()函数的定义
    eg: cout << value;//value为前面列出的类型之一
        则C++程序将其对应于有相应特征的操作符函数
        cout << 88;
        对应于下面的方法原型
        ostream & operator<< (int);
        该原型表明,operator<< (int)接受一个int参数,这与上述语句相匹配
        并且该函数返回一个ostream对象的引用,以便可以进行链式调用
        cout << "I'm feeling sedimental over " << boundary << "\n";
1.输出和指针
(1)ostream类还为下面的指针类型定义了插入操作符函数
    [1]const signed char *
    [2]const unsigned char *
    [3]const char *
    [4]void *
(2)C++使用指向字符串存储位置的指针来表示字符串
    指针的形式可以是char数组名或显式的point-to-char或引号括起的字符串
    eg: char name[20] = "Dudly Diddlemore";
        char *pn = "Violet D'Amore";
        cout << "Hello!";
        cout << name;
        cout << pn;
        方法使用字符串中的终止空字符来确定何时停止显式字符
        对于其他类型的指针,C++将其对应于void *,并打印地址的数值表示,如果要获得字符串的地址,则必须将其强制转换为其他类型
        int eggs = 12;
        char *amount = "dozen";
        cout << &eggs;//print address of eggs variable
        cout << amount;//print the string dozen
        cout << (void *)amount;//print the address of the "dozen" string
        老式C++实现没有接受void *的原型,要打印地址值,必须将指针强制转换为unsigned或unsigned long
2.拼接输出
(1)插入操作符的所有化身的返回类型都是ostream &,其原型如下
    ostream & operator<< (type);
    type为要显示的数据类型,返回类型ostream &意味着使用该操作符将返回一个指向ostream对象的引用
    引用将指向调用该操作符的对象,操作符函数的返回值为调用操作符的对象
    这种特性使得能够通过插入连接输出
    eg: cout << "We have " << count << " unhatched chickens.\n";
        =>
        cout << count << " unhatched chickens.\n";
        =>
        cout << " unhatched chickens.\n";

17.2.2 其他ostream方法
1.除了各种operator<< ()函数外,ostream类还提供了put()方法和write()方法,前者用于显示字符,后者用于显示字符串
2.最初put()的原型如下
    ostream & put(char);
    当前标准尊与此相同,但被模板化,以适用于wchar_t,可以用类方法表示法来调用它
    cout.put('W');//display the W character
    cout是调用方法的对象,put()是类成员函数,和<<操作符一样,该函数也返回指向调用对象的引用
    因此可以用它拼接输出
    cout.put('I').put('t');//displaying It with two put() calls
    函数调用cout.put("I")返回cout,然后cout被用作put('t')的调用对象
    在原型合适的情况下,可以将数值型参数(int)用于put(),让函数原型将参数值自动转换为正确的char值
    cout.put(65);//display the A character
    cout.put(66.3);//display the B character
    第一条语句将int值65转换为char值,然后显示ASCII码为65的字符
    第二条语句将double值66.3转换为char值66,并显示对应的字符
    这种行为在C++2.0之前可以派上用场
    在这些版本中,C++语言用int值表示字符常量
    cout << 'W';
    将'W'解释为int值,因此将其作为整数87(ASCII)显示出来
    cout.put('W');
    当前C++将char常量表示为char类型
    一些老式编译器错误地为char、unsigned char、signed char3中参数类型重载了put()
    这使得将int用于put()时具有二义性,int可被转换为这3中类型中的任何一种
3.write()方法:显示整个字符串,其模板原型
    basic_ostream<charT,traits> & write(const char_type *s,streamsize n);
    第一个参数提供了要显式字符串的地址
    第二个参数指出要显式多少个字符
    使用cout调用write()时将调用char具体化,因此返回类型为ostream &
    cout.write()调用返回cout对象,write()方法返回一个指向调用它的对象的引用‘
    这使得可以将输出拼接起来,cout.write()将被其返回值cout替换
    cout.write(state2,i) << endl;
    write()方法并不会在遇到空字符时自动停止打印字符,而只是打印指定数目的字符,即使超出的字符串的边界
    state2前后声明了亮娃两个字符串,以便相邻内存中有数据
    编译器在内存中存储数据的顺序以及调整内存的方式各不相同
    占用6个字节的字符串,由于编译器使用4个字节的倍数调整字符串,因此6个字节的字符串填充为占用8个字节
    write()方法也可以用于数值数据,可以将数字的地址强制转换为char *,然后传递给它
    long val = 560031841;
    cout.write((char *)&val,sizeof(long));
    long变量的4个字节中的每个字节将被作为单独的字节被传输
    输出设备将把每个字节作为ASCII码进行解释,因此在屏幕上这4个字节将被显式为4个字符组合

17.2.3 刷新输出缓冲区
1.ostream类对cout对象处理的输出进行缓冲,所以输出不会立即发送到目标地址,而是被存储在缓冲区中,直到缓冲区填满
    然后程序将刷新(flush)缓冲区,把内容发送出去,并清空缓冲区,以存储新的数据
    通常缓冲区为512字节或其整数倍
    当标准输出连接的是硬盘上的文件时,缓冲可以节省大量时间,以免程序为发送512字节而存取磁盘512次
    将512字节收集到缓冲区中,然后将它们一次性写入硬盘的效率要高得多
    对于屏幕输出,首先填满缓冲区的重要性要低得多
    屏幕输出时程序不必等到缓冲区被填满,将换行符发送到缓冲区将刷新缓冲区
    多数C++实现都会在输入即将发生时刷新缓冲区
    eg: cout << "Enter a number:";
        float num;
        cin >> num;
        程序期待输入这一事实,将导致它立刻显示cout消息,即使输出字符串中没有换行符
        如果没有这种特性,程序将等待输入,而无法通过cout来提示用户
        如果程序不能所希望的时候刷新输出,可以使用两个控制字符中的一个来强行进行刷新
        控制符flush刷新缓冲区,而控制符endl刷新缓冲区并插入一个换行符
        这两个控制符的使用方式与变量名相同
        cout << "Something" << flush;
        cout << "Something" << endl;
        事实上,控制符也是函数,可以直接使用flush()刷新cout缓冲区,flush(cout)
        ostream类对<<插入操作符进行了重载,使得表达式
        cout << flush;
        将被替换为函数调用flush(cout)
        可以使用更方便的插入表示法来成功进行刷新

17.2.4 使用cout进行格式化
(1).ostream插入操作符将值转换为文本格式
    默认情况下格式化值的方式如下:
    (1)对于char值,如果它代表的是可打印字符,则将被作为一个字符显示在宽度为一个字符的字段中
    (2)对于数值整型,将以十进制方式显示在一个刚好容纳该数字及负号(如果有)的字段中
    (3)字符串被显示在宽度等于该字符串长度的字段中
(2).浮点数的默认行为变化
    [1]新式:浮点类型被显示为6位,末尾的0不显示(显示的数字位数与数字被存储时的精度没有任何关系)
        数字以定点表示法显示还是以科学计数法表示,取决于它的值
        具体来说,当指数大于等于6或小于等于-5时,将使用科学计数法表示
        字段宽度恰好容纳数字和负号(如果有)
        默认的行为对应于带%g的说明符的标准C库函数fprintf()
    [2]老式:浮点类型显示为带6位小数,末尾的0不显示(显示的数字位数与数字被存储时的精度没有任何关系)
        数字以定点表示法还是以科学计数法表示,取决于它的值
        另外,字段宽度恰好容纳数字和负号(如果有)
        因为每个值的显示宽度都等于它的长度,因此必须显式地在值之间提供空格,否则相邻的值将不会被分开
    并非所有编译器都能生成符合当前C++标准格式的输出,当前标准允许区域性变化
    欧洲实现可能遵循欧洲人的风格:使用逗号,而不是句点来表示小数
    2.54将被些成2,54
    区域库(头文件locale)提供了用特定的风格影响(imbuing)输入或输出流的机制
    所以同一个编译器能够提供多个区域选项
    末尾不带0的浮点值后面将有6个空格,科学计数法的指数显示为3位,有些实现可能为2位
1.修改显示时使用的计数系统
    ostream类是从ios类派生而来的,而后者是从ios_base类派生而来的,ios_base类存储了描述格式状态的信息
    eg: 一个类的成员中某些位决定了使用的计数系统,而另一个成员则决定了字段宽度
    通过控制符(manipulator),可以控制显示整数时使用的计数系统
    通过使用ios_base的成员函数,可以控制字段宽度和小数位数
    ios_base类是ostream类的间接基类,可以将其方法应用于ostream对象(或子代),cout
    注:
        ios_base类中的成员和方法以前位于ios类中,现在ios_base是ios的基类
        在新系统中,ios是包含char和wchar_t具体化的模板,而ios_base包含了非模板特性
    eg: 显示整数时使用的计数系统
        要控制整数以十进制、十六进制、八进制显式,可以使用dec、hex、oct控制符
        hex(cout);
        将cout对象的计数系统格式状态设置为十六进制,程序将以十六进制形式打印整数值
        直到将格式状态设置为其他选项为止
    注:控制符不是成员函数,因此不必通过对象来调用
        控制符实际上是函数,但它们通常的使用方式为:
        cout << hex;
        ostream类重载了<<操作符,这使得上述用法与hex(cout)等效
        控制符位于名称空间std中
        可以单独使用控制符,也可以作为一系列插入的组成部分
2.调整字段宽度
    可以使用width()成员函数将长度不同的数字放到宽度相同的字段中,其原型:
    int width();
    int width(int i);
    第一种格式返回字段宽度的当前设置
    第二种格式将字段宽度设置为i个空格,并返回以前的字段宽度值,这使得能够保存以前的值,以便以后恢复宽度值时使用
    注:width()方法只影响将要显示的下一个项目,然后字段宽度将恢复为默认值,
    width()是成员函数,必须使用cout(或其他ostream类及子类对象)调用它
    eg: cout << "#";
        cout.width(12);
        cout << 12 << "#" << 24 << "#\n";//#       12#24#
        12被放到宽段为12的字段最右边,这杯称为右对齐
        然后字段宽度被恢复为默认值,并将其余项目放到宽度与其程度相等的字段中
    C++永远不会截短数据,因此如果试图在宽度为2的字段中打印一个7位值,C++将增宽字段以容纳该数据
    C++中显示所有的数据比保持列整洁更重要
    有些语言如果数据长度与字段宽度不匹配,将使用星号填充
    cout通过加入空格来填满整个字段,右对齐时空格被插入到值的左侧
    用来填充的字符叫做填充字符(fill character),右对齐时默认的
    默认字段宽度为0







        



    
