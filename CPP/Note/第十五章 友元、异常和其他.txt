1.最初特性:友元类、友元类方法、嵌套类
  新增特性:引发异常、try块和catch块、异常类、运行阶段类型识别(RTTI)
	dynamic_cast和typeid、static_cast、const_cast和reinterpret_cast

15.1 友元
1.类并非只能拥有友元函数,也可以将类做为友元
2.友元类的所有方法都可以访问原始类的私有成员和保护成员
3.更严格的限制,可以只将特定的成员函数指定为另一个类的友元

15.1.1 友元类
1.一个对象可以改变另一个对象的状态的类之间的关系可以定义为友元类
2.友元可以声明在公有、私有、保护部分
	eg:	在类中声明Remote为友元类
		friend class Remote;
		Remote类使用了Tv类,编译器必须先了解Tv类才能处理Remote类
		一种方法是首先定义Tv类,另一种方法是使用向前声明(forward declaration)
		
15.1.2 友元成员函数
1.可以使一个类的成员方法称为另一个类的友元,而不必让整个类都成为友元
	需要注意的是,必须小心排列各种声明和定义的顺序
	eg:	声明一个友元成员函数
		class Tv
		{
		friend void Remote::set_chan(Tv & t,int c);
		...
		};
2.使用向前声明(forward declaration)避免循环依赖
	Tv类需要知道Remote的set_chan方法,Remote定义应放到Tv前面
	而Remote方法提到了Tv对象,Tv定义应放到Remote之前
	eg:	class Tv;
		class Remote{...};
		class Tv{...};
3.Remote的内联方法调用了Tv的公有方法,此时编译器必须已经知道Tv类的声明
	解决方案是使Remote中只包含方法声明,实际定义放在Tv类之后
	eg:	class Tv;			//forward declaration
		class Remote{...};	//Tv-using methods as prototypes only
		class Tv{...};
		//puts Remote method definitions here
		Remote方法的原型void onoff(Tv & t);
4.检查到该原型时,编译器需要知道一个Tv类,向前声明提供了这些信息
	当编译器到达真正的方法定义时,它已经读取了Tv类的声明,并拥有了编译这些方法的所有信息
	通过在方法定义中使用inline关键字,可使方法成为内联方法
5.内联函数:内联函数的链接性是内部的,函数定义必须在使用函数的文件中
	内联函数位于头文件中,在使用函数的地方包含头文件可确保定义放在正确的地方
	可以将定义放在实现文件中,但必须删除关键字inline,这样函数的链接性是外部的
6.使整个类为友元不需要向前声明,友元已经指出友元目标是一个类
	eg:	friend class Remote;
	
15.1.3 其他友好关系
1.互为友元,原型必须在定义前面,以便编译器获取足够的信息来编译该方法
	eg:	class Tv
		{
		friend class Remote;
		public:
			void buzz(Remote & r);
			...
		};
		class Remote
		{
			friend class Tv;
		public:
			bool volup(Tv & t){return t.volup();}
			...
		};
		inline void Tv::buzz(Remote & r)
		{
			...
		}
2.共同的友元,函数需要访问两个类的私有数据,则将函数作为两个类的友元
	eg:	class Analyzer;
		class Probe
		{
			friend void sync(Analyzer & a,Probe & p);//sync a to p
			friend void sync(Probe & p,Analyzer & a);//synv p to a
			...
		};
		class Analyzer
		{
			friend void sync(Analyzer & a,Probe & p);//sync a to p
			friend void sync(Probe & p,Analyzer & a);//synv p to a
			...
		};
		//define the friend functions
		inline void sync(Analyzer & a,Probe & p)
		{
			...
		}
		inline void sync(Probe & p,Analyzer & a)
		{
			...
		}
		向前声明使编译器看到Probe中的友元时,知道Analyzer是一个类型

15.2 嵌套类
1.嵌套类(nested class):可以将类声明放在另一个类中,在另一个类中声明的类被称为嵌套类
	它提供新的类型类作用域类避免名称混乱
2.包含类的成员函数可以创建和使用被嵌套类的对象,仅当声明位于公有部分时,才可以在包含类的外面使用嵌套类
	且必须使用作用域解析操作符
3.对类进行嵌套与包含不同,包含意味着将类对象作为另一个类的成员,而对类进行嵌套不创建类成员,
	而是定义了一种类型,该类型仅在包含嵌套类声明的类中有效
4.对类进行嵌套通常是为了帮助实现另一个类,并避免名称冲突
	eg:	(1)嵌套结构
		class Queue
		{
			//class scope definitions
			//Node is a nested structure definition local to this class
			struct Node{Item item;struct Node * next;};
			...
		};
		结构是一种成员默认为公有的类,Node实际上是一个嵌套类
		bool Queue::enqueue(const Item & item)
		{
			if(isfull())
				return false;
			Node * add = new Node;
			if(add == NULL)
				return false;
			add->item = item;
			add->next = NULL;
			...
		}
		(2)嵌套类
		class Queue
		{
			//class scope definitions
			//Node is a nested class definition local to this class
			class Node
			{
			public:
				Item item;
				Node * next;
				Node(const Item & i):item(i),next(0){}
				...
			};
			...
		};
		在类外部定义嵌套类的方法
		Queue::Node::Node(const Item & i):item(i),next(0){}
		新的enqueue写法
		bool Queue::enqueue(const Item & item)
		{
			if(isfull())
				return false;
			Node * add = new Node(item);
			if(add == NULL)
				return false;
			...
		}

15.2.1 嵌套类和访问权限
(1)有两种访问权限适合于嵌套类
	作用域和访问控制
	[1]嵌套类的声明位置决定了嵌套类的作用域
	[2]嵌套类的公有部分、保护部分、私有部分控制了对类成员的访问
1.作用域
	(1)类的默认访问权限是私有的(private)
	(2)嵌套类位于类的私有部分,其派生类及类外对嵌套类都是不可见的
	(3)嵌套类是在另一个类的保护分部声明的,则嵌套类对派生类是可见的,但对于类外部是不可见的
	(4)嵌套类是在另一个类的公有部分声明的,则嵌套类对派生类和类外部都是可见的
	(5)在类外部使用嵌套了,必须使用类限定符(className::nestedClassName)
	(6)嵌套结构和枚举的作用域与嵌套类相同
		eg:	class Team
			{
			public:
				class Coach{...};
				...
			};
			在类外部使用嵌套类
			Team::Coach forhire;//create a Coach object outside the Team class
	(7)嵌套类、结构和枚举作用域特征
		声明位置	包含它的类是否可以使用它	从包含它的类派生而来的类是否可以使用它	外部世界是否可以使用
		私有部分		是							否										否
		保护部分		是							是										否
		公有部分		是							是										是(通过类限定符)
2.访问控制
	(1)类可见后,起决定作用的是访问控制
	(2)嵌套类的访问控制规则和常规类相同
	(3)包含嵌套类的类只能访问嵌套类的公有部分
	(4)类声明的位置决定了类的作用域和可见性,类可见后,
		访问控制规则(公有、私有、保护、友元)将决定程序对嵌套类成员的访问权限
		
15.2.2 模板中的嵌套
1.普通嵌套类可以转换为模板类

15.3 异常
1.异常:程序运行阶段发生错误,导致程序不能正常地运行下去
	(1)打开不可用的文件
	(2)请求过多的内存
	(3)遭遇不能容忍的值
2.异常是新加入到C++中的

15.3.1 调用abort()
1.abort()位于头文件cstdlib(stdlib.h)中,向标准错误(cerr)流发送消息abnormal program termination(程序异常终止)然后终止程序
2.它还返回随实现而异的值,告诉操作系统(如果程序由另一个程序调用,则告诉父进程)处理失败
3.abort()是否刷新文件缓冲区(用于存储读写到文件中的数据的内存区域)取决于实现
	可以使用exit(),该函数刷新文件缓冲区,但不显示消息

15.3.2 返回错误码
1.使用函数返回值指出问题
	eg:ostream的gte(void)成员通常返回下一个输入字符的ASCII码,到达文件结尾时将返回EOF
		可以使用指针或引用将值返回给调用程序,并使用函数的返回值指出成功还是失败
		istream的重载操作符>>使用了这种技术的变体
2.通过告知程序成功还是失败,使得程序可以采取异常终止程序之外的措施
3.另一种存储返回条件的方法是使用全局变量,出现问题的函数设置该全局变量的值为特殊值
	调用程序检查该值
	eg:	传统的C语言数学库Math使用的就是这种方法,全局变量名称为errno
		必须确保其他函数没有将该全局变量用于其他用途
	
15.3.3 异常机制
1.C++异常是对程序运行过程中发生的异常情况的一种响应
	异常提供了将控制权从程序的一个部分传递到另一部分的途径
2.异常处理的组成部分:
	(1)应发异常
	(2)捕获有处理程序的异常
	(3)使用try块
3.程序在出现问题时将引发异常
4.(1)throw语句实际上是跳转,即命令程序跳转到另一条语句
	throw关键字表示引发异常,紧随其后的值(字符串或对象)指出了异常的特征
	程序使用异常处理程序(exception handler)捕获异常,异常处理程序位于要处理问题的程序中
	指引throw语句相当于执行返回语句,它将终止函数的执行
	throw不是将控制权返回给调用程序,而是导致程序沿函数调用序列后退,直到找到包含try块的函数
	程序将在回退路径中寻找与引发的异常类型匹配的异常处理程序
  (2)catch关键字表示捕获异常
	处理程序以关键字catch开头,随后是位于括号中的类型声明,它指出了异常处理程序要相应的异常类型
	然后是花括号括起的代码块,指出要采取的措施
	catch关键字和异常类型用作标签,指出当异常引发时,程序应跳到这个位置执行
	异常处理程序也被称为catch块
	catch捕获异常,会将throw抛出的异常类型赋给catch块参数
  (3)try块标识其中特定的异常可能被激活的代码块,它后面跟一个或多个catch块
	try块是由关键字try指示的,关键字try后是一个由花括号括起的代码块,
	表明需要注意这些代码引发的异常
	eg: //somewhere throw
		[1]throw "something";
		[2]	try
			{
				//do something
			}
			catch(const char * s)
			{
				//do something
			}
  (4)不位于try块中的异常将不会被捕获
  (5)异常类型可以是字符串或C++其他类型,通常为类类型
  (6)程序执行完try块后没有引发异常,则程序跳过try块后面的catch块
	继续执行处理程序后面的语句

15.3.4 将对象用作异常类型
1.引发异常的函数将传递一个对象,有点是可以使用不同的异常类型来区分不同函数在不同情况下引发的异常
	异常对象可以携带信息,可以根据这些信息确定引发异常的原因
	catch块可以根据这些信息来决定采取什么样的措施
	eg: //exception class
		class bad_hmean{...};
		//exception occur
		throw bad_hmean(v1,v2);
2.可使用异常规范对函数定义进行限定,指出它将引发哪些类型的异常
	可在函数定义后面加上异常规范,它由关键字throw和异常类型列表组成,
	异常类型列表被括在括号中并用逗号分隔
	eg:	double hmean(double a,double b) throw(bad_hmean,bad_hmean1,bad_hmean2,...);
	这完成了两项工作,首先它告诉编译器该函数引发哪些类型的异常
	如果以后该函数引发了其他类型异常,程序最终将调用abort()函数
	其次,使用异常规范将提醒阅读该原型的人,该函数引发异常,应提供try块和处理程序
3.对于引发多种类型异常的函数,可提供一个由逗号分隔的异常类型列表,句法与函数参数列表相似
	eg:	double multi_err(double z) throw(const char *,double);
	函数原型及定义中都应加上异常列表
	double hmean(double a,double b) throw(bad_hmean)
	{
		if(a == -b)
			throw bad_hmean(a,b);
		...
	}
4.如果异常规范中的括号内为空,则表明该函数不会引发异常
	eg:	double simple(double z) throw();
	




