142十三章 类继承

1.函数库通常不提供源代码,即使提供了源代码在根据特定需求进行修改时也有一定的风险
2.类库包含的数据表示和类方法,比函数库提供了更完整的程序包
3.C++提供了比修改代码更好的方法来扩展和修改类,这种方法叫作类继承(class inheritance)
4.类继承能够从已有的类派生出新的类,派生类继承的原有类(基类)的特征,包括方法
5.可以通过继承完成的一些工作:
	[1]可以在已有类的基础上添加功能,eg:对数组类添加数学运算
	[2]可以给类添加数据,eg:给字符串类派生出一个类并添加输出颜色的数据成员
	[3]可以修改类方法的行为,eg:对基类派生出具有更好功能的类方法
6.继承机制只需提供新特性,甚至不需要访问源代码就可以派生出类
7.类库可能只提供了类方法的头文件和编译后的代码,仍可以使用库中的类派生出新的类

13.1 一个简单的基类
1.从一个类派生出另一个类时,原始类称为基类,继承类称为派生类

13.1.1 派生一个类
1.类的派生
	eg:	class RatedPlayer:public TableTennisPlayer
		{
		private:
			unsigned int rating;//add a data member
		public:
			RatedPlayer(unsigned int r = 0,
					const char * fn = "none",
					const char * ln = "none",
					bool ht = false);
			RatedPlayer(unsigned int r,TableTennisPlayer & tp);
			unsigned int Rating(){return rating;}
			void ResetRating(unsigned int r){rating = r;}
		};
	[1]冒号指出RatedPlayer类的基类是TableTennisPlayer类
	[2]TableTennisPlayer是一个公有基类,这被称为公有派生
	[3]派生类对象包含基类对象
	[4]使用公有派生,基类的公有成员将成为派生类的公有成员,
		基类的私有部分也将成为派生类的一部分
		但只能通过基类的公有和保护方法访问
2.派生类特征:
	[1]派生类对象存储了基类的数据成员(派生类继承了基类的实现)
	[2]派生类对象可以使用基类的方法(派生类继承了基类的接口)
3.需要在继承中添加什么
	[1]派生类需要自己的构造函数
	[2]派生类可以根据需要添加额外的数据成员和成员函数

13.1.2 构造函数:访问权限的考虑
1.派生类不能直接访问基类的私有成员,而必须通过基类方法进行访问
2.派生类构造函数必须使用基类构造函数
3.创建派生类对象时首先创建基类对象,即基类对象在程序进入派生类构造函数之前被创建
	[1]C++使用成员初始化列表来完成这种工作
	eg:RatedPlayer::RatedPlayer
		(unsigned int r,const char * fn,const char * ln,bool ht):
		TableTennisPlayer(fn,ln,ht)
		{
			rating = r;
		}
	TableTennisPlayer(fn,ln,ht)是成员初始化列表
	将参数从派生类构造函数传递给基类构造函数
	[2]基类对象必须首先创建,如果不调用基类构造函数,程序将使用默认的基类构造函数
	eg:	RatedPlayer::RatedPlayer(unsigned int r,const char * fn,const char * ln,bool ht):TableTennisPlayer()
		{
			rating = r;
		}
	除非要使用默认构造函数,否则应显式调用正确的基类构造函数
	[3]另一个派生类构造函数
	eg:	RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer & tp):TableTennisPlayer(tp)
		{
			rating = r;
		}
		tp的类型为const TableTennisPlayer &这将调用基类的复制构造函数,由于基类未使用动态内存分配
		将调用隐式地浅复制的复制构造函数
	[4]可以对派生类成员使用成员初始化列表
		eg:	RatedPlayer::RatedPlayer
			(unsigned int r,const TableTennisPlayer & tp):
			TableTennisPlayer(tp),rating(r)
			{
			}
4.有关派生类构造函数的要点:
	[1]基类对象首先被创建
	[2]派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
	[3]派生类构造函数应初始化派生类新增数据成员
5.释放对象的顺序与创建的顺序相反,首先执行派生类的析构函数,然后调用基类的析构函数
6.创建派生类对象时,程序首先调用基类构造函数,然后在调用派生类构造函数,
	基类构造函数初始化继承的成员,派生类构造函数初始化新增数据成员,
	派生类构造函数总是调用一个基类构造函数,可以使用初始化列表指明要调用的基类构造函数,
	否则将使用默认基类构造函数
	派生类对象过期时,首先调用派生类的析构函数,然后再调用基类析构函数
7.可以使用成员初始化列表调用基类构造函数以初始化基类数据成员
	仅构造函数可以使用初始化成员列表
	除虚拟基类外,类只能将值传递回相邻的基类,后者可使用相同的机制将信息传递给相邻的基类
	如果没有在成员初始化列表提供基类构造函数,将调用基类默认构造函数
	
13.1.3 使用派生类
1.可以将类声明放在独立的文件中,也可以将相关的类声明在同一个文件中
2.成员初始化列表仅出现在类构造函数实现中,类声明不需写上成员初始化列表
	eg:	声明
		RatedPlayer(unsigned int r = 0,const char * fn = "none",const char * ln = "none",bool ht = false);
		实现
		RatedPlayer::RatedPlayer(unsigned int r,const char * fn,const char * ln ,bool ht):TableTennisPlayer(fn,ln,ht)