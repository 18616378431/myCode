第十三章 类继承

1.函数库通常不提供源代码,即使提供了源代码在根据特定需求进行修改时也有一定的风险
2.类库包含的数据表示和类方法,比函数库提供了更完整的程序包
3.C++提供了比修改代码更好的方法来扩展和修改类,这种方法叫作类继承(class inheritance)
4.类继承能够从已有的类派生出新的类,派生类继承的原有类(基类)的特征,包括方法
5.可以通过继承完成的一些工作:
	[1]可以在已有类的基础上添加功能,eg:对数组类添加数学运算
	[2]可以给类添加数据,eg:给字符串类派生出一个类并添加输出颜色的数据成员
	[3]可以修改类方法的行为,eg:对基类派生出具有更好功能的类方法
6.继承机制只需提供新特性,甚至不需要访问源代码就可以派生出类
7.类库可能只提供了类方法的头文件和编译后的代码,仍可以使用库中的类派生出新的类

13.1 一个简单的基类
1.从一个类派生出另一个类时,原始类称为基类,继承类称为派生类

13.1.1 派生一个类
1.类的派生
	eg:	class RatedPlayer:public TableTennisPlayer
		{
		private:
			unsigned int rating;//add a data member
		public:
			RatedPlayer(unsigned int r = 0,
					const char * fn = "none",
					const char * ln = "none",
					bool ht = false);
			RatedPlayer(unsigned int r,TableTennisPlayer & tp);
			unsigned int Rating(){return rating;}
			void ResetRating(unsigned int r){rating = r;}
		};
	[1]冒号指出RatedPlayer类的基类是TableTennisPlayer类
	[2]TableTennisPlayer是一个公有基类,这被称为公有派生
	[3]派生类对象包含基类对象
	[4]使用公有派生,基类的公有成员将成为派生类的公有成员,
		基类的私有部分也将成为派生类的一部分
		但只能通过基类的公有和保护方法访问
2.派生类特征:
	[1]派生类对象存储了基类的数据成员(派生类继承了基类的实现)
	[2]派生类对象可以使用基类的方法(派生类继承了基类的接口)
3.需要在继承中添加什么
	[1]派生类需要自己的构造函数
	[2]派生类可以根据需要添加额外的数据成员和成员函数

13.1.2 构造函数:访问权限的考虑
1.派生类不能直接访问基类的私有成员,而必须通过基类方法进行访问
2.派生类构造函数必须使用基类构造函数
3.创建派生类对象时首先创建基类对象,即基类对象在程序进入派生类构造函数之前被创建
	[1]C++使用成员初始化列表来完成这种工作
	eg:RatedPlayer::RatedPlayer
		(unsigned int r,const char * fn,const char * ln,bool ht):
		TableTennisPlayer(fn,ln,ht)
		{
			rating = r;
		}
	TableTennisPlayer(fn,ln,ht)是成员初始化列表
	将参数从派生类构造函数传递给基类构造函数
	[2]基类对象必须首先创建,如果不调用基类构造函数,程序将使用默认的基类构造函数
	eg:	RatedPlayer::RatedPlayer(unsigned int r,const char * fn,const char * ln,bool ht):TableTennisPlayer()
		{
			rating = r;
		}
	除非要使用默认构造函数,否则应显式调用正确的基类构造函数
	[3]另一个派生类构造函数
	eg:	RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer & tp):TableTennisPlayer(tp)
		{
			rating = r;
		}
		tp的类型为const TableTennisPlayer &这将调用基类的复制构造函数,由于基类未使用动态内存分配
		将调用隐式地浅复制的复制构造函数
	[4]可以对派生类成员使用成员初始化列表
		eg:	RatedPlayer::RatedPlayer
			(unsigned int r,const TableTennisPlayer & tp):
			TableTennisPlayer(tp),rating(r)
			{
			}
4.有关派生类构造函数的要点:
	[1]基类对象首先被创建
	[2]派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
	[3]派生类构造函数应初始化派生类新增数据成员
5.释放对象的顺序与创建的顺序相反,首先执行派生类的析构函数,然后调用基类的析构函数
6.创建派生类对象时,程序首先调用基类构造函数,然后在调用派生类构造函数,
	基类构造函数初始化继承的成员,派生类构造函数初始化新增数据成员,
	派生类构造函数总是调用一个基类构造函数,可以使用初始化列表指明要调用的基类构造函数,
	否则将使用默认基类构造函数
	派生类对象过期时,首先调用派生类的析构函数,然后再调用基类析构函数
7.可以使用成员初始化列表调用基类构造函数以初始化基类数据成员
	仅构造函数可以使用初始化成员列表
	除虚拟基类外,类只能将值传递回相邻的基类,后者可使用相同的机制将信息传递给相邻的基类
	如果没有在成员初始化列表提供基类构造函数,将调用基类默认构造函数
	
13.1.3 使用派生类
1.可以将类声明放在独立的文件中,也可以将相关的类声明在同一个文件中
2.成员初始化列表仅出现在类构造函数实现中,类声明不需写上成员初始化列表
	eg:	声明
		RatedPlayer(unsigned int r = 0,const char * fn = "none",const char * ln = "none",bool ht = false);
		实现
		RatedPlayer::RatedPlayer
		(unsigned int r,const char * fn,const char * ln ,bool ht):TableTennisPlayer(fn,ln,ht)

13.2 派生类和基类之间的特殊关系
1.基类与派生类的特殊关系
	[1]派生类对象可以使用基类方法,条件是方法不是私有的
	[2]基类指针可以在不需要显式类型转换的情况下指向派生类对象
	[3]基类引用可以不需要显式类型转换的情况下引用派生类对象
	[4]基类的引用或指针只能调用基类方法,不能使用基类引用或指针调用派生类方法
	[5]通常C++要求引用或指针的类型与赋给的类型匹配,但这一规则对继承来说是例外
		这种例外是单向的,不可以将基类对象和地址赋给派生类引用或指针
		即派生类的指针或引用不可以指向基类
	eg:	(1)基类引用指向派生类
		RatedPlayer rplayer1(1140,"Mallory","Duck",true);
		TableTennisPlayer & rt = rplayer1;
		TableTennisPlayer & pt = &rplayer1;
		rt.Name();//引用调用基类方法
		pt->Name();//指针调用基类方法
		
		(2)派生类引用或指针不可以指向基类对象
		TableTennisPlayer player("Betsy","Bloop",true);
		RatedPlayer & rr = player;//not allowed
		RatedPlayer * pr = &player;//not allowed
		
		(3)引用兼容性属性也能够将基类对象初始化为派生类对象
		RatedPlayer olaf1(1840,"Olaf1","Loaf",true);
		TableTennisPlayer olaf2(olaf1);
		其中匹配的构造函数为
		TableTennisPlayer (const RatedPlayer & );
		类定义中没有这样的构造函数,但存在隐式复制构造函数
		TableTennisPlayer (const TableTennisPlayer &);
		形参为基类引用,因此它可以引用派生类
		将olaf2初始化为olaf1时,将使用该构造函数,复制firstname,lastname,hasTable成员的值
		也就是说,将olaf2初始化为嵌套在RatedPlayer对象olaf1中的TableTennisPlayer对象
		
		(4)可以将派生对象赋给基类对象
		RatedPlayer olaf1(1840,"Olaf1","Loaf",true);
		TableTennisPlayer winner;
		winner = olaf1;
		这种情况下程序将使用隐式重载赋值操作符
		TableTennisPlayer operator= (const TableTennisPlayer & )const;
		基类引用指向的派生类对象,因此将olaf1的基类部分复制给winner

13.3 继承--is-a关系
1.C++的三种继承:
	[1]公有继承
	[2]保护继承
	[3]私有继承
2.公有继承:公有继承时最常用的方式,它建立一种is-a关系,即派生类对象也是基类对象,
	可以对基类对象执行任何操作,也可以对派生类执行(is-a-kind-of)
3.公有继承不建立has-a关系,has-a关系是将要包括的内容做为当前对象的数据成员(has-a)
	eg:水果不是午餐,但午餐可以包括水果,则不能从水果类派生出午餐类,但午餐类可以将水果类做为数据成员
4.公有继承不能建立is-like-a关系,也就是说它不采用明喻,相似的比喻关系不能够构建派生关系
	eg:人们常说律师就像鲨鱼,但律师并不是鲨鱼
5.继承可以在基类的基础上添加属性,但不能删除基类的属性,
	在一些情况下可以设计一个包含有共同特征的类,然后使用is-a,has-a关系,
	使用这个类来定义相关的类
6.公有继承不建立is-implemented-as-a关系(做为...来实现),
	eg:可以使用数组实现堆栈,但不能使用数组派生出堆栈,因为堆栈不是数组
		数组的索引不是堆栈的属性,可以使用链表来实现堆栈
		可以通过让堆栈包含一个私有数组成员,来隐藏数组的实现
7.公有继承不建立uses-a关系,计算机可以使用激光打印机,但从Computer派生出Printer类或反过来是没有意义的
	可以使用友元函数或类来处理Printer对象和Computer之间的通信
8.在C++中完全可以使用公有继承完成has-a,is-implemented-as-a或uses-a关系,但这将导致编程方面的问题
	尽量使用is-a关系

13.4 多态公有继承
1.派生类可以使用基类的方法而不做任何修改
2.多态:方法的行为取决于调用该方法的对象,即派生类和基类调用同一个方法产生不同的行为
	这种较复杂的行为称为多态--具有多种形态,就是指同一个方法的行为随上下文而异
3.有两种重要的机制可用于实现多态公有继承:
	[1]在派生类中重新定义基类的方法
	[2]使用虚方法
4.is-a关系是不可逆的
	eg:水果不是香蕉
	
13.4.1 开发Brass类和BrassPlus类
1.virtual修饰的类成员方法称为虚方法(virtual method)
2.可以将析构函数声明为虚拟析构函数(virtual destructor)
3.virtual关键字,如果方法是通过引用或指针而不是对象调用的,它将确定使用哪一种方法
	如果没有使用关键字virtual,程序将根据引用类型或指针类型选择方法
	如果使用了virtual关键字,程序将根据引用或指针指向的对象的类型来选择方法
	eg:	Brass dom("Dominic Banker",12244,4183.45);
		BrassPlus dot("Dorothy Banker",12118,2592.00);
		[1]使用了virtual关键字修饰ViewAcct
		dom.ViewAcct();//use Brass::ViewAcct();
		dot.ViewAcct();//use BrassPlus::ViewAcct();
		[2]未使用virtual修饰ViewAcct
		Brass & b1_ref = dom;
		Brass & b2_ref = dot;
		b1_ref.ViewAcct();//use Brass::ViewAcct();
		b2_ref.ViewAcct();//use Brass::ViewAcct();
		引用变量的类型为Brass,则使用Brass::ViewAcct();
		使用Brass指针代替引用时,结果类似
		[3]ViewAcct时虚拟(virtual)的
		b1_ref.ViewAcct();//use Brass::ViewAcct();
		b2_ref.ViewAcct();//use BrassPlus::ViewAcct();
4.经常在基类中奖派生类会重新定义的方法声明为虚方法,方法在基类中声明为虚拟的后
	在派生类中将自动成为虚方法,在派生类中使用virtual指出哪些是函数是虚函数也是一个好办法
5.基类声明一个虚析构函数,是为了释放派生对象时,按正确的顺序调用析构函数
6.如果要在派生类中重新定义基类方法,通常应将基类中的方法声明为虚拟的,
	这样,程序将根据对象类型(引用或指针指向的类型)而不是引用或指针的类型来选择方法的版本
	为基类声明一个虚拟析构函数也是一种惯例
[1]类实现
	(1)virtual关键字只用于类声明中的方法,不用于类实现的方法中
		//声明
		virtual void ViewAcct();
		//实现
		void Brass::ViewAcct(){...}
	(2)派生类不能直接访问基类的私有数据,必须通过基类的公有方法访问
	(3)派生类可以调用基类公有方法,使用作用域解析操作符访问基类公有方法
		如果不使用作用域解析操作符,方法调用将会认为是调用当前类的方法
		如果当前类不存在调用的方法,则会去基类中寻找,此时可不使用作用域解析操作符
		作用域解析操作符是为了区分基类和派生类都存在的方法
		派生类没有重新定义的基类方法,可以直接调用
		eg:	在派生类方法中 Brass::ViewAcct();
			在派生类方法中调用基类方法错误示范: ViewAcct();//error
	(4)cout.setf()返回一个值,表示当前设置的输出格式

[2]使用Brass和BrassPlus类
1.Brass基类指针数组指向不同的类型的对象(BrassPlus),以使用virtual虚方法特性

[3]虚方法的行为
1.使用指向对象的指针或引用以使用virtual虚方法的特性
	eg:	p_clients[i]->ViewAcct();
		p_clients[i]指向Brass则调用Brass::ViewAcct(),指向BrassPlus则调用BrassPlus::ViewAcct()
		体现了C++的多态性
		
[4]为何需要虚拟析构函数
1.如果基类的析构函数不是虚拟(virtual)的,则delete时将只调用对应于指针类型的析构函数
	eg:	如果不是虚拟的析构函数,则delete时将只调用Brass的析构函数,而不会调用指向
		BrassPlus的析构函数
2.如果析构函数是虚拟(virtual)的,将调用相应对象类型的析构函数,
	使用虚拟析构函数可以保证正确的析构函数调用序列
	eg:	如果指针指向的是BrassPlus对象,将调用BrassPlus的析构函数,
		然后自动调用基类的析构函数
3.如果BrassPlus的析构函数中包含一些特定的操作,则其基类Brass必须定义一个虚拟析构函数,
	即使该析构函数不执行任何操作
	
13.4.2 静态联编和动态联编
1.程序调用函数时,由编译器决定使用哪个可执行代码块
2.函数名联编(binding):将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编
3.在C语言中非常简单,每个函数名都对应一个不同的函数
	C++中,由于函数重载的缘故,这项任务更复杂,编译器必须查看函数名及函数参数才能确定使用哪个函数
4.静态联编(static binding):在编译过程中进行联编被称为静态联编,又称为早起联编(early binding)
	C/C++编译器可以在编译过程完成这种联编,不过虚函数使这项工作更困难
5.动态联编(dynamic binding):编译器必须能够在程序运行期间选择正确的虚方法的代码,
	这被称为动态联编,也称为晚期联编(late binding)
	有时使用哪个函数不是在编译期决定的,因为编译器不知道用户将选择哪种类型的对象
	
13.4.3 指针和引用类型的兼容性
1.动态联编与指针和引用调用的方法相关
2.通常C++不允许将一种类型的地址赋给另一种类型的指针,也不允许一种类型的引用指向另一种类型
	eg:	double x = 2.5;
		int * pi = &x;//error,指针类型不匹配
		long & rl = x;//error,引用类型不匹配
3.指向基类的指针或引用可以指向派生类,不需要进行显式类型转换
	eg:	BrassPlus dilly("Annie Dill",493222,2000);
		Brass *pb = &dilly;//ok
		Brass &rb = dilly;//ok
4.向上强制转换(upcasting):将派生类引用或指针转换为基类引用或指针称为向上强制转换,
	这使公有继承不需要显式类型转换,派生类可以调用基类的方法,对基类的任何操作都适用于派生类
	向上强制转换是可逆的
	Brass指针或引用可以指向由BrassPlus派生出的对象
5.向下强制转换(downcasting):将基类指针或引用转换为派生类指针或引用,称为向下强制转换
	如果不显式类型转换,向下强制转换时不允许的,is-a关系是不可逆的
	向下类型转换必须显式声明
	派生类可以新增数据成员,使用这些数据成员的函数不能用于基类
	eg:	Employee veep;//base,name()
		Singer trala;//drivered,range()
		Employee * pe = &trala;//向上隐式类型转换
		Singer *ps = (Singer *)veep;//显式类型转换,向下强制类型转换
		pe->name();//向上转换带来安全操作
		ps->range();//向下转换带来不安全操作,派生类的新增数据成员并未进行初始化
6.隐式向上转换时基类引用或指针可以指向基类对象或派生类对象,需要动态联编
7.C++使用需虚成员函数(virtual)完成动态联编

13.4.4 虚拟成员函数和动态联编
1.编译器对非虚方法使用静态联编(在编译期就确定使用哪个方法)
2.编译器对虚方法(virtual)使用动态联编(在运行期确定使用哪个方法)
3.	[1]为什么有两种类型的联编,为什么默认为静态联编
		为什么不摒弃静态联编,原因是效率和概念模型
		(1)效率:为了在运行期进行决策,必须采取一些方法来跟踪基类指针或引用指向的对象类型
			这增加了额外的处理开销
			由于静态联编的效率更高,所以被设置为C++的默认选择
			eg:	如果类不会用作基类,则不需要动态联编
				派生类不重载基类的任何方法,则不需要动态联编
				这些情况下使用静态联编更合理,效率也高
			
		(2)概念模型:在设计类时,可能包含一些不在派生类重新定义的成员函数,则不设置为虚函数
			好处有两方面:
				{1}效率更高
				{2}指出不需要重新定义该函数
			仅将那些预期将重新定义的方法声明为虚拟的
		(3)如果要在派生类中重新定义基类的方法,则将它设置为虚方法,否则设置为非虚方法	
	[2]虚函数的工作原理
		(1)通常,编译器处理虚函数的方法是:给每个对象添加一个隐藏成员,
		隐藏成员保存了一个指向函数地址数组的指针,这种数组称为虚函数表(virtual function table,vtbl)
		虚函数表中存储了为类对象进行声明的虚函数的地址
		无论类中定义了1个或10个虚函数,都只需要在对象中添加一个地址成员,只是表的大小不同而已
		eg:	基类对象包含一个指针,该指针指向基类中所有虚函数的地址表
			派生类对象将包含一个指向独立地址表的指针
			如果该派生类提供了虚函数的新定义,该虚函数表将保存新函数的地址
			如果派生类没有重新定义虚函数,该vtbl将保存原始版本的地址
			如果派生类定义了新的虚函数,则该函数的地址将被添加到vbtl中
		(2)调用虚函数时,程序将查看存储在对象中的vbtl地址,然后转向相应的函数地址表
			eg:	如果使用类声明中的第一个虚函数,则程序将使用数组中的第一个函数地址,并执行具有该地址的函数
				如果使用类声明中的第三个虚函数,程序将使用数组中第三个元素的函数
			使用虚函数在内存和执行速度方面有一定的成本:
				{1}每个对象都将增大,增大量为存储地址的空间(指向虚函数地址表的指针的空间)
				{2}对每个类,编译器都创建一个虚函数地址表(数组)
				{3}每个虚函数调用都要执行一步额外的操作,到表中查找地址
			虽然非虚函数效率比虚函数高,但不具备动态联编功能

13.4.5 有关虚函数的注意事项
{1}在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类(包括派生类派生的类)中是虚拟的
{2}如果使用指向对象的指针或引用来调用虚方法,程序将使用指针或引用指向的对象来调用方法
	而不是指针或引用的类型来调用方法,这称为动态联编或晚期联编,这种行为非常重要,
	这样基类指针或引用可以指向派生类对象
{3}如果定义的类将被用作基类,则应该哪些要在派生类中重新定义的类方法声明为虚拟的
1.构造函数
	构造函数不能是虚函数
	创建派生类对象时,将调用派生类的构造函数,而不是基类的构造函数,
	然后,派生类的构造函数将使用基类的一个构造函数,这种顺序不同于继承机制
	因此派生类不继承基类的构造函数,所以将类构造函数声明为虚拟的没有什么意义
2.析构函数
	析构函数应当是虚函数,除非类不用作基类
	eg:	Singer继承Employee,并含有new动态分配内存的成员char *
		Employee * pe = new Singer;
		...
		delete pe;//~Employee() or ~Singer()
		如果基类的析构函数没有声明为虚拟的,上述语句将调用pe指针类型的对象的析构,即Employee的析构函数
		而不会调用Singer的析构函数,只释放了基类的指向的内存,并未释放派生类指向的内存
		如果析构函数是虚拟的,上述代码将先调用Singer的析构函数释放Singer组件指向的内存,
		然后调用Employee的析构函数释放其组件指向的内存
		这样保证了正确的析构函数调用顺序
		通常应给基类提供一个虚拟析构函数,即使它并不需要析构函数
3.友元
	友元不能是虚函数,因为友元不是类成员,而只有成员才能是虚函数
	如果由于这个原因引起了设计问题,可以让友元使用虚拟成员函数类解决问题
4.没有重新定义
	如果派生类没有重新定义函数,将使用该函数的基类版本
	如果派生类位于派生链中,则将使用最新的虚函数版本,例外的情况是基类版本是隐藏的
5.重新定义隐藏方法(虚函数派生类中的重新定义)
	重新定义不会生成函数的两个重载版本,而是隐藏了参数不同的基类版本
	重新定义继承的方法并不是重载
	如果在派生类中重新定义函数,将不是使用相同的函数特征标覆盖基类声明,而是隐藏同名的基类方法
	不管参数特征标如何
	eg:	class Dwelling
		{
		public:
			virtual void showperks(int a)const;
		};
		class Hovel:public Dwelling
		{
		public:
			virtual void showperks()const;
		};
		
	
	(1)如果重新定义继承的方法,应确保与原来的原型相同,但如果返回类型是基类引用或指针,
		则可以修改为指向派生类的引用或指针,这种特性被称为返回类型协变(covariance of return type)
		因为允许返回类型随类类型的变化而变化
		这种例外仅适用于返回值,而不适用与参数
	eg:	Class Dwelling
		{
		public:
			//base method
			virtual Dwelling & build(int n);
		};
		class Hovel:public Dwelling
		{
			//a derived method with a covariance return type
			virtual Hovel & build(int n);
		};
	(2)如果基类声明被重载了,则应在派生类中定义所有基类版本
		如果只重新定义一个版本,则其他版本将被隐藏,派生类中将无法使用它们
		eg:	class Dwelling
			{
			public:
				//three overload
				virtual void showperks(int a)const;
				virtual void showperks(double x)const;
				virtual void showperks()const;
			};
			class Hovel:public Dwelling
			{
			public:
				//three redefined overload
				virtual void showperks(int a)const;
				virtual void showperks(double x)const;
				virtual void showperks()const;
			};
			
13.5 访问控制:protected
1.关键字protected与private类似,在类外只能用公有类方法访问protected部分的类成员
2.private和protected之间的区别在于基类派生出的类中才会表现出来
	派生类可以直接访问基类的保护成员,但不能直接访问基类的私有成员
	对外界来说,保护成员的行为与私有成员相似
	对派生类来说,保护成员的行为与公有成员相似
	eg:	class Brass
		{
		protected:
			double balance;
			...
		};
		这样BrassPlus就可以直接访问balance,而不需要使用Brass的方法
3.使用保护(protected)数据成员可以简化代码编写工作,但存在设计缺陷
	派生类中可以直接访问基类保护成员并可以修改,则可能绕过基类的对成员的保护措施,
	实际上使保护成员成为公有变量
4.最好对类成员使用私有访问控制,不要使用保护访问控制,同时通过基类方法使派生类能够访问基类数据
	然而对于成员函数来说,保护访问控制很有用,它让派生类能够访问公众不能使用的内部函数
5.单设计模式:
	希望有且只有一个类的实例返回给调用程序时,就可以使用单元素模式(Singleton patter)
	eg:	class TheOnlyInstance
		{
		public:
			static TheOnlyInstance * GetTheOnlyInstance();
			//other methods
		protected:
			TheOnlyInstance(){}
		private:
			//private data
		};
		通过将TheOnlyInstance构造函数声明为protected,并省略公有构造函数,可以防止局部实例被创建
		TheOnlyInstance noCando;//not allowed,不允许的
		只能通过公有静态方法GetTheOnlyInstance来访问类,该方法被调用时,将返回类的实例
		TheOnlyInstance * GetTheOnlyInstance()
		{
			static TheOnlyInstance objTheOnlyInstance;
			return &objTheOnlyInstance;
		}
		GetTheOnlyInstance仅在方法第一次调用时,创建TheOnlyInstance类的一个实例,
		以这种方法构造的静态对象一直有效,直到程序终止,静态对象将被自动释放
		要检索指向这个类的唯一实例,只需调用静态方法,该方法返回单对象的地址
		TheOnlyInstance * pTheOnlyInstance = TheOnlyInstance::GetTheOnlyInstance();
		因为静态变量在函数调用结束时仍保存在内存中,所以以后再调用GetTheOnlyInstance时,
		将返回同一个静态对象地址
		
		