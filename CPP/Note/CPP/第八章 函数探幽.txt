第八章 函数探幽

8.1 内联函数
1.常规函数执行流程:
	执行到函数调用指令时,程序将在函数调用后立即存储该指令的内存地址,
	并将函数参数复制到堆栈,跳到标记函数起点的内存单元,执行函数代码(也许需要将返回值放到寄存器中),
	然后跳回到地址被保存的指令处
	使用常规函数会有一定的内存开销
2.内联函数:
	编译器使用相应的函数代码替换函数调用,程序无需跳到另一处执行代码
	内联函数的运行速度比常规函数稍快,代价是需要占用更多的内存
	内联函数不能递归
	内联函数和常规函数一样按值传递参数
3.内联函数声明及定义:函数声明和定义前加上inline关键字
4.内联与宏:#define宏函数是通过文本替换完成的,宏不能按值传递参数

8.2 引用变量
1.引用变量主要用作函数形参,函数使用原始数据,不是拷贝

8.2.1 创建引用变量
1.&符号除表示获取变量地址,c++给&赋予了另一个含义,用来声明引用变量
2.&是类型声明标识符的一部分
3.引用变量和原变量指向相同的内存单元
4.int & 为类型声明标识符,表示指向int的引用
5.引用必须在声明时初始化,指针可以先声明后初始化,eg:int & rodents = rats;
6.可以通过初始声明设置引用,不能通过赋值来设置引用

8.2.2 将引用用作函数参数
1.将引用用作函数参数,使函数中的变量名为调用函数中变量的别名,这种传递参数的方法称为按引用传递
2.eg:test(int & a,int & b);

8.2.3 引用的属性和特别之处
1.使用const常量引用,防止修改原始数据,const double & ra;
2.函数参数引用传值,实参应为变量,不可为表达式
3.实参与引用参数不匹配,c++将生成临时变量
4.引用参数为const,编译器将在以下情况生成临时变量
	(1)实参的类型正确,但不是左值
	(2)实参的类型不正确,但可以转换为正确的类型
	(3)左值参数时可被引用的数据对象,eg:变量、数组元素、结构成员、引用和被解除引用的指针都是左值
	(4)非左值:字面常量和包含多项的表达式
	(5)c++创建的临时变量不影响原变量的值
	(6)形参为const的引用c++函数,如果实参不匹配则其行为类似于按值传递,为确保原始数据不被修改
		将使用临时变量来存储值
	(7)调用的参数不是左值或与相应的const引用参数类型不匹配,
		c++将创建类型正确的匿名变量,将函数调用的参数的值传递给该匿名变量,
		并让参数引用该变量
5.引用传值尽可能使用const
	(1)使用const可避免无意中修改数据的编程错误
	(2)使用const可同时处理const数据和非const数据,否则形参只能接收非cosnt数据
	(3)使用const引用使函数能正确生成并引用临时变量
	
8.2.4 将引用用于结构
1.引用适合于c++结构和类,使用结构引用的方式与使用基本变量引用相同
2.结构体引用即可以作为函数参数也可以作为函数返回值eg:cosnt sysop & use(sysop & sysopref);
3.返回引用意味着调用程序直接访问返回值的值,而不是返回值的拷贝,返回的引用为被引用变量的别名
4.返回的引用不可以是函数结束时不存在的内存单元的引用,避免返回指向临时变量的指针
5.返回引用返回一个做为函数参数的引用,做为参数的引用将指向调用函数使用的数据,
	返回的引用也将指向这些数据
6.在函数中使用new操作符分配新的空间,返回指向这些内存空间的指针
7.cosnt引用返回值说明不能使用返回的引用修改它指向的结构

8.2.5 将引用用于类对象
1.可以通过引用,使函数将类string、ostream、istream、ofstream、ifstream等类的对象做为参数
2.使用const string类引用做为函数形参,函数不创建新的string对象,使用原值
3.string类定义了一个char *到string的转换功能,可以使用c风格字符串初始化string对象
4.函数中声明的局部变量做为引用返回,并赋值给新的变量,使用了已经释放的内存,程序崩溃

8.2.6 对象、继承和引用
1.继承:使得能够将特性从一个类传递给另一个类的语言特性被称为继承
2.ostream是基类,ofstream是派生类,ofstream是基于ostream的,派生类继承了基类的方法
	派生类可以使用基类的特性,eg:格式化方法precision(),setf()
3.继承的另一个特征是基类引用可以指向派生类对象,而无需进行强制类型转换
	eg:定义一个接受基类引用做为参数的函数,调用该函数时,
		可以将基类对象做为参数,也可以将派生类做为参数
	参数类型为ostream &的函数可以接受ostream对象(cout)或声明的ofstream对象做为参数
	
4.ostream对象格式化方法:
	(1)setf(ios_base::fixed);将对象置于使用定点表示法模式
	(2)setf(ios_base::showpoint);将对象置于显示小数点模式
	(3)precision(2);指定显示多少位小数
	(4)width(15);设定下一次输出使用的字段宽度,只在下一个显示时有效,然后恢复到默认值0
	(5)这些状态都保持不变,直到再次使用这些方法重置数值
	(6)setf(ios_base:fixed);返回调用前所有有效的格式化设置
	(7)ios_base::fmtflags;为存储这种信息所需的数据类型

8.2.7 何时使用引用参数
1.使用引用参数的主要原因:
	(1)修改调用函数中的数据
	(2)通过传递引用而不是数据对象,提高程序的运行效率
2.对于使用传递的值而不做修改的函数:
	(1)数据对象很小,如内置数据类型或小型结构,则按值传递
	(2)如果数据对象是数组,使用指针并声明为const类型
	(3)如果数据对象是较大的结构,则使用const指针或const引用,可以节省复制结构所需的时间和空间
	(4)如果数据对象是类对象,则使用const引用,传递类对象的标准方式是传引用
3.对于修改调用函数中的数据的函数:
	(1)如果数据对象为内置数据类型,则使用指针
	(2)如果数据对象是数组,则只能使用指针
	(3)如果数据对象是结构,则使用引用或指针
	(4)如果数据对象是类对象,则使用引用
	
8.3 默认参数
1.默认参数:函数调用中省略了实参时自动使用的值
2.将默认值赋给原型中的参数,传递的值将覆盖默认值
3.带参数列表的函数,必须从右向左添加默认值
4.实参按从左至右的顺序赋给形参,不能跳过任何参数
5.只有原型需要声明默认值,函数定义可以不声明默认值,eg:char * foo(const char * str,int n = 1);

8.4 函数重载
1.默认参数可以使用不同的参数数目调用同一个函数,函数重载则可以使用多个同名函数
2.术语多态指有多种形式,允许函数可以有多种形式;术语重载指可以有多个同名函数
3.函数重载:完成相同的工作,[使用相同的函数名],[使用不同的参数列表]
4.c++使用上下文来确定使用的函数版本
4.函数重载的关键是函数的参数列表,也称为[函数特征标]
	eg:如果两个函数的参数数目和类型相同,同时参数的排列顺序也相同,则称特征标相同,无关变量名
5.c++允许定义相同函数名的函数,[条件是他们的特征标不同]
6.不与任何原型匹配的调用将进行强制转换,有多种匹配将报错
7.编译器在检查特征标时,[把类型引用和类型本身视为同一个特征标]
8.匹配函数时不区分const和非const变量
	调用时会按const和非const变量进行匹配,编译器根据实参是否为const决定使用哪个函数
9.是特征标,而不是函数类型(返回值类型)使得可以对函数进行重载,返回类型可以相同,但特征标必须不同
10.函数特征标:函数的参数列表,与返回类型无关

8.4.1 重载范例
1.函数特征标不同,即可完成重载

8.4.2 何时使用函数重载
1.当函数执行相同的任务,但使用不同形式的数据时,才应使用函数重载
2.c++编译器对函数进行名称加密,名称修饰、名称矫正,用于区分重载函数
3.函数:名称修饰(名称矫正),根据函数原型中指定的形参类型对每个函数进行加密
	eg:long myFuntionFoo(int,float);
		加密后变为"?myFuntionFoo@YAXH@@z"
4.对原始名称进行的表面看似无意义的修饰(矫正)将对参数数目和类型进行编码,
	添加的一组符号随函数的特征标而异,修饰时使用的约定随编译器而异

8.5 函数模板
1.函数模板:函数模板是通用的函数描述,它们使用通用的类型来定义函数,
	其中的通用类型可以用具体的类型(int,double)代替
	通过将类型做为参数传递给模板,可使编译器生成该类型的函数.
	模板允许以通用类型的方式编写程序,因此有时也被称为通用编程.
	由于类型是用参数表示的,因此模板特性有时也被称为参数化类型
2.函数模板允许以任意类型的方式来定义函数,eg:template<class Any>
3.关键字typename和class是等价的,新版支持typename,旧版支持class
4.使用函数模板,编译器将自动检查实参类型并生成相应的函数
5.使用函数模板的函数,函数原型之前和函数定义之前都要声明函数模板

8.5.1 重载的模板
1.可以像重载常规函数那样重载模板函数,必须保证重载的模板函数特征标不同
2.并非所有模板参数都必须是模板参数类型,模板函数参数类型可以是常规类型
	eg:void Swap(Any *a,Any *b,int n);
		void Swap(Any &a,Any &b);
8.5.2 显式具体化
1.显式具体化:提供一个具体化函数定义,称为显式具体化,使其包含所需的代码
	当编译器找到与函数调用匹配的具体化定义时,将使该用定义,而不再寻找模板
	显式具体化模板的具体化之前要有对应[常规模板函数原型]
2.具体化机制随c++的演变而不断变化
3.第三代具体化定义(IOS/ANSI C++标准)
	(1)对于给定的函数名,可以有非模板函数、模板函数、显式具体化模板函数以及它们的重载版本
	(2)显式具体化的原型和定义应以template<>开头,并通过名称指出类型
	(3)具体化将覆盖常规模板,而非模板函数将覆盖具体化和常规模板
	eg:交换job结构的
		非模板函数原型
		[1]void Swap(job &,job &);
		模板函数原型
		[2]template <class Any>//class在新版编译器中可替换为typename
			void Swap(Any &,Any &);
		[3]具体化原型
			template <>void Swap<job>(job &,job &);
4.如果有多个原型,编译器在选择原型时,非模板版本将优先于显式具体化和模板版本,
	而显式具体化版本将优先于使用模板生成的版本
	优先级:非模板版本 > 显示具体化版本 > 模板版本
5.显式具体化
	eg:template <>void Swap<job>(job &,job&);
	中<job>是可选的,函数的参数类型表明这是job的一个具体化,
	该具体化原型也可编写为
	eg:template <>void Swap(job &,job &);
6.早期版本编译器对于显式具体化模板函数处理方式:
	为要处理的类型定义一个常规函数
	eg:	[1]将template <> void Swap<job>(job &j1,job &j2);替换为
			void Swap(int &m,int &n);
		[2]将template <> void Swap<job>(job &j1,job &j2){//code}替换为
			void Swap(job &j1,job &j2){//code};
	当编译器遇到swap(sue,sidney)时,将选择是使用模板来生成函数定义,
	还是使用非模板函数,原来的编译器使用非模板版本
	
	在非官方编译器下,模板版本优先于常规函数
	eg:	[1]将template <> void Swap<job>(job &j1,job &j2);替换为
			void Swap(job &j1,job &j2);
		[2]将template <> void Swap<job>(job &j1,job &j2){//code}替换为
			void Swap<job>(job &j1,job &j2){//code}

8.5.3 实例化和具体化
1.隐式实例化:在代码中包含函数模板本身并不会生成函数定义,它只是一个用于生成函数定义的方案,
	编译器使用模板为特定类型生成函数定义时,得到的是模板实例,
	模板并非函数定义,使用int的函数模板是函数定义,这种实例化方法被称为[隐式实例化]
2.显式实例化:最初编译器只能通过隐式实例化,来使用模板生成函数定义,
	现代c++允许显式实例化,可以直接命令编译器创建特定的实例
	现代[显式实例化]句法:
		eg:template void Swap<int>(int,int);
	实现了这种特定的编译器看到上述声明后,将使用模板Swap生成一个使用int类型的实例,
	即使用swap模板生成int类型的函数定义
3.与显式实例化不同的是,显式具体化使用下面两个等价声明之一
		eg:template <> void Swap<int>(int &,int &);
			template <> void Swap(int &,int &);
	这些声明的意思是"不使用Swap()模板生成生成函数定义,
	应使用独立的、专门的函数定义显式地为int类型生成函数定义"
	这些原型必须有自己的函数定义
	im:显式具体化在关键字template后面有<>,显式实例化没有<>
4.试图在同一编程单元中使用同一种类型的显式实例化和显式具体化将出错
5.隐式实例化、显式实例化和显式具体化统称为具体化,
	它们的相同之处是它们表示的都是使用具体类型的函数定义,而不是通用描述
6.使用template 和template <>来区分显式实例化和显式具体化
7.eg:
	[1]template <typename Any>
		void Swap(Any &,Any &);
		隐式实例化
	[2]template <> void Swap<job>(job &,job &);
		显式具体化
	[3]在main函数中声明
		tempalte void Swap<char>(char &,char &);
		显式实例化

8.5.4 编译器选择使用哪个版本的函数
1.重载解析:对于函数重载、函数模板和函数模板重载，c++需要一个定义良好的策略，
	来决定为函数调用使用哪个函数定义，尤其是有多个参数时，这一过程称为重载解析
2.重载解析过程:
	[1]创建候选函数列表.其中包含与被调函数同名的函数和模板函数
	[2]使用候选函数列表创建可行函数列表.这些都是参数数目正确的函数，
		为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况
	[3]确定是否有最佳的可行函数.如果有则使用，否则该函数调用出错
	
3.编译器确定最佳可行函数，查看使实参与可候选函数的形参匹配所需进行的转换
	最佳到最差的顺序
	[1]完全匹配，常规函数优先于模板函数
	[2]提升转换，小字节类型转换为大字节类型(char,short自动转换为int,float自动转换为double)
	[3]标准转换，(int转换为char,long转换为double)
	[4]用户定义的转换，如类声明中定义的转换
4.完全匹配和最佳匹配
	[1]进行完全匹配时，c++允许某些"无关紧要的转换",Type表示任意类型
		从实参					到形参
		Type					Type &
		Type &					Type
		Type []					* Type
		Type (argument-list)	Type (*) (argument-list)
		Type 					const Type
		Type 					volatile Type
		Type *					const Type
		Type *					volatile Type
		
	[2]如果有多个匹配的原型，编译器将无法完成重载解析过程
	[3]如果没有最佳可行函数，编译器将生成一条错误信息
	[4]有两个完全匹配的函数，编译器仍可完成重载解析，
		指向非const数据的指针和引用优先与[非const的指针和引用]参数进行匹配
	[5]非模板函数优先于模板函数(包括显式具体化)
	[6]如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先，
		即显式具体化将优先于使用模板隐式生成的具体化
		eg:template <class Type> void recyle(Type t);//常规模板函数
			template <> void recyle<blot>(blot &t);//显式具体化函数(优先)
	[7]术语"最具体"不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少
	[8]部分排序规则:用于找出最具体的模板的规则被称为函数模板的部分排序规则(c++新特性)
	[9]重载解析将寻找最匹配的函数
		(1)只存在一个匹配的函数，选择它
		(2)存在多个匹配的函数，但其中只有一个是非模板函数，选择该函数
		(3)如果存在多个匹配的模板函数，选择更具体的函数
		(4)如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数更具体，
			则函数调用将是不确定的，错误的；如果不存在匹配的函数，将报错
5.有多个参数的函数
	将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。
	编译器必须考虑所有参数的匹配情况。
	如果找到比其他可行函数都合适的函数，则选择该函数。
	一个函数要比其他函数都合适，其所有参数的匹配程度都必须不比其他函数差,
	同时至少有一个参数的匹配程度比其他函数都高
	
		
	