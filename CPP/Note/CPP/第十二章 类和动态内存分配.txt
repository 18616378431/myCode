第十二章 类和动态内存分配

12.1 动态内存和类
1.C++使用new和delete操作符来动态控制内存,这种情况下析构函数必不可少,有时还必须重载赋值操作符

12.1.1 复习范例和静态类成员
1.StringBad类使用一个字符串指针和表示字符串长度的值来保存字符串的信息
	使用静态成员记录创建对象的数量
	[1]使用char * 而不是char数组意味着类没有为字符串本身分配内存
		而是在构造函数中使用new来为字符串分配内存,避免了在类声明中预先定义字符串的长度
	[2]使用静态成员,意味着无论创建多少对象,程序都只创建一个静态类变量副本
		类的所有对象共享一个静态成员,可以方便地记录创建对象的数量
		字符串类通常不需要这样的静态成员
2.在构造函数和析构函数中使用new和delete
3.不能类声明中初始化静态成员变量,因为类声明只描述了如何分配内存,但并不分配内存
	静态类成员可以使用单独的语句在类外进行初始化,静态类成员是单独存储的,不是对象的组成部分
	静态数据成员为整型或枚举型const可以在类声明中初始化
	
	静态数据成员在类声明中声明,在包含类方法的文件中初始化,
	初始化时使用作用域解析操作符指出静态成员所属的类,
	如果静态是整型或枚举型const,则可在类声明中初始化
	eg:	//类外
		int StringBad::num_strings = 0;
		//类内初始化常量
		enum{Lbs_per_stn = 14};//枚举常量
		static const int Lbs_per_stn = 14;//静态常量
4.字符串并不保存在对象中,字符串单独保存在堆内存中,对象仅保留了指向字符串的指针
5.删除对象可以释放对象本身占用的内存,并不会自动释放属于对象成员的指针指向的内存
	在析构函数中使用delete释放对象成员指向由new分配的内存
6.在构造函数中使用new分配内存,必须在相应的析构函数使用delete释放内存
	如果使用new []类分配,则必须使用delete []释放
7.自动存储对象被删除的顺序与创建对象的顺序相反
8.对象的初始化和赋值将调用复制构造函数
	eg:	StringBad sailor = sports;
		等价于
		StringBad sailor = StringBad(sports);
		编译器将自动生成复制构造函数
		StringBad (const StringBad &);
		它创建对象的一个副本

12.1.2 隐式成员函数
1.C++默认提供这些成员函数:
	[1]默认构造函数,如果没有定义构造函数
	[2]复制构造函数,如果没有定义
	[3]赋值操作符,如果没有定义
	[4]默认析构函数,如果没有定义
	[5]地址操作符,如果没有定义
2.编译器将生成函数定义,如果将一个对象赋值给另一个对象,编译器将提供赋值操作符的定义
3.隐式地址操作符将返回调用对象的地址(即this指针)
4.默认构造函数:如果没有提供任何构造函数,C++将创建默认构造函数
	eg:	假如定义了Klunk类,但没有提供任何构造函数,编译器将提供下述默认构造函数
		Klunk::Klunk(){}//隐式默认构造函数
		编译器将提供一个不接受任何参数,也不执行任何操作的构造函数,因为创建对象时总是会调用构造函数
		Klunk lunk;//invoke default constructor
	[1]如果定义了构造函数,C++将不会定义默认构造函数
	[2]如果希望显式地进行初始化对象或创建对象数组时,则必须显式地定义默认构造函数
	[3]默认构造函数没有任何参数、不执行任何操作
	[4]带参数的构造函数也可以是默认构造函数,只要所有参数都有默认值
	[5]只能有一个默认构造函数,否则将产生二义性
5.复制构造函数:用于将一个对象复制到新创建的对象中,它用于初始化过程中,而不是常规的赋值过程中
	类的复制构造函数原型:Class_name (const Class_name &);
	它接受一个指向类对象的常量引用做为参数
	eg:	StringBad (const StringBad &);
	[1]何时调用复制构造函数:
		新建对象并将其初始化为现有同类对象时,复制构造函数将被调用
		eg:	将新对象显式地初始化为现有对象
			motto为StringBad对象
			下列四种情况都将调用复制构造函数
			(1)StringBad ditto(motto);//calls StringBad(const StringBad &);
			(2)StringBad metoo = motto;////calls StringBad(const StringBad &);
			(3)StringBad also = StringBad(motto);//calls StringBad(const StringBad &);
			(4)StringBad *pStringBad = new StringBad(motto);//calls StringBad(const StringBad &);
			其中2、4可能使用复制构造函数直接创建metoo、also,也可能使用复制构造函数生成一个临时对象
			然后将临时对象内容赋给metoo、also,这取决于具体实现
			4中,使用motto初始化一个匿名对象,将新对象的地址赋给pStringBad指针
		每当程序生成了对象副本时,编译器都将使用复制构造函数,当函数按值传递对象或函数返回对象时,
		都将使用复制构造函数,按值传递意味着创建原变量的副本,编译器生成临时对象时,将使用复制构造函数
		何时生成临时对象随编译器而异,无论哪种编译器,按值传递和返回对象时都将调用复制构造函数
		由于按值传递对象将调用复制构造函数,因此应按引用传递对象,这样可以节省调用构造函数的时间
		和存储新对象的空间
	[2]复制构造函数的功能:
		默认复制构造函数逐个复制非静态成员(浅复制),复制的是成员的值
		eg:	StringBad sailor = sports;
			等效于
			StringBad sailor;
			sailor.str = sports.str;
			sailor.len = sports.len;
		如果成员本就是类对象,则将使用这个类的复制构造函数来复制成员对象
		静态函数、静态属性不受影响
		类的静态成员属于整个类,类的所有对象共用
6.复制构造函数哪里出了问题
	[1]程序按值传递类对象时,调用了复制构造函数,初始化了函数形参
		复制构造函数不说明其行为以及不指出创建过程
		析构函数在任何对象过期时都将被调用,无论对象是如何创建的
	[2]解决办法是创建一个显式复制构造函数
		eg:	StringBad (const StringBad & s)
			{
				num_strings++;
				...
			}
		如果类中包含计数对象数量的静态成员,其值在新对象创建时发生变化,应提供一个显式复制构造函数
	[3]隐式的复制构造函数是按值进行复制的
		sailor.str = sports.str;
		这里复制的并不是字符串,而是指向字符串的指针
		两个对象的str指向相同的字符串
		析构函数释放str指向的内存
		delete [] sailor.str;
		因为sailor.str与sports.str指向相同的字符串,
		sports.str指向的字符串被sailor的析构函数释放,
		然后执行sports的析构函数释放str指向的内存将导致错误
		delete [] sports.str;
7.使用显式复制构造函数来解决问题
	[1]在类设计中解决隐式复制构造函数产生的问题,可以使用显式复制构造函数进行深度复制(deep copy)
		复制构造函数复制字符串并将副本的地址赋给str成员,而不仅仅是复制字符串的地址
		这样每个对象都有自己的字符串,而不是引用另一个对象的字符串
		调用析构函数都将释放不同的字符串,而不会试图释放已释放的字符串
		eg: 编写StringBad的复制构造函数:
			StringBad::StringBad(const StringBad & st)
			{
				num_strings++;
				len = st.len;
				str = new char[len + 1];
				std::strcpy(str,st.str);
				std::cout << num_strings << ":\"" << str << "\" object created\n";
			}
	[2]必须使用显式复制构造函数原因在于,一些类使用new初始化的、指向数据的指针,
		而不是数据本身,直接用其进行初始化仅会进行浅复制
	[3]	深复制与浅复制
		(1)如果类中包含new初始化的指针成员,应当定义一个复制构造函数,以复制指针指向的数据,
			而不是仅仅复制指针,这称为深度复制
		(2)复制的另一种形式(成员复制或浅复制)只是复制指针的值,浅复制仅浅浅地复制指针的信息,
			不会复制指针指向的数据
8.赋值操作符:ANSI C允许结构赋值,C++允许对象赋值,C++是通过自动为类重载赋值操作符实现的
	类的赋值操作符原型:Class_name & Class_name::operator= (const Class_name &);
	它接受并返回一个指向对象的引用
	eg: StringBad的复制操作符原型
		StringBad & StringBad::operator= (const StringBad &);
	[1]何时使用赋值操作符
		(1)将已有的对象赋值给另一个对象时,将使用重载的赋值操作符
		eg:	StringBad headline1("Celery Stalks at Midnight");
			...
			StringBad knot;
			knot = headline1;//赋值操作符被调用
		(2)初始化对象时并不一定会调用赋值操作符
		eg:	StringBad metoo = knot;//使用赋值构造函数,可能使用赋值操作符
		该实现可能分两步执行:
			|1|调用复制构造函数创建临时对象,通过赋值将临时对象的值复制到新对象中
	[2]赋值操作符的功能
		与复制构造函数相似,赋值操作符的隐式实现也对成员进行逐个复制(浅复制)
		如果成员本身就是对象,则程序将使用为这个类定义的赋值操作符来复制该成员,
		静态数据成员不受影响
9.赋值的问题出在哪里
	eg:	knot = headline1;
		后创建的对象先执行析构函数
		knot先执行析构函数,释放str指向的内存
		待headline1释放str指向的内存时,重复释放了相同的内存
		释放已经释放的内存将导致不确定结果,可能程序异常终止,可能改变内存中的内容
		问题的出现与隐式复制构造函数相同,是成员复制的问题
		headline1.str与knot.str指向相同的地址
		操作结果不确定,执行的结果因编译器而异,包括显式独立声明或释放隐藏文件占用的硬盘空间
10.解决赋值的问题
	默认的赋值操作符不合适,解决办法是提供赋值操作符定义,进行深复制
	其实现与复制构造函数相似,但也有一些差别
	[1]由于目标对象可能引用了以前分配的数据,所以函数应使用delete []来释放这些数据
	[2]函数应当避免将对象赋给自身,否则给对象重新赋值之前,释放内存操作可能删除对象的内容
	[3]函数返回一个指向对象的引用
	通过返回对象,函数可以像常规赋值操作那样,连续进行赋值
	eg:	StringBad s0,s1,s2;
		s0 = s1 = s2;
		转换为函数调用为
		s0.operator= (s1.operator= (s2));
		返回值是指向对象的引用,参数类型正确
	赋值操作符实现:
	eg:	StringBad & StringBad::operator= (const StringBad & st)
		{
			if(this == &st)
				return *this;//对象赋给自身
			delete [] str;//释放旧的字符串
			len = st.len;
			str = new char[len + 1];
			std::strcpy(str,st.str);
			return *this;
		}
	赋值操作符是仅能由类成员来重载的操作符
	赋值操作不创建新对象,不需要同步num_strings静态变量
	
12.1.3 改进后的新String类
添加赋值构造函数和赋值操作符,使类能够正确管理类对象使用的内存

1.修订后的默认构造函数:
	String::String()
	{
		len = 0;
		str = new char[1];
		str[0] = '\0';
	}
	[1]为什么使用new char[1];而不是new char;
		两者在内存分配上是相同的
		区别是前者与析构函数兼容,后者不兼容
		析构函数包含delete [] str;其对应的应为new char[n];
	[2]delete []与new []初始化的指针和空指针都兼容
		eg:	str = new char[1];
			str[0] = '\0';
			等价于
			str = 0;//设置str为空指针
	[3]以其他方式初始化的指针,使用delete []时结果是不确定的
		eg:	char words[15] = "bad idea";
			char * p1 = words;
			char * p2 = new char;
			char * p3;
			delete [] p1;//未定义行为
			delete [] p2;//未定义行为
			delete [] p3;//未定义行为
2.比较成员函数:
	[1]使用strcmp()函数进行字符串大小比较
		第一个字符串位于第二个之前,operator< ()返回true
		strcmp:	(1)第一个参数位于第二个参数之前,返回负值
				(2)两个字符串相同,返回0
				(3)第一个参数位于第二个参数之后,返回正值
		eg:	bool operator< (const String & st1,const String & st2)
			{
				if(std::strcmp(st1.str,st2.str) < 0)
				{
					return true;
				}
				else
				{
					return false;
				}
				//简化
				return (std::strcmp(st1.str,st2.str) < 0);
			}
			bool operator> (const String & st1,const String & st2)
			{
				return st2.str < st1.str;
			}
			bool operator== (const String & st1,const String & st2)
			{
				return (std:strcmp(st1.str,st2.str) == 0);
			}
	[2]使用友元有助于将String对象与C风格的字符串比较
		eg: String answer;
			if("love" == answer)
			将被转换为
			if(operator== ("love",answer))
			编译器将使用构造函数将代码转换为
			if(operator== (String("love"),answer))
			这将于原型匹配
3.使用中括号表示法来访问字符:
	[1]标准C字符串可以使用中括号来访问字符
	[2]C++中两个中括号组成一个操作符--中括号操作符,可以使用方法重载operator[] ()该操作符
	[3]二元C++操作符位于两个操作数之间,对于中括号操作符,一个操作数位于第一个中括号前
		另一个位于两个中括号之间
		eg:	2 + 5//二元操作符
			city[0],city是第一个操作数,[]是操作符,0是第二个操作数
	[4]String对象opera
		String opera(The Magic Flute");
		opera[4]将转换为函数调用
		opera.operator[] (4)
		其匹配operator[] (int i)
		中括号重载实现
		char & String::operator[] (int i)
		{
			return str[i];
		}
		有了如上定义
		cout << opera[4];将转换为
		cout << opera.operator[] (4);
		返回类型为char &便可以给特定的元素赋值
	[5]String means("might");
		means[0] = 'r';
		公有方法可访问私有数据
		转换为函数调用为means.operator[] (0) = 'r';其等价于means.str[0] = 'r';
		
	[6]假如有常量对象
		const String answer("futile");
		如果只有上述operator[] (int i)定义,下面的赋值语句将出错
		cout << answer[1];//编译时错误
		因为answer是常量,上述方法无法确保不修改数据
	[7]在重载时,C++将区分常量和非常量函数的特征标
		可以提供另一个常量重载成员函数,供常量对象使用
		const char & String::operator[] (int i)const
		{
			return str[i];
		}
4.静态成员函数:
	[1]可以将成员函数声明为静态的(在函数声明前加上static关键字)
		(1)不能通过对象来调用静态成员函数
		(2)静态成员函数不能使用this指针
		(3)静态成员函数实在公有部分声明的,则可以使用类名加上作用域解析操作符来调用
		eg:	为String类添加静态成员函数
			static int HowMany(){return num_strings;}
			其调用方法如下
			int count = String::HowMany();
		(4)静态成员函数不与特定的对象关联,只能使用静态数据成员
			eg:	HowMany可以使用num_strings静态数据成员,但不可访问str和len
	[2]可以使用静态成员函数设置类级(classwide)标记,以控制类某些接口的行为
		eg:	类级可以控制显式类内容的方法所使用的格式
5.进一步重载赋值操作符:
	[1]使用构造函数将普通字符串转换为对象,创建临时对象和释放临时对象将导致效率问题
		eg:	String name;
			char temp[40];
			cin..getline(temp,40);
			name = temp;
			(1)上述语句将调用构造函数String(const char *)创建临时对象
			(2)然后将临时对象的内容复制到name中
			(3)程序调用析构函数释放临时对象
	[2]更好的实现(不适用构造函数进行转换)
		eg:	String & String::operator= (const char * s)
			{
				delete [] str;
				len = std::strlen(s);
				str = new char[len + 1];
				std::strcpy(str,s);
				return *this;
			}
			必须释放str之前占有的内存,并重新分配足够的空间

12.1.4 在构造函数使用new时应注意的事项
1.注意事项:
	[1]如果在构造函数中使用new来初始化指针成员,应在析构函数中使用delete
	[2]new和delete必须互相兼容,new对应delete,new []对应delete []
	[3]如果有多个构造函数应使用相同的方式使用new,要么都带中括号,要么都不带
		所有的构造函数都应与唯一的析构函数兼容
		delete或delete []都与空指针(NULL/0)兼容
	[4]应定义一个复制构造函数,通过深度复制将一个对象初始化为另一个对象
	[5]复制构造函数应分配足够的空间来存储复制的数据,复制数据,不仅仅是复制数据的地址,
		应包含地址指向的内容,还应当适当地更新静态数据成员
	[6]应当定义一个赋值操作符,通过深度复制将一个对象复制给另一个对象
		(1)检查自我赋值
		(2)释放成员指针以前指向的内存
		(3)复制数据不仅仅是数据的地址
		(4)返回指向调用对象的引用
	[7]delete释放不是new分配的内存时,结果是不确定的
	
12.1.5 有关返回对象的说明
返回对象的方式:
	[1]返回指向对象的引用
	[2]指向对象的const引用
	[3]const对象
1.返回指向const对象的引用
	[1]函数返回对象将调用复制构造函数,返回引用不会
	[2]引用指向的对象应在调用函数中存在
	[3]参数都为const引用,返回值应为const引用才匹配
	[4]返回引用效率更高
	eg:	const Vector & Max(const Vector & v1,const Vector & v2)
		{
			if(v1.magval() > v2.magval())
				return v1;
			else
				return v2;
		}
2.返回指向非const对象的引用
	[1]operator= ()的返回值(调用对象)用于连续赋值,
		返回引用可避免该函数调用复制构造函数创建新的对象
		返回非const,使得程序可对其进行修改
		eg:	String s1("count");
			String s2,s3;
			s3 = s2 = s1;
			s3 = s2.operator= (s1);//将该调用的返回值赋给s3
	[2]operator<< ()的返回值(ostream &)用于串接输出
		该重载返回值必须是ostream &,不能是ostream
		使用返回类型为ostream将调用ostream的复制构造函数
		而ostream没有公有的复制构造函数
		cout对象已存在调用函数的作用域内,因此可以返回其引用
3.返回对象
	[1]如果返回的对象是被调用函数的局部变量,则不应按引用方式返回它,因为被调用函数执行完毕时,
		局部对象将调用其析构函数
		当控制权回到调用函数时,引用指向的对象将不再存在
		在这种情况下应返回对象,而不是引用
		例如被重载的算术操作符属于这种情况
		eg:	Vector force1(50,60);
			Vector force2(10,70);
			Vector net;
			net = force1 + force2;
			被返回的对象不是force1的引用,也不是force2的引用,
			返回值不能是在调用函数中已经存在的对象的引用
			Vector::operator+ ()计算的到的两个矢量的和存储在临时对象,
			函数不应返回临时对象的引用,而应返回实际的Vector对象,而不是引用
	[2]	Vector Vector::operator+ (const Vector & b)const
		{
			return Vector(x + b.x,y + b.y);
		}
		(1)调用构造函数创建方法能够访问的对象
		(2)返回语句引发的对复制构造函数的隐式调用创建一个调用程序能够访问的对象
4.返回const对象
	eg:	(1)net = force1 + force2;
			临时对象赋给net
		(2)force1 + force2 = net;
			计算force1,force2的和,将结果保存在临时对象,
		再用net内容覆盖临时对象的内容,然后将临时对象丢弃,原来的矢量全部保持不变
		
		(3)cout << (force1 + force2 = net).magval() << endl;
			显示临时对象的长度,然后将其删除
		
	[1]复制构造函数将创建临时对象来表示返回值
	[2]使用完临时对象时将其丢弃
	[3]将返回值声明为const
	[4]防止滥用,将返回const对象,语句2、3将是非法的
5.总结
	[1]方法或函数返回局部对象,则应返回对象,而不是指向对象的引用,
		这种情况下将使用复制构造函数生成返回的对象
	[2]如果方法或函数要返回一个没有公有复制构造函数类的对象,
		则其必须返回指向对象的引用
	[3]重载操作符可返回对象或其引用,优先引用,效率高,其次返回对象

12.1.6 使用指向对象的指针
1.指向对象的指针不需要使用new来分配内存
	eg:	String * po = new String("test");
2.使用new初始化对象
	eg:	(1)Class_name *pclass = new Class_name(value);
			Class_name为类,value为Type_name类型
		(2)该操作将调用构造函数
			Class_name(Type_name);
		(3)调用复制构造函数
			Class_name(cosnt Type_name & v);			
		(4)Class_name *pclass = new Class_name;
			该操作将调用默认构造函数
		