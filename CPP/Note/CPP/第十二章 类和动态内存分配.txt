第十二章 类和动态内存分配

12.1 动态内存和类
1.C++使用new和delete操作符来动态控制内存,这种情况下析构函数必不可少,有时还必须重载赋值操作符

12.1.1 复习范例和静态类成员
1.StringBad类使用一个字符串指针和表示字符串长度的值来保存字符串的信息
	使用静态成员记录创建对象的数量
	[1]使用char * 而不是char数组意味着类没有为字符串本身分配内存
		而是在构造函数中使用new来为字符串分配内存,避免了在类声明中预先定义字符串的长度
	[2]使用静态成员,意味着无论创建多少对象,程序都只创建一个静态类变量副本
		类的所有对象共享一个静态成员,可以方便地记录创建对象的数量
		字符串类通常不需要这样的静态成员
2.在构造函数和析构函数中使用new和delete
3.不能类声明中初始化静态成员变量,因为类声明只描述了如何分配内存,但并不分配内存
	静态类成员可以使用单独的语句在类外进行初始化,静态类成员是单独存储的,不是对象的组成部分
	静态数据成员为整型或枚举型const可以在类声明中初始化
	
	静态数据成员在类声明中声明,在包含类方法的文件中初始化,
	初始化时使用作用域解析操作符指出静态成员所属的类,
	如果静态是整型或枚举型const,则可在类声明中初始化
	eg:	//类外
		int StringBad::num_strings = 0;
		//类内初始化常量
		enum{Lbs_per_stn = 14};//枚举常量
		static const int Lbs_per_stn = 14;//静态常量
4.字符串并不保存在对象中,字符串单独保存在堆内存中,对象仅保留了指向字符串的指针
5.删除对象可以释放对象本身占用的内存,并不会自动释放属于对象成员的指针指向的内存
	在析构函数中使用delete释放对象成员指向由new分配的内存
6.在构造函数中使用new分配内存,必须在相应的析构函数使用delete释放内存
	如果使用new []类分配,则必须使用delete []释放
7.自动存储对象被删除的顺序与创建对象的顺序相反
8.对象的初始化和赋值将调用复制构造函数
	eg:	StringBad sailor = sports;
		等价于
		StringBad sailor = StringBad(sports);
		编译器将自动生成复制构造函数
		StringBad (const StringBad &);
		它创建对象的一个副本

12.1.2 隐式成员函数
1.C++默认提供这些成员函数:
	[1]默认构造函数,如果没有定义构造函数
	[2]复制构造函数,如果没有定义
	[3]赋值操作符,如果没有定义
	[4]默认析构函数,如果没有定义
	[5]地址操作符,如果没有定义
2.编译器将生成函数定义,如果将一个对象赋值给另一个对象,编译器将提供赋值操作符的定义
3.隐式地址操作符将返回调用对象的地址(即this指针)
4.默认构造函数:如果没有提供任何构造函数,C++将创建默认构造函数
	eg:	假如定义了Klunk类,但没有提供任何构造函数,编译器将提供下述默认构造函数
		Klunk::Klunk(){}//隐式默认构造函数
		编译器将提供一个不接受任何参数,也不执行任何操作的构造函数,因为创建对象时总是会调用构造函数
		Klunk lunk;//invoke default constructor
	[1]如果定义了构造函数,C++将不会定义默认构造函数
	[2]如果希望显式地进行初始化对象或创建对象数组时,则必须显式地定义默认构造函数
	[3]默认构造函数没有任何参数、不执行任何操作
	[4]带参数的构造函数也可以是默认构造函数,只要所有参数都有默认值
	[5]只能有一个默认构造函数,否则将产生二义性
5.复制构造函数:用于将一个对象复制到新创建的对象中,它用于初始化过程中,而不是常规的赋值过程中
	类的复制构造函数原型:Class_name (const Class_name &);
	它接受一个指向类对象的常量引用做为参数
	eg:	StringBad (const StringBad &);
	[1]何时调用复制构造函数:
		新建对象并将其初始化为现有同类对象时,复制构造函数将被调用
		eg:	将新对象显式地初始化为现有对象
			motto为StringBad对象
			下列四种情况都将调用复制构造函数
			(1)StringBad ditto(motto);//calls StringBad(const StringBad &);
			(2)StringBad metoo = motto;////calls StringBad(const StringBad &);
			(3)StringBad also = StringBad(motto);//calls StringBad(const StringBad &);
			(4)StringBad *pStringBad = new StringBad(motto);//calls StringBad(const StringBad &);
			其中2、4可能使用复制构造函数直接创建metoo、also,也可能使用复制构造函数生成一个临时对象
			然后将临时对象内容赋给metoo、also,这取决于具体实现
			4中,使用motto初始化一个匿名对象,将新对象的地址赋给pStringBad指针
		每当程序生成了对象副本时,编译器都将使用复制构造函数,当函数按值传递对象或函数返回对象时,
		都将使用复制构造函数,按值传递意味着创建原变量的副本,编译器生成临时对象时,将使用复制构造函数
		何时生成临时对象随编译器而异,无论哪种编译器,按值传递和返回对象时都将调用复制构造函数
		由于按值传递对象将调用复制构造函数,因此应按引用传递对象,这样可以节省调用构造函数的时间
		和存储新对象的空间
	[2]复制构造函数的功能:
		默认复制构造函数逐个复制非静态成员(浅复制),复制的是成员的值
		eg:	StringBad sailor = sports;
			等效于
			StringBad sailor;
			sailor.str = sports.str;
			sailor.len = sports.len;
		如果成员本就是类对象,则将使用这个类的复制构造函数来复制成员对象
		静态函数、静态属性不受影响
		类的静态成员属于整个类,类的所有对象共用
6.复制构造函数哪里出了问题
	[1]程序按值传递类对象时,调用了复制构造函数,初始化了函数形参
		复制构造函数不说明其行为以及不指出创建过程
		析构函数在任何对象过期时都将被调用,无论对象是如何创建的
	[2]解决办法是创建一个显式复制构造函数
		eg:	StringBad (const StringBad & s)
			{
				num_strings++;
				...
			}
		如果类中包含计数对象数量的静态成员,其值在新对象创建时发生变化,应提供一个显式复制构造函数
	[3]隐式的复制构造函数是按值进行复制的
		sailor.str = sports.str;
		这里复制的并不是字符串,而是指向字符串的指针
		两个对象的str指向相同的字符串
		析构函数释放str指向的内存
		delete [] sailor.str;
		因为sailor.str与sports.str指向相同的字符串,
		sports.str指向的字符串被sailor的析构函数释放,
		然后执行sports的析构函数释放str指向的内存将导致错误
		delete [] sports.str;
7.使用显式复制构造函数来解决问题
	[1]在类设计中解决隐式复制构造函数产生的问题,可以使用显式复制构造函数进行深度复制(deep copy)
		复制构造函数复制字符串并将副本的地址赋给str成员,而不仅仅是复制字符串的地址
		这样每个对象都有自己的字符串,而不是引用另一个对象的字符串
		调用析构函数都将释放不同的字符串,而不会试图释放已释放的字符串
		eg: 编写StringBad的复制构造函数:
			StringBad::StringBad(const StringBad & st)
			{
				num_strings++;
				len = st.len;
				str = new char[len + 1];
				std::strcpy(str,st.str);
				std::cout << num_strings << ":\"" << str << "\" object created\n";
			}
	[2]必须使用显式复制构造函数原因在于,一些类使用new初始化的、指向数据的指针,
		而不是数据本身,直接用其进行初始化仅会进行浅复制
	[3]	深复制与浅复制
		(1)如果类中包含new初始化的指针成员,应当定义一个复制构造函数,以复制指针指向的数据,
			而不是仅仅复制指针,这称为深度复制
		(2)复制的另一种形式(成员复制或浅复制)只是复制指针的值,浅复制仅浅浅地复制指针的信息,
			不会复制指针指向的数据
8.赋值操作符:ANSI C允许结构赋值,C++允许对象赋值,C++是通过自动为类重载赋值操作符实现的
	类的赋值操作符原型:Class_name & Class_name::operator= (const Class_name &);
	它接受并返回一个指向对象的引用
	eg: StringBad的复制操作符原型
		StringBad & StringBad::operator= (const StringBad &);
	[1]何时使用赋值操作符
		(1)将已有的对象赋值给另一个对象时,将使用重载的赋值操作符
		eg:	StringBad headline1("Celery Stalks at Midnight");
			...
			StringBad knot;
			knot = headline1;//赋值操作符被调用
		(2)初始化对象时并不一定会调用赋值操作符
		eg:	StringBad metoo = knot;//使用赋值构造函数,可能使用赋值操作符
		该实现可能分两步执行:
			|1|调用复制构造函数创建临时对象,通过赋值将临时对象的值复制到新对象中
	[2]赋值操作符的功能
		与复制构造函数相似,赋值操作符的隐式实现也对成员进行逐个复制(浅复制)
		如果成员本身就是对象,则程序将使用为这个类定义的赋值操作符来复制该成员,
		静态数据陈冠不受影响
		
			
		
		
