第十一章 使用类
1.操作符重载允许将标准C++操作符用于类对象
2.友元允许非成员函数访问类的私有数据

11.1 操作符重载
1.操作符重载时一种形式的C++多态
2.定义多个特征标不同的相同函数名的函数,叫做函数重载或函数多态,
	使用同名的函数完成相同的基本操作
3.操作符重载将重载的概念使用到操作符上,允许操作符多种含义
4.实际上很多C、C++操作符已经被重载
	eg:	将*操作符用于地址则取出地址中存储的值
		将*用于数字时则将得到它们的乘积
5.C++根据操作数的类型及数目决定采用哪种操作
6.C++允许将操作符重载扩展到用户定义类型,
	编译器将根据操作数类型和数目决定使用哪种操作符定义,
	重载操作符可使代码看起来更自然
	eg:允许将两个对象相加
7.操作符重载隐藏了内部机理,强调了实质,OOP的另一个目标
8.要重载操作符,要使用被称为操作符函数的特殊函数形式,操作符重载格式
	eg:operator op(argument-list);
		op是将要重载的操作符,必须是有效的C++操作符
		重载(+)操作符operator +();
		重载(*)操作符operator *();
		重载数组索引操作符([]),operator []();
9.操作符重载,操作符左边的操作数为调用对象,右边的对象做为参数传递
	隐式使用调用对象,显式使用操作符右边的对象
	eg:Time operator +(const Time & t)const;
		Time a,b,c;
		c = a + b; => c = a.operator +(b);

11.2 计算时间:一个重载操作符范例
1.不要返回指向局部变量或临时对象的引用,函数执行完毕后,局部变量和临时对象将消失,
	引用将指向不存在的数据
	
11.2.1 添加加法操作符
1.重载操作符可以在标识符中使用字母、数字、下划线之外的其他字符
	eg:Time operator +(const Time & t)const;
2.重载操作符将第一个对象做为调用对象,将第二个对象做为参数传递
3.可以像调用普通成员函数一样调用操作符重载函数
	eg:	total = coding.operator +(fixing);//函数表示法
		total = coding + fixing;//操作符表示法
	操作符表示法中,左侧对象为调用对象,操作符右边对象是做为参数传递的对象
	operator+()函数的名称使得可以使用函数表示法或操作符表示法来调用,
	编译器将根据操作数的类型来确定如何做
4.可以将两个以上的对象相加
	eg:	Time t1,t2,t3,t4;
		t4 = t1 + t2 + t3;
		转换为函数调用,(+)为从左向右结合的操作符
		t4 = t1.operator +(t2 + t3); =>
		t4 = t1.operator +(t2.operator +(t3));

11.2.2 重载限制
1.多数C++操作符都可以这样重载,重载的操作符不必是成员函数,
	但必须至少有一个操作数是用户定义类型
2.C++对用户定义的操作符重载限制:
	[1]重载后的操作符必须至少有一个操作数是用户定义的类型,
		这将防止用户为标准类型重载操作符
		eg:不能将减法操作符(-)重载为计算两个double的和
	[2]使用操作符时不能违反操作符原来的句法规则,不能改变操作符的优先级
		eg:不能将求模操作符(%)重载为只使用一个操作数 % x;
			如果将加号操作符重载成两个类相加,则新的操作符与原来的加号具有相同的优先级
	[3]不能定义新的操作符
		eg:不能operator **();表示求幂
	[4]不能重载以下操作符:
		(1)sizeof		-- sizeof操作符
		(2).			-- 成员操作符
		(3).*			-- 成员指针操作符
		(4)::			-- 作用域解析操作符
		(5)?:			-- 条件操作符
		(6)typeid		-- 一个RTTI操作符
		(7)const_cast	-- 强制类型转换操作符 
		(8)dynamic_cast	-- 强制类型转换操作符
		(9)reinterpret	-- 强制类型转换操作符
		(10)static_cast	-- 强制类型转换操作符
		
		可重载操作符
		(1)+	(2)-	(3)*	(4)/	(5)%	(6)^
		(7)&	(8)|	(9)~=	(10)!	(11)=	(12)<
		(13)>	(14)+=	(15)-=	(16)*=	(17)/=	(18)%=
		(19)^=	(20)&=	(21)|=	(22)<<	(23)>>	(24)>>=
		(25)<<=	(26)==	(27)!=	(28)<=	(29)>=	(30)&&
		(31)||	(32)++	(33)--	(34),	(35)->*	(36)->
		(37)()	(38)[]	(39)new	(40)delete	(41)new []	(42)delete []
	[5]	[4]中的可重载操作符大多数都可以通过成员函数或非成员函数重载
		下面的操作符只能通过成员函数重载:
		(1)=	-- 赋值操作符
		(2)()	-- 函数调用操作符
		(3)[]	-- 下标操作符
		(4)->	-- 通过指针访问类成员的操作符
3.重载操作符时应遵循一些明智的限制
	eg:不要将(*)重载为交换两个Time对象的数据成员,
		因为表示法中没有任何内容能够表示操作符完成的工作,
		因此最好定义一个具有说明性的方法Swap()

11.2.3 其他重载操作符
1.重载Time类的减法和乘法操作符
	eg:	Time operator -(const Time & t)const;
		Time operator *(double n)const;
	
11.3 友元简介

1.友元:
	突破类的私有成员访问限制,类的公有方法是访问类私有成员的唯一途径
	[1]友元函数
	[2]友元类
	[3]友元成员函数
2.通过让函数成为类的友元,可以赋予该函数与类的成员函数相同的访问权限
3.为什么需要友元:
	在为类重载二元操作符时(带两个参数的操作符)常常需要友元
	eg:	Time类对象乘以实数
		Time operator *(double n)const;
		A = B * 2.75; =>　A = B.operator *(2.75);
		A = 2.75 * B;编译器不能使用相应成员函数进行替换
		左侧的操作数应是Time对象
	解决方案:非成员函数,(大多数操作符都可以通过成员函数或非成员函数重载)
		非成员函数不是由对象调用的,它使用的所有值都是显式参数
		这样编译器能够将A = 2.75 * B;与非成员函数调用匹配A = operator *(2.75,B);
		该函数原型:Time operator *(double m,const Time & t);
		对于非成员重载操作符函数来说,
		操作符左边的操作数对应于操作符函数的第一个参数,
		操作符右边的操作数对应于操作符函数的第二个参数
4.使用非成员函数可以按所需的顺序获得操作数,非成员函数不能访问类的私有数据
	常规非成员函数不能访问,有一类特殊非成员函数可以访问类的私有成员,
	友元函数可以访问类的私有数据
	
11.3.1 创建友元
1.第一步创建友元:创建友元函数的第一步是将其原型放在类声明中,并在原型声明前加上friend关键字
	类声明中的友元函数声明意味着:
	eg:friend Time operator* (double m,const Time & t);
	[1]虽然operator* ()函数是在类声明中声明的,但它不是成员函数,不能使用成员操作符来调用
	[2]虽然operator* ()函数不是成员函数,但它与成员函数的访问权限相同
2.第二步编写友元函数定义:
	因为友元函数不是成员函数,不需要(Time::)限定符
	不要在定义中使用friend关键字
	eg:	Time operator* (double m,const Time & t)
		{
			Time result;
			long totalminutes = t.hours * m * 60 + t.minutes * m;
			
			result.hours = totalminutes / 60;
			result.minutes = totalminutes % 60;
			
			return result;
		}
	有了上述声明
	A = 2.75 * B; 转换为 A = operator* (2.75,B);
	从而调用前面定义的非成员友元函数
3.简而言之,类的友元函数是非成员函数,但与成员函数具有相同的访问权限
4.友元允许了类的非成员函数访问私有数据,违背了OOP数据隐藏的原则
	应将友元函数看做类的扩展接口的组成部分
	double乘以Time,和Time乘以double,前者要求有友元函数,后者使用成员函数
	这是C++句法的结果,而不是概念上的差别
	通过使用友元函数和类方法可以同时表达这两种操作
	[只有类声明可以决定哪一个函数是友元,所以类声明仍然控制哪些函数可以访问私有数据]
	简而言之,类方法和友元只是表达类接口的两种不同的机制
5.按照下面的方式对定义进行修改,交换乘法操作数的顺序,可以将这个友元函数编写为非友元函数
	Time operator* (double m,const Time & t)
	{
		return t * m;
	}
	原来的版本是显式地访问类对象t的数据,所以它必须是友元
	这个版本将Time对象t作为一个整体使用,让成员函数来处理私有值,因此不必是友元
	
	也可以将该版本做为类的友元,则其可做为类的正式接口组成部分
	如果以后需要函数直接访问私有数据,则只需要修改函数定义即可,不必修改类原型
6.如果要为类重载操作符,并将非类的项做为第一个操作数,则可以用友元函数来反转操作数顺序

11.3.2 常用的友元:重载<<操作符
1.可以对<<操作符重载,使之能与cout一起来显示对象的内容
	<<操作符已经被重载很多次,<<操作符最初是C、C++的位左移操作符
	ostream类对该操作符进行重载,将其转换为一个输出工具
	cout是一个ostream对象,能够识别出所有C++基本类型
	因为针对每种基本类型,ostream类声明中都包含了相应重载的operator<<()定义
	例如一个定义使用int参数,一个定义使用double参数
	要使cout能够识别Time对象,一种方法是将一个新的函数操作符定义添加到ostream类声明中
	这不是更好的方法,更好的办法是,通过Time类声明来让Time类知道如何使用cout
2.[1]<<的第一种重载版本
	(1)要使Time类知道使用cout,必须使用友元函数
		eg:	Time trip;	
			cout << trip;
		该操作使用两个对象,第一个是ostream类对象
		如果使用Time成员函数来重载<<,Time对象将是第一个操作数,必须这样使用
		eg:	trip << cout;
		这样不是好的办法,可以通过使用友元函数
		友元声明:friend void operator<< (ostream & os,const Time & t);
		void operator<< (ostream & os,const Time & t)
		{
			os << t.hours << "hours," << t.minutes << "minutes";
		}
		这样便可以使用下述语句
		cout << trip;
		友元函数使用ostream的os作为第一个参数,通常情况下os引用cout对象
		但也可将这一操作用于其他对象,这种情况下os将引用相应的对象,如cerr
		ofstream继承ostream,可以使用ostream的方法
		调用cout << trip应使用cout对象本身,而不是他的拷贝,因此该友元函数按引用传递
		而不是按值,这样将导致os是cout的一个别名,cerr << trip则使os成为cerr的别名
		Time对象可以按引用或按值传递,但按引用传递效率更高
	(2)友元还是非友元
		新的TIme类声明使operator<<()函数成为Time类的一个友元函数
		但该函数不是ostream类的友元函数,该函数访问了Time类的私有数据
		必须是友元,但没有访问ostream的私有成员,将ostream对象做为整体使用
		所以该函数并不一定必须是ostream类的友元
			
 [2]<<的第二种重载版本
	(1)cout << trip;
		这样可行,但重新定义的<<操作符与cout一起使用时不允许将输出拼接起来
		通常cout是可以拼接的
		int x = 5,y = 8;
		cout << x << y;等同于(cout << x) << y;
		iostream定义中,要求<<操作符左边是ostream对象,因为cout是ostream对象,
		表达式cout << x满足要求
		因为表达式cout << x位于y左侧,所以输出语句也要求该表达式是一个ostream对象
		因此ostream类将operator<<()函数实现返回一个ostream对象
		具体的说,该例子返回调用对象cout,因此表达式cout << x本身是一个ostream对象
		而可以位于<<操作符的左侧
	(2)可以对友元函数使用相同的方法,使其返回ostream对象的引用
		ostream & operator<< (ostream & os,const Time & t)
		{
			os << t.hours << "hours," << t.minutes << "minutes";
			return os;
		}
		返回类型为引用,程序开始执行传递了一个对象引用,函数的返回结果就是传递给它的对象
		cout << trip;被转换为operator<< (cout,trip);返回cout对象
		则可以使用cout << "Trip time = " << trip << "(Tuesday)\n";
		分步解析该表达式
		首先cout << "Trip time = ";调用ostream中的<<定义,显示字符串并返回cout对象
		表达式被返回的cout对象替代变成
		cout << trip << "(Tuesday)\n";
		接下来程序使用Time对象的友元函数重载操作符<<的定义,显示trip的值
		并返回cout对象,则语句变成
		cout << "(Tuesday)\n";
		现在使用ostream中用于字符串的定义<<,来显示最后一个字符串
		operator<< ()版本还可用于将输出写入到文件
		eg:	#include<fstream>
			ofstream fout;
			fout.open("file.txt");
			Time trip(12,40);
			fout << trip;
		其中最后一条语句将转换为
		operator<< (fout,trip);
	(3)类继承的引用,基类可以指向派生类,ostream引用可以指向ostream和ofstream对象
		一般可使用友元函数重载操作符<<显示对象内容
3.友元函数也可以作为内联函数,既是定义也是原型
4.友元函数不需要使用类限定符
