第十六章 string类和标准模板库
1.主要内容:string类、auto_ptr、STL(通用编程技术,generic programming)

16.1 string类
1.C风格字符串支持string.h,在C++中为cstring
2.string头文件提供了string类支持
3.stirng类内容:
    [1]将字符串赋给变量
    [2]合并字符串
    [3]比较字符串
    [4]访问各个元素的重载操作符
    [5]在字符串查找字符串和子字符串

16.1.1 构造字符串
1.string有6个构造函数
2.string实际上是模板规范basic_string<char>的一个typedef,同时省略了与内存管理相关的参数
3.size_type是一个依赖于实现的整型,在头文件string中定义
4.string类将string::npos定义为字符串的最大长度,通常为无符号整型int的最大值
5.NBTS(null-byte-terminated string):空字符结束的字符串--传统C字符串
6.表16.1 string类的构造函数
    构造函数                         描述
    string(cosnt char * s)          将string初始化s指向的NBTS
    string(size_type n,char c)      创建一个包含n个元素的string对象,其中每个元素都被初始化为字符c
    string(const string & str,string size_type n = npos)    将string兑现个初始化为对象str中从位置pos开始到结尾的字符串,或从位置pos开始的n个字符
    string()                        创建一个默认的string对象,长度为0
    string(const char * s,size_type n)  将string初始化为s指向的NBTS中的前n个字符,即使超过了NBTS的结尾,仍将位于s之后内存中的内容做为字符进行复制
    template<class Iter> string(Iter begin,Iter end)    将string对象初始化为区间[begin,end]内的字符,其中begin和end的行为就像指针,用于指定位置,范围包括begin在内,但不包括end,
    即[begin,end),该构造函数接收一个模板参数,在使用时Iter将被替换为参数的实际类型,eg:char *
7.重载的操作符
    [1]+= 将一个字符串附加到另一个字符串后面
    [2]= 将一个字符串赋给另一个字符串,第二个参数可以是string对象、C-风格字符串、char
    [3]<< 显示string对象
    [4][ ] 访问字符串中的各个字符
    [5]+ 第二个参数可以是string对象、C-风格字符串、char
    
16.1.2 string类输入
1.C-风格字符串有3种输入方式:
    char info[100];
    [1]cin >> info;
    [2]cin.getline(info,100); //discard \n
    [3]cin.get(info,100);//leave \n in queue
2.string对象2种输入方式：
    string stuff;
    [1]cin >> stuff;//read a word
    [2]getline(cin,stuff);//read a line,discard \n
3.两个版本的getline()都有一个可选参数,用于指定使用哪个字符来确定输入的边界
    [1]cin.getline(info,100,':');//read up to ':',discard :
    [2]getline(cin,stuff,':');//read up to ':',discard :
4.两个版本getline的区别:
    [1]string版本的getline()将自动调整目标string对象的大小,使之刚好能够存储输入的字符
    eg: char fname[10];
        string lname;
        cin >> fname;//problem for input size > 9 characters
        cin >> lname;//can read a very very long word
        cin.getline(fname,10);//may truncate input
        getline(cin,fname);//no truncation
    [2]设计方面的区别,读取C-风格字符串的函数时istream类的方法,而string版本是独立的函数
    eg: cin.operator>>(fname);
        operator>>(cin,name);
5.深入探讨string输入函数:
    [1]string对象的允许最大长度由常量string:npos指定,通常为unsigned int最大值
    [2]第二个限制因素是程序可以使用的内存
    [3]string版本的getline()函数从输入中读取字符,并将其存储到目标string中,直到发生下列3种情况
        (1)到达文件末尾,输入流eofbit将被设置,方法eof()、fail()都返回true
        (2)遇到分界字符(\n),这将把分界字符从输入流中删除,但不存储它
        (3)读取的字符数达到最大允许值(string::npos和可用内存字节较小的一个),这将设置输入流的failbit,方法fail()、eof()将返回true
    [4]输入流对象有一个统计系统,用于跟踪流的错误状态。在这个系统中,检测到文件末尾将设置eofbit寄存器,检测到输入错误时将设置failbit寄存器,出现无法识别的故障将设置badbit寄存器,一切顺利将设置goodbit寄存器
    [5]string版本的operator>>()函数的行为与此类似,只是它不断读取,直到遇到空白字符并将其留在输入队列中,而不是不断读取,直到遇到分解符并将其丢弃,空白字符指空格、换行符、制表符,即isspace()返回true的字符
    [6]string版本的getline()指定分界符后,将把换行符\n视为普通字符

16.3 使用字符串
1.string对象对全部6个关系操作符都进行了重载,可以比较string对象
2.在机器排序序列中,一个对象位于另一个对象前面,则前者被视为小于后者
    如果机器排序序列为ASCII码,则数字将小于大写字符、大写字符将小于小写字符
3.string对象对每个关系操作符都以三种方式进行重载,以便能够将string对象与另一个string对象、C-风格字符串进行比较,并能够将C-风格字符串与string对象比较
    eg: string snake1("cobra");
        string snake2("coral");
        char snake3[] = "anaconda";
        if(snake1 < snake2)//operator< (const string &,const string &)
            ...
        if(snake1 == snake3)//operator== (const string &,const char *)
            ...
        if(snake3 != snake2)//operator!= (const char *,const string &)
            ...
4.string成员函数size()和length()都返回字符串中的字符数
    eg: if(snake1.length() == snake2.size())
            cout << "Both string has the same length.\n";
    length()函数来自较早版本的string类,size()函数为提供STL兼容性添加的
5.可以以多种方式在字符串中搜索给定的子字符串或字符
    find方法的四个版本:重载的find方法
    方法原型                                                    描述
    size_type find(const string & str,size_type pos = 0)const  从字符串的pos位置开始,查找子字符串str,如果找到,则返回该子字符串首次出现时其首字符的索引;否则,返回string::npos
    size_type find(const char * s,size_type pos = 0)const      从字符串的pos位置开始,查找子字符串s,如果找到,则返回该子字符串首次出现时其首字符的索引;否则,返回string::npos
    size_type find(const char * s,size_type pos = 0,size_type n)从字符串的pos位置开始,查找s的前n个字符组成的子字符串,如果找到,则返回该子字符串首次出现时其首字符的索引;否则返回string::npos
    size_type find(char ch,size_type pos = 0)const             从字符串的pos位置开始,查找字符ch,如果找到,则返回该字符首次出现的位置;否则,返回string::npos
6.string的其他find相关方法:
    rfind(),find_first_of(),find_last_of(),find_first_not_of(),find_last_not_of()
    它们的重载函数特征标都与find相同
    [1]rfind:查找子字符串或字符最后一次出现的位置
    [2]find_first_of:在字符串中查找参数中任何一个字符首次出现的位置
        eg: int where = snake1.find_first_of("hark");//将返回r在cobra中的索引 3
    [3]find_last_of:功能与find_first_of相似,查找的是最后一次出现的位置
        eg: int where = snake1.find_last_of("hark");//将返回a在cobra中的位置
    [4]find_first_not_of:在字符串中查找第一个不被包含在参数中的字符
        eg: int where = snake1.find_first_note_of("hark");//将返回c在cobra的位置
    [5]find_last_not_of:在字符串中查找最后一个不被包含在参数中的字符

16.1.4 string还提供了哪些功能
1.string库提供了许多其他工具,包括完成下述功能的函数:
    [1]删除字符串的部分或全部内容
    [2]用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容
    [3]将数据插入到字符串中或删除字符串中的数据
    [4]将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较
    [5]从字符串中提取子字符串
    [6]将一个字符串中的内容复制到另一个字符串中
    [7]交换两个字符串的内容
    ps:这些函数大多都被重载,以便能够同时处理C-风格字符串和string对象,详见附录F
2.string类的自动调整大小功能:
    每当程序将一个字符附加到字符串末尾时,不能仅仅将已有的字符串加大,因为相邻的内存可能被占用了
    因此可能需要分配一个新的内存块,并将原来的内容复制到新的内存单元中
    如果执行大量这样的操作,效率将非常低
    因此很多C++实现分配一个比实际字符串大的内存块,为字符串提供了增大空间
    然而,如果字符串不断增大,超过了内存块的大小,程序将分配一个大小为原来两倍的新内存块,以提供足够的增大空间
    避免不断地分配新内存块
    [1]方法capacity()返回当前分配给字符串的内存块大小
    [2]方法reserve()限定您能够请求内存块的最小长度
        标准容量选择是16的倍数(win7 MS 15bytes)
3.有string对象但需要C-风格字符串,string对象的c_str()方法返回与string对象存储内容相同的指向C-风格字符串的指针
    eg: string filename;
        cout << "Enter filename:";
        cin >> filename;
        ofstream fout;
        fout.open(filename.c_str());
4.可以使用重载的==操作符来比较string对象,但某些情况下会区分大小写
    通常比较两个字符串是否相等不区分大小写
    C库的stricmp()执行不区分大小写的比较(该函数不属于C标准,不一定通用)
    通过创建该函数的重载版本可以避免上述问题
    eg: #include <cstring>
        #include <string>

        inline bool stricmp(cosnt std::string & strA,const std::string & strB)//overloaded function
        {
            return stricmp(strA.c_str(),strB.c_str()) == 0;
        }

        string strA;
        cin >> strA;
        string strB = "mapleSyrup";

        bool bStringAreEqual = stricmp(strA,strB);
        c_str()方法提供了将C-风格字符串函数转换为string对象函数的路径
5.string库是基于一个模板类的
    template< class charT,class traits = char _traits<charT>,class Allocator = allocator<charT> >
    basic_string{...};
    这个类中包含两个typedef
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    这使得能够使用基于char和wchar_t的字符串
    甚至可以开发某种类似字符的类,并对它使用basic_string模板
    traits类描述关于被选择的字符类型的特定情况,如何对值进行比较
    对于char和wchar_t类型的,有预定义的char_traits模板规范,它们都是traits的默认值
    Allocator是一个管理内存分配的类,对于char和wchar_t类型,有预定义的allocator模板规范,它们都是默认的
    它们按通常的方式使用new和delete,但编程者可保留一部分内存,并提供自己的分配方法
    
16.2 auto_ptr类
1.auto_ptr是一个模板类,用于管理动态内存分配的用法
    eg: (1) void remodel(string & str)
            {
                string * ps = new string(str);
                ...
                str = *ps;
                return ;
            }
            仅分配,未释放
        (2) void remodel(string & str)
            {
                string * ps = new string(str);
                ...
                if(weird_thing())
                    throw exception();
                str = *ps;
                delete ps;
                return ;
            }
            出现异常将不执行delete,导致内存泄漏
2.remodel这样的函数终止(正常终止或异常终止),本地变量都将从栈内存中删除,指针ps占据的内存将被释放
    但ps指向的堆内存并没有释放,希望在ps过期时采取另一项额外的措施,对于基本类型并没有这种额外的服务
    但对于类,则可以通过析构函数机制类提供
    ps只是一个常规指针,不是类对象,如果它是类对象,则可以在过期时让它的析构函数删除被指向的内存
    这正是auto_ptr背后的思想

16.2.1 使用auto_ptr
1.auto_ptr模板定义了类似指针的对象,可以将new获得(直接或间接)的地址赋给这种对象
    当auto_ptr对象过期时,其析构函数将使用delete来释放内存
    因此将new返回的地址赋给auto_ptr对象时,无须记住稍后释放这些内存
    在auto_ptr对象过期时,这些内存将自动被释放
2.要创建auto_ptr对象,必须包含头文件#include <memory>,该文件包括auto_ptr模板,然后使用通常的模板句法来实例化所需类型的指针
    eg: 模板中包括
        template<class X> class auto_ptr{
            public:
                explicit auto_ptr(X * p = 0) throw ();
                ...
        };
        //throw ()表示构造函数不引发任何异常,并且构造函数为显式的,不存在指针到auto_ptr对象的隐式类型转换
        //使用
        auto_ptr<double> pd(new double);//an auto_ptr to double,use place of double *
        auto_ptr<string> ps(new string);//an auto_ptr to string,use place of string *
        new double返回指向double的指针,是auto_tr构造函数的参数,原型中p的实参
3.转换remodel函数:
    (1)包含头文件memory
    (2)将指向string的指针替换为指向string的auto_ptr对象
    (3)删除delete语句
    eg: //improve remodel
        #include <memory>
        void remodel(string & str)
        {
            auto_ptr<string> ps(new string(str));
            ...
            if(weird_thing())
                throw exception();
            str = *ps;//可以对auto_ptr对象执行解引用操作
            //delete ps;
            return ;
        }
        auto_ptr<double> pd;
        double * p_reg = new double;
        pd = p_reg;//not allowed(implicit conversion)
        pd = auto_ptr<double> (p_reg);//allowed(explicit conversion)
        auto_ptr<double> pauto = p_reg;//not allowed(implicit conversion)
        auto_ptr<double> pauto(p_reg);//allowed(explicit conversion)
        模板让您能够通过构造函数将auto_ptr对象初始化为一个常规指针
4.auto_ptr是智能指针(smart pointer),类似于指针,但特性比指针更多
    auto_ptr在很多方面被定义为与常规指针类似
    ps是一个auto_ptr,
    可对它执行解除引用操作(*ps)和递增操作(++ps),
    用它来访问结构成员ps->puffIndex
    将它赋给指向同类型的常规指针,
    赋给另一个同类型的auto_ptr

16.2.2 有关auto_ptr的注意事项
1.new和new [],必须与相应的使用delete和delete [],auto_ptr模板使用的是delete,而不是delete []
    因此它只能与new一起使用,而不腻与new []一起使用
2.没有适用于动态数组的auto_ptr,可以复制头文件memory中的auto_ptr模板,重命名为auto_arr_ptr,
    然后对其进行修改,使之使用delete []
    string vacation("I wandered lonely as cloud.");
    auto_ptr<string> pvac(&vacation);//error 将delete用于非堆内存
    只能对new分配的内存使用auto_ptr,而不要对由new []分配或通过声明变量分配的内存使用它
3.
    auto_ptr<string> ps(new string("I reigned lonely as a cloud"));
    auto_ptr<string> vocation;
    vocation = ps;
    如果两个指针为常规指针,指向同一个string对象,其中一个是另一个的拷贝,ps和vocation过期时将试图删除同一个对象两次
    避免这种问题的方法:
    (1)定义赋值操作符,执行深复制,这样两个指针将指向不同的对象,其中一个对象是另一个对象的拷贝
    (2)建立所有权(ownership)概念,对于特定的对象,只能有一个智能指针拥有它,
        智能指针的构造函数只能删除该只能指针拥有的对象,并使赋值操作符转让所有权,这就是用于auto_ptr的策略
    (3)创建智能更高的指针,跟踪引用特定对象的智能指针数,这被称为引用计数(reference counting)
        例如:赋值时将计数加1,指针过期时计数减1,仅当最后一个指针过期时,delete才被调用
        同样的策略也适用于构造函数
4.下面的方法不适用于auto_ptr对象:
    auto_ptr<string> films[5] = {
        auto_ptr<string> (new string("Fowl Balls")),
        auto_ptr<string> (new string("Duck Walks")),
        auto_ptr<string> (new string("Chicken Runs")),
        auto_ptr<string> (new string("Turkey Errors")),
        auto_ptr<string> (new string("Goose Eggs"))
    };
    auto_ptr<string> owin(films[2]);
    int i;
    cout << "The nominees for best avian baseball film are\n";
    for(i = 0;i < 5;i++)
        cout << *films[i] << endl;
    cout << "The winner is " << *pwin << "!\n";
    问题在于,将所有权从films[2]转让给pwin时,它可能导致films[2]不再引用该字符串
    auto_ptr对象放弃所有权后,将可能不再可用,是否可用取决于实现
5.智能指针
    C++库中auto_ptr对象是一种智能指针(smart pointer),智能指针是这样一种类,即其对象的特征类似于指针
    智能指针可用于存储new分配的内存地址,也可被解除引用
    因为只能指针是一个类对象,一次它可修改和扩充简单指针行为
    例如,只能指针可建立引用计数,这样多个对象可共享由智能指针跟踪的同一个值
    当使用该值的兑现数为0时,只能指针将删除这个值
    智能指针可以提高内存的使用效率,帮助防止内存泄漏

16.3 STL
1.STL提供了一组表示容器、迭代器、函数对象和算法的模板
    (1)容器是一个与数组类似的单元,可存储若干个值,STL容器是同质的,即存储的值类型相同
    (2)算法是完成特定任务(对数组进行排序或在链表中查找特定的值)的处方
    (3)迭代器能够用来遍历容器的对象,与能够遍历数组的指针类似,是广义指针
    (4)函数对象是类似于函数的对象,可以是类对象或函数指针(包括函数名,因为函数名被用作指针)
2.STL使得能够构造各种容器(包括数组、队列、链表)和执行各种操作(包括搜索、排序和随机排列)
3.STL不是面向对象编程,而是通用编程技术(generic programming)

16.3.1 vector模板类
1.在计算中矢量对应数组,数学矢量是使用N个分量表示N维数学矢量,数学矢量类似于N维数组
2.计算矢量存储了一组可随机访问的值,即可以使用索引来直接访问矢量的第n个元素,而不必首先访问前面n-1个元素
3.vector模板定义在头文件<vector>(vector.h)中
4.vector模板使用动态内存分配,可以使用初始化参数指出需要多少矢量
    eg: #include <vector>
        using namespace std;
        vector<int> ratings(5);//a vector of 5 ints
        int n;
        cin >> n;
        vector<double> scores(n);//a vector of n doubles
5.vector的[ ]操作符被重载,可以使用通常的数组表示法来访问各个元素
    eg: ratings[0] = 9;
        for(int i =0;i < n;i++)
            cout << scores[i] << endl;
6.分配器:与string类相似,各种STL容器模板都接受一个可选的模板参数,该参数指定使用哪个分配器对象来管理内存
    eg: vector模板的开头:
        template<class T,class Allocator allocator<T> >
        class vector{...};
        如果省略该可选参数,则容器模板将使用默认的allocator<T>类,这个类以标准方式使用new和delete
        



    






