第十六章 string类和标准模板库
1.主要内容:string类、auto_ptr、STL(通用编程技术,generic programming)

16.1 string类
1.C风格字符串支持string.h,在C++中为cstring
2.string头文件提供了string类支持
3.stirng类内容:
    [1]将字符串赋给变量
    [2]合并字符串
    [3]比较字符串
    [4]访问各个元素的重载操作符
    [5]在字符串查找字符串和子字符串

16.1.1 构造字符串
1.string有6个构造函数
2.string实际上是模板规范basic_string<char>的一个typedef,同时省略了与内存管理相关的参数
3.size_type是一个依赖于实现的整型,在头文件string中定义
4.string类将string::npos定义为字符串的最大长度,通常为无符号整型int的最大值
5.NBTS(null-byte-terminated string):空字符结束的字符串--传统C字符串
6.表16.1 string类的构造函数
    构造函数                         描述
    string(cosnt char * s)          将string初始化s指向的NBTS
    string(size_type n,char c)      创建一个包含n个元素的string对象,其中每个元素都被初始化为字符c
    string(const string & str,string size_type n = npos)    将string兑现个初始化为对象str中从位置pos开始到结尾的字符串,或从位置pos开始的n个字符
    string()                        创建一个默认的string对象,长度为0
    string(const char * s,size_type n)  将string初始化为s指向的NBTS中的前n个字符,即使超过了NBTS的结尾,仍将位于s之后内存中的内容做为字符进行复制
    template<class Iter> string(Iter begin,Iter end)    将string对象初始化为区间[begin,end]内的字符,其中begin和end的行为就像指针,用于指定位置,范围包括begin在内,但不包括end,
    即[begin,end),该构造函数接收一个模板参数,在使用时Iter将被替换为参数的实际类型,eg:char *
7.重载的操作符
    [1]+= 将一个字符串附加到另一个字符串后面
    [2]= 将一个字符串赋给另一个字符串,第二个参数可以是string对象、C-风格字符串、char
    [3]<< 显示string对象
    [4][ ] 访问字符串中的各个字符
    [5]+ 第二个参数可以是string对象、C-风格字符串、char
    
16.1.2 string类输入
1.C-风格字符串有3种输入方式:
    char info[100];
    [1]cin >> info;
    [2]cin.getline(info,100); //discard \n
    [3]cin.get(info,100);//leave \n in queue
2.string对象2种输入方式：
    string stuff;
    [1]cin >> stuff;//read a word
    [2]getline(cin,stuff);//read a line,discard \n
3.两个版本的getline()都有一个可选参数,用于指定使用哪个字符来确定输入的边界
    [1]cin.getline(info,100,':');//read up to ':',discard :
    [2]getline(cin,stuff,':');//read up to ':',discard :
4.两个版本getline的区别:
    [1]string版本的getline()将自动调整目标string对象的大小,使之刚好能够存储输入的字符
    eg: char fname[10];
        string lname;
        cin >> fname;//problem for input size > 9 characters
        cin >> lname;//can read a very very long word
        cin.getline(fname,10);//may truncate input
        getline(cin,fname);//no truncation
    [2]设计方面的区别,读取C-风格字符串的函数时istream类的方法,而string版本是独立的函数
    eg: cin.operator>>(fname);
        operator>>(cin,name);
5.深入探讨string输入函数:
    [1]string对象的允许最大长度由常量string:npos指定,通常为unsigned int最大值
    [2]第二个限制因素是程序可以使用的内存
    [3]string版本的getline()函数从输入中读取字符,并将其存储到目标string中,直到发生下列3种情况
        (1)到达文件末尾,输入流eofbit将被设置,方法eof()、fail()都返回true
        (2)遇到分界字符(\n),这将把分界字符从输入流中删除,但不存储它
        (3)读取的字符数达到最大允许值(string::npos和可用内存字节较小的一个),这将设置输入流的failbit,方法fail()、eof()将返回true
    [4]输入流对象有一个统计系统,用于跟踪流的错误状态。在这个系统中,检测到文件末尾将设置eofbit寄存器,检测到输入错误时将设置failbit寄存器,出现无法识别的故障将设置badbit寄存器,一切顺利将设置goodbit寄存器
    [5]string版本的operator>>()函数的行为与此类似,只是它不断读取,直到遇到空白字符并将其留在输入队列中,而不是不断读取,直到遇到分解符并将其丢弃,空白字符指空格、换行符、制表符,即isspace()返回true的字符
    [6]string版本的getline()指定分界符后,将把换行符\n视为普通字符

16.3 使用字符串
1.string对象对全部6个关系操作符都进行了重载,可以比较string对象
2.在机器排序序列中,一个对象位于另一个对象前面,则前者被视为小于后者
    如果机器排序序列为ASCII码,则数字将小于大写字符、大写字符将小于小写字符
3.string对象对每个关系操作符都以三种方式进行重载,以便能够将string对象与另一个string对象、C-风格字符串进行比较,并能够将C-风格字符串与string对象比较
    eg: string snake1("cobra");
        string snake2("coral");
        char snake3[] = "anaconda";
        if(snake1 < snake2)//operator< (const string &,const string &)
            ...
        if(snake1 == snake3)//operator== (const string &,const char *)
            ...
        if(snake3 != snake2)//operator!= (const char *,const string &)
            ...
4.string成员函数size()和length()都返回字符串中的字符数
    eg: if(snake1.length() == snake2.size())
            cout << "Both string has the same length.\n";
    length()函数来自较早版本的string类,size()函数为提供STL兼容性添加的
5.可以以多种方式在字符串中搜索给定的子字符串或字符
    find方法的四个版本:重载的find方法
    方法原型                                                    描述
    size_type find(const string & str,size_type pos = 0)const  从字符串的pos位置开始,查找子字符串str,如果找到,则返回该子字符串首次出现时其首字符的索引;否则,返回string::npos
    size_type find(const char * s,size_type pos = 0)const      从字符串的pos位置开始,查找子字符串s,如果找到,则返回该子字符串首次出现时其首字符的索引;否则,返回string::npos
    size_type find(const char * s,size_type pos = 0,size_type n)从字符串的pos位置开始,查找s的前n个字符组成的子字符串,如果找到,则返回该子字符串首次出现时其首字符的索引;否则返回string::npos
    size_type find(char ch,size_type pos = 0)const             从字符串的pos位置开始,查找字符ch,如果找到,则返回该字符首次出现的位置;否则,返回string::npos
6.string的其他find相关方法:
    rfind(),find_first_of(),find_last_of(),find_first_not_of(),find_last_not_of()
    它们的重载函数特征标都与find相同
    [1]rfind:查找子字符串或字符最后一次出现的位置
    [2]find_first_of:在字符串中查找参数中任何一个字符首次出现的位置
        eg: int where = snake1.find_first_of("hark");//将返回r在cobra中的索引 3
    [3]find_last_of:功能与find_first_of相似,查找的是最后一次出现的位置
        eg: int where = snake1.find_last_of("hark");//将返回a在cobra中的位置
    [4]find_first_not_of:在字符串中查找第一个不被包含在参数中的字符
        eg: int where = snake1.find_first_note_of("hark");//将返回c在cobra的位置
    [5]find_last_not_of:在字符串中查找最后一个不被包含在参数中的字符

16.1.4 string还提供了哪些功能
1.string库提供了许多其他工具,包括完成下述功能的函数:
    [1]删除字符串的部分或全部内容
    [2]用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容
    [3]将数据插入到字符串中或删除字符串中的数据
    [4]将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较
    [5]从字符串中提取子字符串
    [6]将一个字符串中的内容复制到另一个字符串中
    [7]交换两个字符串的内容
    ps:这些函数大多都被重载,以便能够同时处理C-风格字符串和string对象,详见附录F
2.string类的自动调整大小功能:
    每当程序将一个字符附加到字符串末尾时,不能仅仅将已有的字符串加大,因为相邻的内存可能被占用了
    因此可能需要分配一个新的内存块,并将原来的内容复制到新的内存单元中
    如果执行大量这样的操作,效率将非常低
    因此很多C++实现分配一个比实际字符串大的内存块,为字符串提供了增大空间
    然而,如果字符串不断增大,超过了内存块的大小,程序将分配一个大小为原来两倍的新内存块,以提供足够的增大空间
    避免不断地分配新内存块
    [1]方法capacity()返回当前分配给字符串的内存块大小
    [2]方法reserve()限定您能够请求内存块的最小长度
        标准容量选择是16的倍数(win7 MS 15bytes)
3.有string对象但需要C-风格字符串,string对象的c_str()方法返回与string对象存储内容相同的指向C-风格字符串的指针
    eg: string filename;
        cout << "Enter filename:";
        cin >> filename;
        ofstream fout;
        fout.open(filename.c_str());
4.可以使用重载的==操作符来比较string对象,但某些情况下会区分大小写
    通常比较两个字符串是否相等不区分大小写
    C库的stricmp()执行不区分大小写的比较(该函数不属于C标准,不一定通用)
    通过创建该函数的重载版本可以避免上述问题
    eg: #include <cstring>
        #include <string>

        inline bool stricmp(cosnt std::string & strA,const std::string & strB)//overloaded function
        {
            return stricmp(strA.c_str(),strB.c_str()) == 0;
        }

        string strA;
        cin >> strA;
        string strB = "mapleSyrup";

        bool bStringAreEqual = stricmp(strA,strB);
        c_str()方法提供了将C-风格字符串函数转换为string对象函数的路径
5.string库是基于一个模板类的
    template< class charT,class traits = char _traits<charT>,class Allocator = allocator<charT> >
    basic_string{...};
    这个类中包含两个typedef
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    这使得能够使用基于char和wchar_t的字符串
    甚至可以开发某种类似字符的类,并对它使用basic_string模板
    traits类描述关于被选择的字符类型的特定情况,如何对值进行比较
    对于char和wchar_t类型的,有预定义的char_traits模板规范,它们都是traits的默认值
    Allocator是一个管理内存分配的类,对于char和wchar_t类型,有预定义的allocator模板规范,它们都是默认的
    它们按通常的方式使用new和delete,但编程者可保留一部分内存,并提供自己的分配方法
    
16.2 auto_ptr类
1.auto_ptr是一个模板类,用于管理动态内存分配的用法
    eg: (1) void remodel(string & str)
            {
                string * ps = new string(str);
                ...
                str = *ps;
                return ;
            }
            仅分配,未释放
        (2) void remodel(string & str)
            {
                string * ps = new string(str);
                ...
                if(weird_thing())
                    throw exception();
                str = *ps;
                delete ps;
                return ;
            }
            出现异常将不执行delete,导致内存泄漏
2.remodel这样的函数终止(正常终止或异常终止),本地变量都将从栈内存中删除,指针ps占据的内存将被释放
    但ps指向的堆内存并没有释放,希望在ps过期时采取另一项额外的措施,对于基本类型并没有这种额外的服务
    但对于类,则可以通过析构函数机制类提供
    ps只是一个常规指针,不是类对象,如果它是类对象,则可以在过期时让它的析构函数删除被指向的内存
    这正是auto_ptr背后的思想

16.2.1 使用auto_ptr
1.auto_ptr模板定义了类似指针的对象,可以将new获得(直接或间接)的地址赋给这种对象
    当auto_ptr对象过期时,其析构函数将使用delete来释放内存
    因此将new返回的地址赋给auto_ptr对象时,无须记住稍后释放这些内存
    在auto_ptr对象过期时,这些内存将自动被释放
2.要创建auto_ptr对象,必须包含头文件#include <memory>,该文件包括auto_ptr模板,然后使用通常的模板句法来实例化所需类型的指针
    eg: 模板中包括
        template<class X> class auto_ptr{
            public:
                explicit auto_ptr(X * p = 0) throw ();
                ...
        };
        //throw ()表示构造函数不引发任何异常,并且构造函数为显式的,不存在指针到auto_ptr对象的隐式类型转换
        //使用
        auto_ptr<double> pd(new double);//an auto_ptr to double,use place of double *
        auto_ptr<string> ps(new string);//an auto_ptr to string,use place of string *
        new double返回指向double的指针,是auto_tr构造函数的参数,原型中p的实参
3.转换remodel函数:
    (1)包含头文件memory
    (2)将指向string的指针替换为指向string的auto_ptr对象
    (3)删除delete语句
    eg: //improve remodel
        #include <memory>
        void remodel(string & str)
        {
            auto_ptr<string> ps(new string(str));
            ...
            if(weird_thing())
                throw exception();
            str = *ps;//可以对auto_ptr对象执行解引用操作
            //delete ps;
            return ;
        }
        auto_ptr<double> pd;
        double * p_reg = new double;
        pd = p_reg;//not allowed(implicit conversion)
        pd = auto_ptr<double> (p_reg);//allowed(explicit conversion)
        auto_ptr<double> pauto = p_reg;//not allowed(implicit conversion)
        auto_ptr<double> pauto(p_reg);//allowed(explicit conversion)
        模板让您能够通过构造函数将auto_ptr对象初始化为一个常规指针
4.auto_ptr是智能指针(smart pointer),类似于指针,但特性比指针更多
    auto_ptr在很多方面被定义为与常规指针类似
    ps是一个auto_ptr,
    可对它执行解除引用操作(*ps)和递增操作(++ps),
    用它来访问结构成员ps->puffIndex
    将它赋给指向同类型的常规指针,
    赋给另一个同类型的auto_ptr

16.2.2 有关auto_ptr的注意事项
1.new和new [],必须与相应的使用delete和delete [],auto_ptr模板使用的是delete,而不是delete []
    因此它只能与new一起使用,而不腻与new []一起使用
2.没有适用于动态数组的auto_ptr,可以复制头文件memory中的auto_ptr模板,重命名为auto_arr_ptr,
    然后对其进行修改,使之使用delete []
    string vacation("I wandered lonely as cloud.");
    auto_ptr<string> pvac(&vacation);//error 将delete用于非堆内存
    只能对new分配的内存使用auto_ptr,而不要对由new []分配或通过声明变量分配的内存使用它
3.
    auto_ptr<string> ps(new string("I reigned lonely as a cloud"));
    auto_ptr<string> vocation;
    vocation = ps;
    如果两个指针为常规指针,指向同一个string对象,其中一个是另一个的拷贝,ps和vocation过期时将试图删除同一个对象两次
    避免这种问题的方法:
    (1)定义赋值操作符,执行深复制,这样两个指针将指向不同的对象,其中一个对象是另一个对象的拷贝
    (2)建立所有权(ownership)概念,对于特定的对象,只能有一个智能指针拥有它,
        智能指针的构造函数只能删除该只能指针拥有的对象,并使赋值操作符转让所有权,这就是用于auto_ptr的策略
    (3)创建智能更高的指针,跟踪引用特定对象的智能指针数,这被称为引用计数(reference counting)
        例如:赋值时将计数加1,指针过期时计数减1,仅当最后一个指针过期时,delete才被调用
        同样的策略也适用于构造函数
4.下面的方法不适用于auto_ptr对象:
    auto_ptr<string> films[5] = {
        auto_ptr<string> (new string("Fowl Balls")),
        auto_ptr<string> (new string("Duck Walks")),
        auto_ptr<string> (new string("Chicken Runs")),
        auto_ptr<string> (new string("Turkey Errors")),
        auto_ptr<string> (new string("Goose Eggs"))
    };
    auto_ptr<string> owin(films[2]);
    int i;
    cout << "The nominees for best avian baseball film are\n";
    for(i = 0;i < 5;i++)
        cout << *films[i] << endl;
    cout << "The winner is " << *pwin << "!\n";
    问题在于,将所有权从films[2]转让给pwin时,它可能导致films[2]不再引用该字符串
    auto_ptr对象放弃所有权后,将可能不再可用,是否可用取决于实现
5.智能指针
    C++库中auto_ptr对象是一种智能指针(smart pointer),智能指针是这样一种类,即其对象的特征类似于指针
    智能指针可用于存储new分配的内存地址,也可被解除引用
    因为只能指针是一个类对象,一次它可修改和扩充简单指针行为
    例如,只能指针可建立引用计数,这样多个对象可共享由智能指针跟踪的同一个值
    当使用该值的兑现数为0时,只能指针将删除这个值
    智能指针可以提高内存的使用效率,帮助防止内存泄漏

16.3 STL
1.STL提供了一组表示容器、迭代器、函数对象和算法的模板
    (1)容器是一个与数组类似的单元,可存储若干个值,STL容器是同质的,即存储的值类型相同
    (2)算法是完成特定任务(对数组进行排序或在链表中查找特定的值)的处方
    (3)迭代器能够用来遍历容器的对象,与能够遍历数组的指针类似,是广义指针
    (4)函数对象是类似于函数的对象,可以是类对象或函数指针(包括函数名,因为函数名被用作指针)
2.STL使得能够构造各种容器(包括数组、队列、链表)和执行各种操作(包括搜索、排序和随机排列)
3.STL不是面向对象编程,而是通用编程技术(generic programming)

16.3.1 vector模板类
1.在计算中矢量对应数组,数学矢量是使用N个分量表示N维数学矢量,数学矢量类似于N维数组
2.计算矢量存储了一组可随机访问的值,即可以使用索引来直接访问矢量的第n个元素,而不必首先访问前面n-1个元素
3.vector模板定义在头文件<vector>(vector.h)中
4.vector模板使用动态内存分配,可以使用初始化参数指出需要多少矢量
    eg: #include <vector>
        using namespace std;
        vector<int> ratings(5);//a vector of 5 ints
        int n;
        cin >> n;
        vector<double> scores(n);//a vector of n doubles
5.vector的[ ]操作符被重载,可以使用通常的数组表示法来访问各个元素
    eg: ratings[0] = 9;
        for(int i =0;i < n;i++)
            cout << scores[i] << endl;
6.分配器:与string类相似,各种STL容器模板都接受一个可选的模板参数,该参数指定使用哪个分配器对象来管理内存
    eg: vector模板的开头:
        template<class T,class Allocator allocator<T> >
        class vector{...};
        如果省略该可选参数,则容器模板将使用默认的allocator<T>类,这个类以标准方式使用new和delete
        
16.3.2 可对矢量执行的操作
1.所有的STL容器都提供了一些基本方法,其中包括size()--返回容器中元素数目,swap()--交换两个容器的内容
    begin()--返回一个指向容器第一个元素的迭代器,end()--返回一个表示超过容器尾的迭代器
2.迭代器:一个广义指针,实际上它可以是指针,也可以是一个可对其执行类似指针的操作--如解除引用(operator *())
    和递增(operator ++())--的对象
    对指向迭代器的指针进行广义化使得STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口
    每个容器类都定义了一个合适的迭代器,该迭代器类型时一个名为iterator的typedef,其作用域为整个类
    eg: 为vector的double类型规范声明一个迭代器
        vector<double>::iterator pd;//pd an iterator
        scores是一个vector<double>对象
        vector<double> scores;
        则可以使用迭代器pd执行这样的操作
        pd = scores.begin();
        *pd = 22.3;
        ++pd;
    迭代器的行为就像指针
    超过结尾(past-the-end)的迭代器,它是一种迭代器,指向个容器最后一个元素后面那个元素
    这与C-分隔字符串最后一个字符后面的空字符类似,空字符是一个值,"超过结尾"是一个指向元素的指针(迭代器)
    (1)end()成员函数标识超过结尾的位置
    如果将迭代器设置为容器的第一个元素,并不断地递增,则最终它将到达容器结尾,从而遍历整个容器的内容
    eg: 可以使用下面的代码显式容器的内容
        for(pd = scores.begin();pd != scores.end();pd++)
            cout << *pd << endl;
    所有容器都包含以上方法
    vector模板类也包含一些只有STL容器才有的方法
    (2)push_back()是一个方便的方法,它将元素添加到矢量末尾,这样做时,它将负责内存管理
    增加矢量长度,使之能够容纳新成员
    eg: vector<double> scores;
        double temp;
        while(cin >>temp && temp >= 0)
            scores.push_back(temp);
        cout << "You entered " << scores.size() << " scores.\n";
        每次循环给scores增加一个元素,无需了解元素的数目,有足够的内存,就可以根据需要增加scores的长度
    (3)arase()删除矢量中给定区间的元素,它接受两个迭代器参数,这些参数定义了要删除的区间
    第一个迭代器指向区间的起始处,第二个迭代器位于区间终止处的后一个位置
    eg: scores.erase(scores.begin(),scores.begin() + 2);
        将删除第一个元素和第二个元素,删除begin()和begin()+1指向的元素
        vector实现了随机访问功能,其实现了begin() + 2的操作
        如果it1、it2是迭代器,则STL文档使用(it1,it2)来表示从it1到it2(不包括it2)的区间
        因此区间[begibn(),end()]将包括集合的所有内容,区间[it1,it1]为空
        []表示法不是C++的部分,只能在文档中使用
        区间[it1,it2]由迭代器it1、it2指定,其范围为it1到it2(不包括it2)
    (4)insert()方法的功能与erase()相反,它接受3个迭代器参数,第一个参数指定了新元素的插入位置
        第二个和第三个迭代器参数定义了被插入区间,该区间通常是另一个容器对象的一部分
    eg: vector<int> old;
        vector<int> new;
        ...
        old.insert(old.begin(),new.begin() + 1,new.end());
        将矢量new中除第一个元素以外的所有元素插入到old矢量的第一个元素前面
        这种情况下拥有超尾元素是非常方便的,因为这使得在矢量尾部附加元素非常简单
    eg: old.insert(old.end(),new.begin() + 1,new.end());
        将新元素插入到old.end()前面,即矢量最后一个元素前面
    (5)总结矢量方法:size(),begin(),end(),push_back(),erase(),insert(),swap()

16.3.3对矢量可执行的其他操作
1.矢量模板没有包含常用的对数组的搜索、排序、随机排序等功能,STL从更广泛的角度定义了非成员(non-member)函数来执行这些操作
    不是为每一个容器类都定义一个操作的函数,而是定义了适用于所有容器类的非成员函数,
    这种设计理念省去了大量重复的工作,定义新的容器类时,遵循正确的指导思想,则它也可以使用非成员函数来执行查找、排序等操作
2.3个具有代表性的STL函数:
    for_each()、random_shuffle()、和sort()
    (1)for_each:可用于许多容器类,它接受3个参数,前两个是定义容器中区间的迭代器,最后一个是指向函数的指针(函数对象)
        for_each()将被指向的函数(第三个参数)应用于容器区间中的各个元素,被指向的函数不能修改容器元素的值
        可以用for_each()函数代替for循环
        eg: //迭代器方法遍历区间
            vector<Review>::iterator pr;
            for(pr = books.begin();pr != books.end();pr++)
                ShowReview(*pr);
            //STL函数遍历区间,可避免显式使用迭代器变量
            for_each(books.begin(),books.end(),ShowReview);
    (2)random_shuffle:接受两个指定区间的迭代器参数,并随机排列该区间的元素
        eg: random_shuffle(books.begin(),books.end());
            //这将随机排列books矢量中的所有元素
            与可用于任何容器类的for_each不同,该函数要求容器类允许随机访问,vector类可以满足这一点
    (3)sort:也要求容器支持随机访问,该函数有两个版本
        [1]第一个版本接受两个定义区间的迭代器参数,并使用为存储在容器中的类型元素定义的<操作符
            对区间中的元素进行操作
            eg: vector<int> coolstuff;
                ...
                sort(coolstuff.begin(),coolstuff,end());
                //将按升序进行排序,排序时使用内置的<操作符对值进行比较
            如果容器元素是用户定义对象,则要使用sort,必须定义能够处理该类型对象的operator< ()函数
            可以为Review提供成员或非成员函数operator< (),则可对包含Review对象的矢量进行排序
            eg: bool operator< (const Review & r1,const Review & r2)
                {
                    if(r1.title < r2.title)
                        return true;
                    else if(r1.title == r2.title && r1.rating < r2.rating)
                        return true;
                    else
                        return false;
                }
                有了这样的函数就可以对包含Review对象的矢量进行排序
                sort(books.begin(),books.end());
        如果想按降序排序或按rating进行排序,可以使用另一种格式sort()
        [2]它接受三个参数,前两个参数是指定区间的迭代器,最后一个参数是指向要使用的函数的指针(函数对象)
            而不是用于比较的operator< (),返回值可转换为bool,false表示两个参数的顺序
            eg: bool WorseThan(const Review & r1,const Review & r2)
                {
                    if(r1.rating < r2.rating)
                        return true;
                    else
                        return false;
                }
                有了这个函数则可以对包含Review对象的矢量进行升序排序
                sort(books.begin(),books.end(),WorseThan);
                注意:与operator< ()函数相比,WorseThan()函数执行的对Review对象进行排序的工作不那么完整,
                    如果两个对象的title成员相同,operator< ()函数将按rating进行排序,而WorseThan将它们视为相同
                    第一种排序称为全排序(total ordering),第二种排序称为完整弱排序(strict weak ordering)
                    在全排序中,如果a<b、b<a都不成立,则a和b必定相同
                    在完整弱排序中,它们可能相同,也可能只是在某方面相同,只能说明它们等价,而不是相同
                    
16.4 通用编程技术
1.STL是一种通用编程技术(generic programming)
    面向对象关注的是编程的数据方面,而通用编程技术关注的是算法
    它们之间的共同点是抽象和创建可重用代码,但理念绝然不同
2.通用编程技术旨在编写独立于数据类型的代码
    C++中完成通用程序的工具是模板,模板使得能够按通用类型定义函数或类,而STL通过通用算法更进了一步
    模板让这一切称为可能,但必须对元素进行仔细地设计

16.4.1 为何使用迭代器
1.理解迭代器是理解STL的关键所在,模板使得算法独立于存储的数据类型,而迭代器使得算法独立于使用的容器类型
    它们都是STL通用方法的重要组成部分
2.为何需要迭代器,为两种不同数据表现实现find函数,即推广这种方法
    eg: (1)在double数组中搜索特定的值
        double * find_ar(double * ar,int n,const double & val)
        {
            for(int i = 0;i < n;i++)
                if(ar[i] == val)
                    return &ar[i];
            return 0;
        }
        可以使用模板将这种算法推广到包含==操作符、任意类型的数组
        尽管如此,这种算法仍然与一种特定的数据结构(数组)关联在一起
        (2)在链表中搜索
        struct Node{
            double item;
            Node * p_next;
        };
        Node * find_ll(Node * head,const double & val)
        {
            Node *start;
            for(start = head;start != 0;start = start->p_next)
                if(start->item == val)
                    return start;
            return 0;
        }
        同样也可以使用模板将这种算法推广到支持==操作符的任何数据类型
        这种算法仍然与特定的数据结构(链表)关联在一起
3.通用编程算法旨在使用同一个算法函数来处理数组、链表或任何其他容器类型
    函数不仅独立于容器中存储的数据类型,而且独立于容器本身的数据结构
    模板提供了存储在容器中的数据类型的通用表示,因此还需要遍历容器中的值的通用表示
    迭代器正是这样的通用表示
4.要实现find函数,迭代器需要具备的特征:
    (1)应能够对迭代器执行解除引用操作,以便能够访问它引用的值.如果p是一个迭代器,则应对*p进行定义
    (2)应能够将一个迭代器赋给另一个.如果p、q都是迭代器,则应对表达式p=q进行定义
    (3)应能够将一个迭代器与另一个进行比较,看是否相等.p、q都是迭代器,则应对p==q和p!=q进行定义
    (4)应能够使用迭代器遍历容器中的所有元素,可以通过对迭代器带定义++p和p++来实现
    (5)迭代器也可以有其他功能
5.STL按功能的强弱定义了多种级别的迭代器
    eg: 重新编写find_ar函数
        typdef double * iterator;
        iterator find_ar(iterator ar,int n,const double & val)
        {
            for(int i = 0;i < n;i++,ar++)
                if(*ar == val)
                    return ar;
            return 0;
        }
        修改函数参数,使其接受两个指示区间的指针参数,其中一个指向数组起始位置,另一个指向数组的超尾
        函数可以返回尾指针,指出没有知道要找的值
        typedef double * iterator;
        iterator find_ar(iterator begin,iterator end,const double & val)
        {
            iterator ar;
            for(ar = begin;ar != end;ar++)
                if(*ar == val)
                    return ar;
            return end;
        }
        //对于find_ll函数可以定义一个迭代器类,其中定义了操作符*和++
        struct Node
        {
            double item;
            Node * p_next;
        };
        class iterator
        {
            Node * pt;
        public:
            iterator():pt(0){}
            iterator(Node * pn):pt(pn){}
            double operator* (){return pt->item;}
            iterator & operator++ ()//for ++it,1 + it
            {
                pt = pt->p_next;
                reutrn *this;
            }
            iterator operator++ (int)//for it++,it + 1(int)
            {
                iterator tmp = *this;
                pt = pt->p_next;
                return tmp;
            }
            //operator== (),operator!= (),etc
        };
        为区分++操作符前缀版本和后缀版本,C++将operator++ ()做为前缀版本,
        将operator++ (int)做为后缀版本,其中的参数永远不会用到,所以不必指定其名称
        //改进后的find_ll函数
        iterator find_ll(iterator head,const double & val)
        {
            iterator start;
            for(start = head;start != 0;++start)
                if(*start == val)
                    return start;
            return 0;
        }
        这和find_ar几乎相同,区别在于如何断言已达到最后一个值
        find_ar使用超尾迭代器,而find_ll使用存储在最后一个元素节点中的空值
        除了这种差别,这两个函数完全相同
        可以要求链表的最后一个元素后面还有一个额外的元素,即让数组和链表都有超尾元素
        并在迭代器到达超尾位置时结束搜索,这样find_ar和find_ll检测数据尾的方式将相同
        从而成为相同的算法,增加超尾元素后,对迭代器的要求变成了对容器类的要求
6.STL遵循上面介绍的方法
    首先,每个容器类(vector,list,deque等)定义了相应的迭代器类型
        对于其中某个类,迭代器可能是指针,而对于另一个类,则可能是对象
        不管实现方式如何,迭代器都将提供所需的操作,如*和++(有些类需要的操作可能比其他类多)
    其次,每个容器类都有一个超尾标记,当迭代器递增到超越容器的最后一个值后,这个值将被赋给迭代器
        每个容器类都有begin()和end()方法,它们分别返回指向容器第一个元素和超尾位置的迭代器
        每个容器类都使用++操作符,让迭代器从指向第一个元素逐步指向超尾位置,从而遍历容器中的每一个元素
    使用容器类时,无需知道其迭代器是如何实现的,也无需知道超尾是如何实现的,而只需知道它有迭代器,
        其begin()返回指向第一个月元素的迭代器,end()返回指向超尾位置的迭代器即可
        eg: 打印vector<double>对象中的值
            vector<double>::iterator pr;
            for(pr = scores.begin();pr != scores.end();pr++)
                cout << *pr << endl;
            pr被声明为vector<double>::iterator类型的迭代器
            使用list<double>类模板来存储分数
            list<double>::iterator pr;
            for(pr = scores.begin();pr != scores.end();pr++)
                cout << *pr << endl;
            唯一不同的是pr的类型
    因此STL为每个类定义适当的迭代器,并以统一的风格设计类,能够为内部表示绝然不同的容器,
    编写相同的代码
    就风格而言,应避免直接使用迭代器,而应尽可能使用STL函数(for_each)来处理细节
7.总结STL方法
    (1)处理容器的算法,应尽可能用通用的术语来表达算法,使之独立于数据类型和容器类型
        为使通用算法能够适用于具体情况,应定义能够满足算法需求的迭代器,
        并把要求加到容器设计上
    (2)基于算法的要求,设计基本迭代器的特征和容器特征

16.4.2 迭代器类型
(1).不同的算法对迭代器的要求也不同
    (1)查找算法需要定义++操作符,以便迭代器能够遍历整个容器,它要求能够读取数据,但不要求能够写数据
    (2)排序算法要求能够随机访问,以便能够交换两个不相邻的元素.如果iter是一个迭代器
        则可以通过定义+操作符来实现随机访问,这样就可以使用iter+10这样的表达式
        排序算法要求能够读写数据
(2).STL定义了5种迭代器,并根据所需的迭代器类型对算法进行了描述
    (1)输入迭代器
    (2)输出迭代器
    (3)正向迭代器
    (4)双向迭代器
    (5)随机访问迭代器
    eg: //find的原型与下面类似
        template <class InputIterator,class T>
        InputIterator find(InputIterator first,InputIterator last,const T & value);
        这种算法需要一个输入迭代器
        //sort原型
        template<class RandomAccessIterator>
        void sort(RandomAccessIterator first,RandomAccessIterator last);
        这种算法需要一个随机访问迭代器
(3)这5中迭代器都可以执行解引用操作(为它们定义了*操作符),也可以进行比较(==或!=)
    如果连个迭代器相同,则对它们执行解引用操作得到的值相同
    iter1 == iter2;则*iter1 == *iter2;
    内置操作符和指针同理
1.输入迭代器:
    (1)从程序角度,来自容器的信息被视为输入
        输入迭代器可被程序用来读取容器中的信息
        对输入迭代器执行解引用操作将使程序能够读取容器中的值,但不一定能让程序修改值
        因此,需要输入迭代器的算法将不会修改容器中的值
    (2)输入迭代器必须能够访问容器中所有的值,这是通过++操作符(前缀或后缀)来实现的
        如果将输入迭代器设置为指向容器中第一个元素,并不断将其递增,直到达到超尾位置
        则它将依次指向容器中的每一个元素
        并不能保证输入迭代器第二次遍历容器时,顺序不变
        输入迭代器被递增后,也不能保证其先前的值仍然可以被解除引用
        基于输入迭代器的任何算法都应当是单通行(single-pass)的,不依赖与前一次遍历时迭代器的值
        也不依赖与本次遍历中前面的迭代器值
    (3)输入迭代器是单向迭代,可以递增,不能倒退
2.输出迭代器:将信息从程序传输给容器的迭代器,程序的输出就是容器的输入
    (1)输出迭代器与输入迭代器相似,只是解除引用可以让程序修改容器的值,而不能读取
        如果算法不用读取容器的内容就可以修改它(生成的要存储的值),则没有理由要求它使用能够读取内容的迭代器
    (2)单通行、只读算法,可以使用输入迭代器
        单通行、只写算法,可以使用输出迭代器
3.正向迭代器:只使用++操作符来遍历容器,每次沿容器向前移动一个元素
    (1)与输出、输入迭代器相似,与输入、输出迭代器不同的是,它总是按相同的顺序遍历一系列的值
    (2)正向迭代器递增后,仍然可以对前面的迭代器值解除引用(如果保存了),并可以得到相同的值
        这些特征使多次通行算法成为可能
    (3)正向迭代器既可以使得能够读取和修改数据,也可以使得只能读取数据
        eg: int * pirw;//read-write iterator
            const int * pir;//read-only iterator
4.双向迭代器:
    双向迭代器具有正向迭代器的所有特性,同时支持两种递减操作符(前缀、后缀)
    eg: reverse函数可以交换第一个元素和最后一个元素,将指向第一个元素的指针加1,
        将指向第二个元素的指针减1,并重复这种操作
5.随机访问迭代器:能够直接跳到容器中的任何一个元素,叫做随机访问,需要随机访问迭代器
    算法如(标准排序、二分检索)要求能够随机访问
    (1)随机访问迭代器具有双向迭代器的所有特性,同时添加了支持随机访问的操作(指针增加运算)
        和用于对元素进行排序的关系操作符
    X表示随机迭代器类型、T表示被指向的类型、a和b都是迭代器值,n为整数,r为随机迭代器变量或引用
                    随机访问迭代器操作
    表达式             描述                 
    a + n           指向a所指元素后的第n个元素
    n + a           与a + n相同
    a - n           指向a所指向元素前的第n个元素
    r += n          等价于r = r + n
    r -= n          等价于r = r - n
    a[n]            等价于*(a + n)
    b - a           b = a + n中n的值
    a < b           如果b - a > 0,则为真
    a > b           如果b < a,则为真
    a >= b          如果!(a < b),则为真
    a <= b          如果!(a > b),则为真
    注:a + n这样的表达式仅当a和a + n都位于容器区间(包括超尾)内时才合法

16.4.3 迭代器层次结构
1.正向迭代器具有输入迭代器和输出迭代器的全部功能,同时还有自己的功能
2.双向迭代器具有正向迭代器的全部功能,同时还有自己的功能
3.随机访问迭代器具有双向迭代器的全部功能,同时还有自己的功能
4.根据特定迭代器类型编写的算法可以使用该种迭代器,也可以使用具有所需功能的任何其他迭代器
    具有随机访问迭代器的容器可以使用为输入迭代器编写的算法
5.为何需要这么多算法,为了在编写算法时尽可能使用要求最低的迭代器,并让它适用于容器的最大区间
    通过使用级别最低的输入迭代器,find()函数便可用于任何包含可读取值的容器
    而sort()函数由于需要随机访问迭代器,所有只能用于支持这种迭代器的容器
6.各种迭代器的类型并不是确定的,而是一种概念.
    (1)每个容器都定义了一个类级typedef名称-iterator,vector<int>的迭代器类型为vector<int>::iterator
        矢量迭代器是随机访问迭代器,它允许使用基于任何迭代器类型的算法,因为随机访问迭代器具有所有迭代器的功能
    (2)list<int>类的迭代器类型为list<int>::iterator
        STL实现了一个双向链表,它使用双向迭代器,因此不能使用基于随机访问迭代器的算法
        但可以使用基于要求较低的迭代器的算法
7.迭代器类型关系:
    输入迭代器|输出迭代器 < 正向迭代器 < 双向迭代器 < 随机访问迭代器
8.迭代器功能:i为迭代器 n为整数
    迭代器功能           输入      输出      正向      双向      随机访问
    解除引用读取          有       无        有          有         有
    解除引用写入          无       有        有          有         有
    固定和可重复排序      无        无        有          有         有
    ++i,i++              有       有         有         有          有 
    --i,i--              无       无         无         有          有
    i[n]                 无       无         无         无          有
    i + n                无       无         无         无          有
    i - n                无       无         无         无          有
    i += n               无       无         无         无          有
    i -= n               无       无         无         无          有
    
16.4.4 概念、改进和模型
(1).STL有若干个用C++语言无法描述的特性,如迭代器的种类
    可以设计具有正向迭代器特征的类,但不能让编译器将算法限制为只使用这个类
    正向迭代器是一系列要求,而不是类型
    所设计的迭代器可以满足这种要求,常规指针也可以满足这种要求,STL算法可使用任何满足其要求的迭代器实现
    STL文献使用术语概念(concept)来描述一系列要求
    如果所设计的容器类需要迭代器,可考虑STL,它包含用于标准种类的迭代器模板
(2).概念可以具有类似继承的关系
    双向迭代器继承了正向迭代器的功能,但不能将C++继承用于迭代器
    可以将正向迭代器实现为一个类,将双向迭代器实现为常规指针
    对于C++而言,这种双向迭代器是一种内置类型,不能从派生类而来
    从概念上,它确实能够继承
    有些STL文献使用术语改进(refinement)来表示这种概念上的继承
    因此双向迭代器是对正向迭代器的改进
(3).概念的具体实现被称为模型(model)
    一个常规指针是一个随机访问迭代器模型,也是一个正向迭代器模型,它满足该概念所有要求
1.将指针用作迭代器:
    (1)迭代器是广义指针,指针满足所有的迭代器要求
        迭代器是STL算法的接口,而指针是迭代器,因此STL算法可以使用指针来对基于指针的非STL容器进行操作
        可将STL算法用于数组
        eg: const int SIZE = 100;
            double Receipts[SIZE];
            sort(Receipts,Receipts + SIZE);
            C++确保了表达式Receipts + n是被定义的,只要该表达式的结果位于数组中
            C++支持将超尾概念用于数组,使得可以将STL算法用于常规数组
            由于指针是迭代器,算法是基于迭代器的,这使得可以将STL算法用于常规数组
            可以将STL算法用于自定义的数组形式,只要提供适当的迭代器(指针或对象)和超尾指示器
    (2)STL提供了一些预定义的迭代器
        copy()、ostream_iterator、istream_iterator
        [1]copy()将数据从一个容器复制到另一个容器
            这种算法是以迭代器方式实现的,所以它可以从一个容器到另一个容器进行复制,
            甚至可以在数组之间复制,因为可以将指向数组的指针用作迭代器
            eg: int casts[10] = {6,7,2,9,4,11,8,7,10,5};
                vector<int> dice(10);
                copy(casts,casts + 10,dice.begin());
                前两个参数指示要复制的范围,第三个参数表示要将第一个元素复制到什么位置
                前两个参数必须是输入迭代器,第三个参数必须是输出迭代器
                copy()将覆盖目标容器中已有的数据,目标容器必须足够大
                以便能够容纳被复制的元素
                注:不能使用copy()将数据放到空矢量中,本章后面的技巧可以突破这种限制
        [2]要将信息复制到显示器上
            如果有一个输出流的迭代器,则可以使用copy()
            STL为这种迭代器提供了ostream_iterator模板,该模板是输出迭代器概念的一个模型
            它也是一个适配器(adapter)--一个类或函数,可以将其他接口转换为STL使用的接口
            包含头文件iterator(iterator.h),创建这种迭代器
            #include <iterator>
            ...
            ostream_iterator<int,char> out_iter(cout," ");
            out_iter是一个接口,以便可以使用cout来显式信息
            第一个模板参数指出了发送给输出流的数据类型
            第二个模板参数指出了输出流使用的字符类型(char/wchar_t)
            构造函数的第一个参数指出了要使用的输出流,可以是用于文件的输出流
            最后一个字符串参数是在发送给输出流每个数据项后显示的分隔符
            注:老式C++实现中,只使用了ostream_iterator的第一个模板参数
            eg: ostream_iterator<int,char> out_iter(cout," ");
                *out_iter++ = 15;//cout << 15 << " ";
                对于常规指针,这意味着将15赋给指针指向的位置,然后指针后移一位
                但对于ostream_iterator,这意味着将15和空格组成的字符串发送到cout管理的输出流中
                并为下一个输出操作做好了准备
                可以将copy用于容器
                copy(dice.begin(),dice.end(),out_iter);
                将容器区间复制到输出流中,显式容器内容
                可以创建匿名迭代器
                copy(dice.begin(),dice.end(),ostream_iterator<int,char>(cout," "));
        [3]iterator头文件还定义了istream_iterator模板,使istream输入可用作迭代器接口
            它是一个输入迭代器模型,可以使用两个istream_iterator对象来定义copy()的输入范围
            eg: copy(istream_iterator<int,char>(cin),
                    istream_iterator<int,char>(),
                    dice.begin());
                与ostream_iterator相似,istream_iterator也是用两个模板参数
                第一个模板参数指出要读取的数据类型
                第二个模板参数指出输入流使用的字符类型
                构造函数参数cin意味着使用由cin管理的输入流,省略构造函数参数表示输入失败
                上述代码表示从输入流中读取,直到文件末尾、类型不匹配或出现其他输入故障为止
2.其他有用的迭代器
(1)除了ostream_iterator和istream_iterator之外,头文件iterator还提供了其他一些专用的预定义迭代器类
    reverse_iterator,back_insert_iterator,front_insert_iterator和insert_iterator
    [1]reverse_iterator:
        对reverse_iterator执行递增操作将导致它被递减,不使用常规迭代器,是为了简化对已有的函数的使用
        eg: 显式dice的内容
            ostream_iterator<int,char> out_iter(cout," ");
            copy(dice.begin(),dice.end(),out_iter);
        反向显式容器内容
        vector类有一个名为rbegin()的成员函数和一个名为rend()的成员函数
        前者返回指向超尾的反向迭代器,后者返回指向第一个元素的反向迭代器
        对迭代器执行递增操作将导致它被递减,则可以使用下面语句进行反向显式容器内容
        copy(dice.rbegin(),dice.rend(),out_iter);
        甚至不必声明反向迭代器
        注:rbegin()和end()反回相同的值(超尾),但类型不同(reverse_iterator,iterator)
            rend()和begin()返回相同的值(容器的第一个元素),但类型不同(reverse_iterator,iterator)
        必须对反向迭代器做一种特殊的补偿.假设rp是一个被初始化为dice.rbegin()的反转指针
        则rp指向超尾,因此不能对该地址进行解除引用,如果rend()是第一个元素的位置
        则copy必须提早一个位置停止,因为区间的结尾处不包括在区间内
        反向指针通过先递减,再解除引用解决了这两个问题
        即*rp将在*rp的当前值之前对迭代器执行解除引用,如果rp指向6,则*rp将是位置5的值,以此类推
        如果可以在显式声明迭代器和使用STL函数来处理内部问题(将rbegin()返回值传递给函数)之间选择
        请采用后者,这样要做的工作较少且出错机会更小
    [2]另外3种迭代器(back_insert_iterator,front_insert_iterator和insert_iterator)也将提高STL算法的通用性
        很多STL函数都与copy函数相似,将结果发送到输出迭代器指示的位置
        eg: copy(casts,casts + 10,dice.begin());
            将值复制到dice容器中并覆盖原有值,但该函数不会自动调整容器大小
        将元素添加到容器中且不覆盖,3种插入迭代器通过将复制转换为插入解决了这些问题
        插入将添加新的元素,而不会覆盖已有的数据,并使用自动内存分配来容纳新的元素
        back_insert_iterator将元素插入到容器末尾
        front_insert_iterator将元素插入到容器前端
        insert_iterator将元素插入到insert_iterator构造函数参数指定的位置前面
        这三个插入迭代器都是输出容器概念模型
        这里存在一些限制
        back_insert_iterator只能用于允许在尾部快速插入的容器(快速插入指一个时间固定的算法),vector类符合这种要求
        front_insert_iterator只能用于允许在起始位置做时间固定插入的容器类型,vector类不能满足这种要求,但queue满足
        insert_iterator没有这种限制,因此可以用它将元素插入到矢量前端,但front_insert_iterator对那些支持它的容器执行速度更快
        可以用insert_iterator将复制数据的算法转换为插入数据的算法
        这些迭代器将容器类型做为模板参数,将实际的容器标识做为构造函数参数
        eg: 为名为dice的vector<int>容器创建back_insert_iterator
            back_insert_iterator< vector<int> > back_iter(dice);
            必须声明容器类型的原因是,迭代器必须使用合适的容器方法
            back_insert_iterator的构造函数将假设传递给它的类型有一个push_back()方法
            copy是一个独立函数没有调整容器大小的权限
            但前面的声明让back_iter能够使用方法vector<int>::push_back()方法,该方法有这样的权限
        front_insert_iterator的方式与此相同
        insert_iterator还需一个指示插入位置的构造函数参数
        insert_iterator< vector<int> > insert_iter(dice,dice.begin());
    [3]copy函数不仅可以将信息从一个容器复制到另一个容器,还可以将信息从容器复制到输出流
        从输入流复制到容器中,还可以使用copy将信息插入到容器中

16.4.5 容器种类
(1).STL具有容器概念和容器类型
(2).概念是具有名称的通用类别:容器、序列容器、联合容器等
(3).容器类型时可用于创建具体容器对象的模板
    11个容器类型:deque,list,queue,priority_queue,stack,vector,map,multimap,set,multiset,bitset
    bitset是比特级处理数据的容器
(4).概念对类型进行了分类
1.容器概念:
(1)没有与容器概念对应的类型,但概念描述了所有容器类都通用的元素,它是概念化的基类--容器类并不真正使用继承机制
    容器概念指定了所有STL容器类都必须满足的一系列要求
(2)容器是存储其他对象的对象,被存储的对象必须是同一种类型,可以是OOP意义上的对象,也可以是内置类型
    被存储的对象为容器所有,这意味着容器过期时,存储在容器中的数据也将过期(数据为指针的话,其指向的数据不一定过期)
(3)不能将任何类型的对象存储在容器中,类型必须是可复制构造和可赋值的
    基本类型满足这些要求,类定义没有将复制构造函数和赋值操作符声明为私有或保护的,则类也满足这种要求
(4)基本容器不能保证其元素按顺序存储,也不能保证元素顺序不变,但对概念进行改进后,则可以增加这样的保证
    所有的容器都提供某些特性和操作
(5)下表对通用的特性进行了总结:
    X表示容器类型(vector),T表示存储在容器中的对象类型,a、b表示类型X的值,u表示类型X的标识符
    执行所需的操作时间(快-->慢):复杂度
    编译时间:操作在编译时执行,执行时间为0
    固定时间:操作发生于运行阶段,但独立于对象中元素的数目
    线性时间:时间与元素数目成正比
        a,b都为容器,a==b具有线性复杂度,因为==操作符必须用于容器中每个元素
        容器长度不同,则不需任何单独比较
                    一些基本的容器特征
    表达式         返回值类型           说明                                  复杂度
    X::iterator     指向T的迭代器类型   除输出迭代器外的任何迭代器类型         编译时间
    X::value_type   T                  T的类型                              编译时间
    X u             无                   创建名为u的空容器                   固定
    X()             无                   创建匿名空容器                      固定
    X u(a);         无                   复制构造函数                        线性
    X u = a;        无                   作用同X u(a);                       线性
    (&a)->~X();     void                对容器中每个元素应用析构函数          线性
    a.begin();      迭代器                 返回指向容器的第一个元素的迭代器    固定
    a.end();        迭代器                 返回超尾值迭代器                   固定
    a.size();       无符号整型              返回元素个数,等价于a.end()-a.begin() 固定
    a.swap(b);      void                    交换a和b的内容                    固定
    a == b          可转换为bool            如果a和b长度相同且a中每个元素都等于 线性
                                            (==为真)b中相应的元素,则为真 
    a != b          可转换为bool            返回!(a == b)                     线性
2.序列(sequence):是一种重要的改进,6中STL容器类型(deque,list,queue,priority_queue,stack,vector)都是序列
    (队列能够在队尾添加元素,在队首删除元素，deque表示的双端队列允许在两端添加和删除元素)
    序列概念增加了迭代器至少是正向迭代器的要求,这保证了元素将按特定的顺序排列,不会在两次迭代之间发生变化
    序列还要求其元素按严格的线性顺序排列,即存在第一个元素、最后一个元素,除第一个元素和最后一个元素外,
    每个元素前后都分别有一个元素.数组和链表都是序列,但分支结构(其中每个节点都指向两个子节点)不是序列
    因为序列中元素具有确定顺序,因此可以执行诸如将值插入到特定位置、删除特定区间等操作
                            序列的要求
    X表示容器类型(vector),t表示T类型(存储在容器中值的类型)的值,n表示整数,p、q、i、j表示迭代器
    表达式         返回值类型               说明
    X a(n,t);       无                       声明一个名为a的、由n个t值组成的序列
    X(n,t);         无                       创建一个由n个t值组成的匿名序列
    X a(i,j);       无                       创建一个名为a的序列,并将其初始化为区间[i,j)的内容
    X (i,j);        无                       创建一个匿名序列,并将其初始化为区间[i,j)的内容
    a.insert(p,t);  迭代器                    将t插入到p前面
    a.insert(p,n,t);    void                 将n个t插入到p前面
    a.insert(p,i,j);    void                  将区间[i,j)中的元素插入到p前面
    a.earse(p);     迭代器                     删除p指向的元素
    a.earse(p,q);   迭代器                     删除区间[p,q]中的元素
    a.clear();      void                       等价于a.earse(a.begin(),a.end());
    因为deque、list、queue、priority_queue、stack、vector模板类都是序列概念模型,所以它们都支持以上操作
    还有一些可用其他操作,负责度为固定时间
                            序列的可选要求
    表达式         返回值类型           含义              容器
    a.front()       T&                  *a.begin()      vector,list,deque
    a.back()        T&                  *--a.end()      vector,list,deque
    a.push_front(t) void                a.insert(a.begin(),t)   list,deque
    a.push_back(t)  void                a.insert(a.end(),t)     vector,list,deque
    a.pop_front(t)  void                a.earse(a.begin())      list,deque
    a.pop_back(t)   void                a.earse(--a.end())      vector,list,deque
    a[n]            T&                  *(a.begin() + n)        vector,deque
    a.at(n)         T&                  *(a.begin() + n)        vector,deque
    a[n]和a.at(n)都返回一个指向容器中第n个元素的引用(从0开始编号)
    它们之间的差别在于,如果n落在容器有效区间之外,则a.at(n)将执行边界检查,并引发out_of_range异常
    仅为list、deque定义了push_front,因为其时间复杂度为固定时间,vector需要向后移动每个元素,时间复杂度为线性
    上述的操作为固定时间复杂度实现
    链表和双端队列的设计允许将元素添加到前端,而不用移动其他元素,可以固定时间复杂度来实现push_front()
(1)vector:数组的一种类表示,提供了内存自动管理,可以动态改变vector对象长度,随元素的添加和删除增大缩小
    提供了对元素的随机访问,在尾部添加和删除元素的时间是固定的,但在头部或中间插入和删除元素的复杂度为线性时间
    除了序列外,vector还是可反转容器(reversible container)概念的模型
    这增加了两个类方法,rbegin()和rend(),前者返回指向反转序列的第一个元素的迭代器,后者返回反转序列的超尾迭代器
    eg: for_each(dice.begin().dice.end(),Show);//forward
        for_each(dice.rbegin(),dice.rend(),Show);//reverse
        两种方法返回的迭代器都是类级类型reverse_iterator,对这样的迭代器递增将导致它反向遍历可反转容器
        vector是最简单的序列类型,除非其他类型的特殊优点能够更好地满足要求,否则优先使用vector
(2)deque:在头文件deque声明,表示双端队列(double-ended queue),通常被简称为deque
    在STL中,其实现类似于vector容器,支持随机访问,主要区别在于,从deque对象的开始位置插入和删除元素的时间是固定的
    而不像vector中那样是线性时间,所以如果多数操作发生在序列的起始和结尾处,则应考虑使用deque数据结构
    为实现在deque两端插入和删除的时间为固定,deque对象的设计比vector对象更为复杂
    因此,尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作,vector更快一些
(3)list:在list头文件中声明,表示双向链表,除了第一个元素和最后一个元素外,每个元素都与前后的元素相连接,可以双向遍历链表
    list和vector之间的关键的区别在于,list在链表中任一位置进行插入和删除操作的时间都是固定的
    vector则提供了除结尾外的线性时间的插入和删除,在结尾处插入和删除的操作时间是固定的
    vector强调通过随机访问进行快速访问,list强调快速插入和删除
    与vector相似,list也是可反转容器,与vector不同的是,list不支持数组表示法和随机访问
    与vector迭代器不同,从容器中插入或删除元素后,链表迭代器指向元素将不变
    vector在起始位置插入元素,将后移其他所有元素,第5个元素将包含之前的第四个元素的值
    迭代器指向的位置不变,但指向的值发生了改变
    在list中插入元素,不会移动已有元素,仅对链接信息进行修改,指向某个元素的迭代器仍指向该元素
    但它链接的元素可能与以前不同
    除了序列和可反转容器的函数外,list还包含了链表专用的成员函数
    Alloc模板参数通常有其默认值
                    list成员函数
        函数                                  说明
        void merge(list<T,Alloc> & x)           将链表x与调用链表合并.两个链表必须已经排序
                                                合并后的、经过排序的链表保存在调用链表中,x为空.         
                                                这个函数复杂度为线性时间
        void remove(const T & val)              从链表中删除所有val实例,复杂度为线性时间
        void sort()                             使用<操作符对链表进行排序,N个元素的时间复杂度为NlogN
        void splice(iterator pos,list<T,Alloc>x)将链表x的内容插入到pos前面,x将为空.复杂度为固定时间
        void unique()                           将连续的相同元素压缩为单个元素,复杂度为线性时间
    所有模拟STL序列的类都有insert方法
(4)程序说明:
    insert()和splice()之间的主要区别在于:
        insert()将原始区间的副本插入到目标地址
        splice()则将原始区间移动到目标地址
    splice的其他原型用于移动单个元素和元素区间,splice执行后迭代器仍然有效,仍指向其移动前指向的元素
    unique()只能将相邻的相同的值压缩为单个值,执行list<Type>::sort()后在执行unique则每个值将只占一个位置
    非成员函数sort(),需要随机访问迭代器,快速插入使得不能够进行随机访问,不能将非成员函数sort()用于链表
    list模板提供了成员函数版本sort()
(5)list工具箱
    list方法组成了一个方便的工具箱
    可以对列表先排序然后合并,使用unique函数删除重复元素
    sort(),merge(),unique()方法还各自拥有接受另一个参数的版本,该参数用于指定用来比较元素的函数
    remove()函数也有接受另一个参数的版本,该参数用于指定用来确定是否删除元素的函数
    这些参数都是判定函数
(6)queue:模板类在头文件queue(queue.h)中声明,是一个适配器类
    ostream_iterator就是一个适配器类,让输出流能够使用迭代器接口
    queue模板让底层类(deque)展示典型的队列接口
    queue模板的限制比deque更多,不仅不允许随机访问队列元素,甚至不允许遍历队列
    它将使用限制在定义队列的基本操作,
    可以将元素议添加到队尾,从队首删除元素,查看队首和队尾的值,检查元素数目,测试队列是否为空
                    queue的操作
        方法                              说明
        bool empty()const               如果队列为空返回true,否则返回false
        size_type size()const           返回队列中元素的数目
        T & front()                     返回指向队首元素的引用
        T & back()                      返回指向队尾元素的引用
        void push()(const T & x)        在队尾插入x
        void pop()                      删除队首元素
    注意:pop()是删除数据的方法,不是检索数据的方法,应先使用front检索这个值,然后使用pop将其从队首删除
(7)priority_queue:模板类在有文件queue中声明,是另一个适配器类,支持的操作与queue相同
    两者的区别主要在于:
        在priority_queue中,最大的元素被移到队首
        内部区别在于,默认的底层类是vector
    可以修改用于确定哪个元素放在队首的比较方式,方法是提供一个可选的构造函数参数
    priority_queue<int> pd1;
    priority_queue<int> pq2(greater<int>);//use greater<int> to order
    greater<>()是一个预定义的函数对象
(8)stack:与queue相似,在头文件stack(stack.h)中声明,也是一个适配器类,给底层类(默认情况下是vector)提供了典型的堆栈接口
    stack模板的限制比vector更多,它不仅不允许随机访问堆栈元素,甚至不允许遍历堆栈元素,它把使用限制在定义堆栈的基本操作上,
    可以将压入推到栈顶,从栈顶弹出元素,查看栈顶的值,检查元素数目,测试堆栈是否为空
            stack操作
        方法                      说明
        bool empty()const       如果堆栈为空返回true,否则返回false
        size_type size()const   返回堆栈中元素数目
        T & top()               返回指向栈顶元素的引用
        void push(T & x)        在堆栈顶部插入x
        void pop()              删除栈顶元素
    注意:要使用堆栈中的值,先使用top检索其值,然后使用pop将其从栈顶删除

16.4.6 联合容器
(1)联合容器(associative container):是对容器概念的另一种改进
    联合容器将值与关键字关联在一起,使用关键字来查找值
    值可以是结构,关键字可以是具有唯一性的编号
    对于容器X,表达式X::value_type指出了存储容器中值的类型
    对于关联容器,表达式X::key_type指出了用作关键字的类型
(2)联合容器的有点在于其提供了对值的快速访问
    与序列相似,联合容器也允许插入新元素,但不能指定元素的插入位置
    原因是联合容器通常包含用于确定数据放置位置的算法,以便能够很快检索信息
(3)STL提供了4中联合容器,set、multiset、map、multimap
    前两种是在set(set.h,multiset.h)头文件中定义的,后两种是在map(map.h,multimap.h)头文件中定义的
    最简单的簇(bunch)是set,其值的类型与关键字相同,关键字是唯一的--集合中不会有多个相同的关键字,对于set来说值就是关键字
    multiset类型类似于set,前者可能有多个值的关键字相同
    eg: 关键字和值的类型为int,则multiset对象包含的内容可以是1、2、2、2、3、4、7、7
    对于map类型,值的类型与关键字不同,关键字是唯一的,每个关键字只对应一个值
    multimap与map类似,只是一个关键字可以与多个值关联
1.set范例
    (1)STL set是多个概念的模型,它是一个联合集合,可反转、可排序,关键字是唯一的,它只能存储同一类型的值
        与vector和list相似,set也是用模板参数来提供要存储的值的类型
        set<string> A;//a set of string objects
        可选的第二个模板参数可以用于指示用来对关键字进行排序的比较函数或对象,默认使用less<>模板
        set<string,less<string> > A;//old implementation
    (2)set也有一个将迭代器区间做为参数的构造函数,这样提供了将集合初始化为数组内容的简单方法
        关键字是唯一的,数组中for出现了两次,在集合中只出现了一次,且集合是被排序的
        eg: const int N = 6;
            string s1[N] = {"buffon","thinkers","for","heavy","can","for"};
            set<string> A(s1,s1 + N);
            ostream_iterator<string,char> out(cout," ");
            copy(A.begin(),A.end(),out);
            //buffon,can,for,heavy,thinkers
        数学为集合定义了一些标准操作,并集包含两个集合合并后的内容,如果两个集合中包含相同的值
        则这个值将在并集中只出现一次,因为关键字是唯一的
        交集包含两个集合公有的元素
        两个集合的差是第一个集合减去交集后的结果
        STL提供了这些操作的算法,它们是通用函数而不是方法,因此它们不是只能用于set对象
        所有的set对象都自动满足使用这些算法的先决条件,即容器是经过排序的
        [1]set_union()
            接受5个迭代器参数,前两个定义了集合的区间,接下来的两个定义了第二个集合的区间
            最后一个是输出迭代器,指出将结果集复制到什么位置
            eg: 显式集合A和B
                set_union(A.begin(),A.end(),B.begin(),B.end(),
                ostream_iterator<string,char> (cout," "));
                要将结果集放到集合C中,而不是显式它,则最后一个参数为指向C的迭代器,C.begin()但这样不可用
                原因有两个:
                    首先联合集合将关键字看做是常量,所以C.begin()返回的是固定迭代器,不能用作输出迭代器
                    第二个原因是,与copy()相似,set_union()将覆盖容器中已有数据,并要求容器有足够的空间来容纳信息
                    C是空的不能满足这种要求
                    前面讨论的insert_iterator模板可以解决这两个问题,其可以将复制转换为插入
                    另外它还模拟了输出迭代器的概念,所以可以用它将信息写入容器
                    创建匿名insert_iterator迭代器,将信息复制给C
                    构造函数使用容器名称和迭代器做为参数
                    set_union(A.begin(),A.end(),B.begin(),B.end(),
                        insert_iterator<set<string> > (C,C.ebgin()));
        (2)set_intersection()和set_difference()函数查找交集和获得两个集合的差
            它们的接口与set_union()相同
        (3)两个有用的set方法是lower_bound()和upper_bound()
            [1]lower_bound()方法将关键字做为参数并返回一个迭代器,该迭代器指向集合中第一个不小于关键字参数的成员
            [2]upper_bound()方法将关键字做为参数,并返回一个迭代器,该迭代器返回集合中第一个大于关键字参数的成员
                可以使用这些方法获得一个字符串集合的区间,该区间包含b->f的的所有字符串
        (4)因为排序决定了插入的位置,所以这种类包含只指定要插入的信息,而不指定位置的插入方法
            eg: A,B是字符串集合
                string s("tennis");
                A.insert(s);//insert a value
                B.insert(A.begin(),A.end());//insert a range
2.multimap范例
    (1)与set相似,multimap也是可反转、经过排序的联合容器,但在multimap中,关键字的类型与值类型不同
        在multimap对象中,特定的关键字可能与多个值关联
    (2)基本的multimap声明使用模板参数指定了关键字的类型和所存储值的类型
        可选的第三个模板参数可以用于指出用于对关键字进行排序的比较函数或对象,默认使用less<>模板
        该模板将关键字类型做为参数
        eg: multimap<int,string> codes;
            关键字类型为int,值类型为string
    (3)为将信息结合到一起,实际的值类型将关键字类型和数据类型结合为一对
        为此,STL使用pair<class T,class U>模板类将这两种值存储到一个对象中
        eg: 如果keytype为关键字类型,datatype存储的数据类型,则值类型为pair<const keytype,datatype>
            codes对象中存储的值类型为pair<cosnt int,string>
    (4)创建multimap对象的值
        eg: [1]pair<const int,string> item(213,"Los Angeles");
            codes.insert(item);
            也可以使用匿名函数创建
            codes.insert(pair<const int,string>(213,"Los Angeles"));
            数据项是按关键字进行排序的,所以不需要指出插入位置
            [2]有了pair对象便可以通过first和second成员来访问两个部分
                pair<const int,string> item(213,"Los Angeles");
                cout << item.first << " " << item.second << endl;
    (5)获取有关multimap对象的信息
        [1]count()成员函数用关键字做为参数,并返回具有该关键字的元素数目
        [2]lower_bound()和upper_bound()成员函数将关键字做为参数,它们的工作方式与set的方式相同
        [3]equal_range()成员函数将关键字做为参数,并返回表示与该关键字匹配的区间的迭代器
            该方法返回两个值,存储在pair对象中,此时两个模板参数时迭代器类型
            eg: pair<multimap<KeyType,string>::iterator,
                     multimap<KeyType,string>::iterator> range = 
                     codes.equal_range(718);
                cout << "Cities with area code 718:\n";
                for(it = range.first;it != range.second;it++)
                    cout << (*it).second << endl;

16.5 函数对象
(1)很多STL算法都使用函数对象--也叫函数符(functor)
(2)函数符是可以以函数方式与()结合使用的任意对象,包括函数名、指向函数的指针和重载了()操作符的类对象(定义了operator() ()的类)
    eg: class Linear
        {
        private:
            double slope;
            double y0;
        public:
            Linear(double _s1 = 1,double _y = 0):slope(_s1),y0(_y){}
            double operator() (double x){return y0 + slope * x;}
        };
        重载的()操作符使得能够像函数一样调用Linear对象
        Linear f1;
        Linear f2(2.5,10.0);
        double y1 = f1(12.5);//f1.operator() (12.5);
        double y2 = f2(0.4);
        slope、y0来自对象的构造函数,x来自operator() ()的参数
        for_each(books.begin(),books.end(),ShowReview);
        第三个参数可以是常规函数也可以是函数符
        不能将第三个参数声明为函数指针,因为函数指针指定了参数类型
        因为容器可以包含任意类型的元素,预先无法知道参数类型
        STL通过使用模板解决了这个问题
        for_each的原型
        template<class InputIterator,class Function>
        Function for_each(InputIterator first,InputIterator last,Function f);
        ShowReview的原型
        void ShowReview(const Review & );
        这样标识符ShowReview的类型将为void (*)(const Review &),这也是赋给模板参数Function的类型
        对于不同的函数调用,Function参数可以表示具有重载的()操作符的的类类型
        最终,for_each将具有一个使用f(...)的表达式
        该例中f是一个函数指针,f(...)为调用该函数
        for_each的最后一个参数为对象,则f(...)将是调用其重载的()操作符的对象

16.5.1 函数符概念
1.正如STL定义了容器和迭代器概念,它也定义了函数符概念:
    (1)生成器(generator)是不用参数就可以调用的函数符
    (2)一元函数(unary function)是用一个函数可以调用的函数符
    (3)二元函数(binary function)是用两个参数可以调用的函数符
        eg: 用于for_each的函数符应当是一元函数,因为它每次作用于一个容器元素
    概念改进版(断言):
    (4)返回bool值的一元函数是断言(predicate)
    (5)返回bool值的二元函数是二元断言(binary predicate)
        eg: 一些STL函数需要断言参数或二元断言参数
            例16.7的sort函数使用了二元断言作为其第三个参数
            bool WorseThan(const Review & r1,const Review & r2);
            ...
            sort(books.begin(),books.end(),WorseThan);
    (6)list模板有一个将断言做为参数的remove_if()成员,该函数将断言应用于区间中的每个元素,
        如果断言返回true,则删除这些元素
        eg: 删除链表中大于100的元素
            bool tooBig(int n){return n > 100;}
            list<int> scores;
            ...
            scores.remove_if(tooBig);
        断言只能接收一个参数,但可以通过类成员来传递额外的参数,而不是函数参数
        eg: template <typename T>
            class TooBig
            {
            private:
                T cutoff;
            public:
                TooBig(const T & t):cutoff(t){}
                bool operator() (const T & v){return v > cutoff;}
            };
        remove_if是模板类的一个模板方法,有些老式C++编译器可能不支持
        有一个非成员函数版本的remove_if(),它使用两个区间(两个迭代器)和断言作为参数
        eg: 可以将接收两个参数的模板函数转换为接收一个参数的函数对象
            template<class T>
            bool tooBig(const T & val,const T & lim)
            {
                return > lim;
            }
            转换为函数对象
            template <class T>
            class TooBig
            {
            private:
                T cutoff;
            public:
                TooBig(const T & t):cutoff(t){}
                bool operator() (const T & v){return tooBig<T>(v,cutoff);}
            };
            //use
            TooBig<int> tB100(100);
            int x;
            cin >> x;
            if(tB100(x))//same as tooBig(x,100);
            ...
            函数符时一个适配器,使函数能够满足不同的接口
16.5.2 预定义的函数符
1.STL定义了多个基本的函数符,它们执行诸如将两个值相加、比较两个值是否相等操作
    提供这些函数对象时为了支持将函数作为参数的STl函数
    eg: transform()有两个版本
        (1)第一个版本接收四个参数,前两个参数是指定容器区间的迭代器,第三个参数是指定将结果复制到哪里的迭代器
            最后一个参数是一个函数符,它被应用于区间中的每个元素,生成结果中的新元素
            const int LIM = 5;
            double arr1[LIM] = {36,39,42,45,48};
            vector<double> gr8(arr1,arr1 + LIM);
            ostream_iterator<double,char> out(cout," ");
            transform(gr8.begin(),gr8.end(),out,sqrt);
            计算每一个元素的平方根并将结果输出到输出流
            目标迭代器可以位于原始区间中
            out替换为gr8.being()将使用新值覆盖原来的值
            使用的函数符必须是接收单个参数的函数符
        (2)第二个版本是使用一个接受两个参数的函数,并将该函数用于两个区间中的元素
            用另一个参数(第三个参数)标识第二个区间的起始位置
            m8//vector<double>
            mean//(double,double)返回两个值的平均值
            输出来自gr8和m8的值的平均值
            transform(gr8.begin(),gr8.end(),m8.begin(),out,mean);
            将数组相加
            double add(double x,double y){return x + y;}
            ...
            transform(gr8.begin(),gr8.end(),m8.begin(),out,add);
            这样必须为每个类型定义一个函数,更好的办法是定义一个STL没有定义的模板
2.头文件functional(function.h)定义了多个模板类函数对象,包括plus<>()
    eg: #include <functional>
        ...
        plus<double> add;//create plus<double> object
        double y = add(2.2,3.4);//using plus<double>::operator() ()
        它使得将函数对象做为参数更方便
        transform(gr8.begin(),gr8.end(),m8.begin(),out,plus<double> ());
        可以使用匿名对象构造函数符
3.STL提供了的等价于内置操作符的函数符,算术操作符、关系操作符、逻辑操符
    它们可用于处理C++内置类型或任何用户定义类型(如果重载了相应操作符)
                操作符和相应的函数符
    操作符             相应的函数符          操作符             相应的函数符
    +                   plus                >                   greater
    -                   minus               <                   less
    *                   multiplies(times)   >=                  greater_equal
    /                   divides             <=                  less_equal
    %                   modulus             &&                  logical_and
    -                   nagate              ||                  logical_or
    ==                  equal_to            !                   logical_not
    !=                  not_equal_to

16.5.3 自适应函数符和函数适配器
1.上表中列出的预定义函数符都是自适应的
2.STL有5个相关概念:
    (1)自适应生成器(adaptable generator)
    (2)自使用一元函数(adaptable unary function)
    (3)自适应二元函数(adaptable binary function)
    (4)自适应断言(adaptable predicate)
    (5)自适应二元断言(adaptable binary predicate)
3.使函数符称为自适应的原因是,它携带了标识参数类型和返回值类型的typedef成员
    这些成员分别是result_type、first_argument_type、second_argument_type
    eg: plus<int>对象的返回值类型内标识为plus<int>::result_type,这是int的typedef
    函数符自适应的意义在于:函数适配器对象可以使用函数对象,并认为存在这些typedef成员
    eg: 接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回值类型匹配的变量
    STL提供了使用这些工具的函数适配器类
    eg: transform(gr8.begin(),gr8.end(),out,sqrt);
        将gr8的每个元素增加2.5倍
        multiplies()函数可以执行乘法操作,但它是二元函数,因此需要一个函数适配器,将接受两个参数的函数转换为接受一个参数的函数符
        TooBig已经进行了相似范例,提供了一种方法
        但STL使用binder1st和binder2nd类自动完成这一过程,它们将自适应二元函数转换为一元函数
        (1)binder1st:
            有一个自适应二元函数对象f2(),则可以创建一个binder1st对象,该对象与一个将被用作f2()的第一个参数的特定值val关联
            binder1st(f2,val) f1;
            这一使用单个参数调用f1(x)时,返回的值与将val做为第一个参数、将f1()的参数做为第二个参数调用的f2()的返回值相同
            即f1(x)等价于f2(val,x),只是前者是一元函数,后者是二元函数,f2()函数被适配
            仅当f2()是一个自适应函数时这才能实现
            STL提供了bind1st()函数,以简化binder1st类的声明
            可以为其提供用于构造binder1st对象的函数名称和值,它将返回一个这种类型的对象
            将二元自适应函数multiplies()转换为一元函数
            binder1st(multiplies<double> (),2.5);
            将gr8每个元素*2.5
            transform(gr8.begin(),gr8.end(),out,bind1st(multiplies<double> (),2.5));
        (2)binder2nd:与binder1st类似,只是将常数赋给第二个参数,而不是第一个参数
            有一个bind2nd的助手函数,工作方式类似于bind1st()

16.6 算法
1.STL包含了很多处理容器的非成员函数,
    sort()、copy()、find()、random_shuffle()、set_union()、set_intersection()、set_difference()、transform()
    它们的总体设计是相同的,都使用迭代器来标识要处理的数据区间和结果存放位置
    有些函数还接受一个函数对象参数,并使用它来处理数据
2.对于算法函数设计,有两个主要的通用部分
    它们都使用模板来提供通用类型
    都使用迭代器来提供访问容器中数据的通用表示
    copy()函数可用于将double值存储在数组中的容器、将string值存储在链表中的容器,也可用于将用户定义的对象存储在树结构中(set)的容器
    指针是一种特殊的迭代器,copy()等STL函数可用于常规数组
3.统一的容器设计使得不同类型的容器之间具有明显关系
    可以使用copy()将常规数组中的值复制到vector对象中,将vector对象的值复制到list中
    将list对象中的值复制到set对象中
    可以使用==来比较不同类型的容器,deque和vector
    因为容器重载的==操作符使用迭代器来比较内容
    deque和vector的内容相同且排序相同,则它们是相等的

16.6.1 算法组
1.STL将算法分为四组:
   (1)非修改式序列操作
   (2)修改式序列操作
   (3)排序和相关操作
   (4)通用数字运算
   前三组在algorithm(algo.h)头文件中描述,第四组是专用于数值数据的,位于头文件numeric(old in algo.h)中
   非修改式序列操作对区间中的每个元素进行操作,这些操作不修改容器的内容,eg:find(),for_each()
   修改式序列操作对区间中每个元素进行操作,它们可以修改容器的内容,可以修改值和值的排列顺序,eg: transform(),random_shuffle(),copy()
   排序和相关操作包括多个排序函数(sort())和其他各种函数,包括集合操作
   数字操作包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数,通常这些都是数组的操作特性,vector是最有可能使用这些操作的容器

16.6.2 算法的通用特征
1.STL函数使用迭代器和迭代器区间
    template<class InputIterator,class OutputIterator>
    OutputIterator copy(InputIterator first,InputIterator last,OutputIterator result);
    STL模板使用模板参数名称来表示参数模型的概念
    区间参数必须是输入迭代器或更高级别的迭代器,指示存储结果位置的迭代器必须是输出迭代器或更高级别的迭代器
2.对算法进行分类的方式之一是按结果的存放位置进行分类
    有些算法就地完成工作,有些则创建拷贝
    sort()函数完成工作时将结果存放在原始数据的位置上,sort()是就地算法(in-place algorithm)
    copy()则是将结果发送到另一个位置,所以它是复制算法(copying algorithm)
    transform()可以以这两种方式工作,与copy相似,它使用输出迭代器指示结果的存放位置,与copy不同的是transform()允许输出迭代器指向输入区间,因此它可以使用计算结果覆盖原来的值
    有些算法有两个版本:
        (1)就地版本和复制版本
            STL的约定是,复制版本的名称将以_copy结尾,复制版本将接受一个额外的输出迭代器参数,该参数指定结果的存放位置
            eg: replace()的原型,就地版本
                template <class ForwardIterator,class T>
                void repalce(ForwardIterator first,ForwardIterator last,const T & old_value,const T & new_value);
                它将所有的old_value替换为new_value,这是就地发生的,这种算法同时读写容器元素,因此迭代器类型必须是ForwardIterator或更高级别的
                
                复制版本的原型
                template <class InputIterator,class OutputIterator,class T>
                OutputIterator replace_copy(InputIterator first,InputIterator last,OutputIterator result,const T & old_value,const T & new_value);
                结果被复制到result指定的位置,因此对于指定区间而言,只读输入迭代器足够了
                replace_copy的返回值类型为OutputIterator
                对于复制算法,统一的约定是:返回一个迭代器,该迭代器指向复制的最后一个值后面的一个位置(超尾)
        (2)另一个常见的变体是:有些函数有这样的版本,即根据将函数应用于容器元素得到的结果来执行操作
            这些版本的名称通常以_if结尾
            如果将函数用于旧值时,返回值的true,则replace_if()将把旧值替换为新的值
            replace_if()原型:
                template <class ForwardIterator,class Predicate,class T>
                void replace_if(ForwardIterator first,ForwardIterator last,Predicate pred,const T & new_value);
                断言是返回bool值的一元函数,还有一个replace_copy_if版本
                与InputIterator一样,Predicate也是模板参数名称,可以为T、U
                STL使用Predicate类提醒用户,实参应该是Predicate概念的一个模型
                STL使用Generator和BinaryPredicate等术语来指示必须是其他函数对象概念模型的参数
16.6.3 STL和string类
1.string类不是STL的组成部分,但设计时考虑到了STL,它包含begin()、end()、rbegin()、rend()等成员,因此可以使用STL接口
2.排列组合就是将容器中元素顺序重新安排
    next_permutation()算法将区间内容转换为下一种排序方式,并自动提供唯一的排列组合
    对于字符串,排列方式按照字母递增的顺序进行
    成功返回true,如果区间已处于最后的序列中,否则返回false
    最初的顺序是sort()函数排序后的顺序
16.6.4 函数和容器方法
1.有时可以选择STL方法或STL函数,通常方法是更好的选择
    方法更适合于特定的容器,做为成员函数,它可以使用模板类的内存管理工具,在需要时调整容器长度
    eg: list<int> la;
        ls.remove(4);//remove all 4 from the list
        链表中的所有值为4的元素都将被删除并自动调整链表长度
    还有一个名为remove()的STL算法,它不由对象调用,而是接受区间参数
    list<int> lb;
    remove(lb.begin(),lb.end(),4);
    但是由于该remove函数不是成员函数,因此不能调整链表长度,它将没删除的元素放在链表的开始位置
    并返回一个指向新的超尾值的迭代器,这样就可以使用该迭代器来修改容器的长度
    方法通常更适合,但非方法函数更通用
    可以将其用于数组、string对象、STL容器、还可以用非方法函数处理混合的容器类型
    如将矢量容器中的数据存储到链表中







   





    




    

        









    
        




    



    






