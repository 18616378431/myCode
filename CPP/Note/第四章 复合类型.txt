第四章 复合类型

数组、C-风格字符串、string类字符串、getline()和get()方法读取字符串、
结构、共用体、枚举、指针、new和delete关键字、动态数组、动态结构、自动存储、静态存储、动态存储

===========================数组=================================
数组:一种数据格式，可以存储多个同类型的值
数组声明:元素类型，数组名，元素个数
数组的初始化只可以在声明时进行
可以空出数组元素个数位置，让编译器计算数组大小
C++标准模板库(STL)是一种数组的替代品，模板类vector
===========================数组=================================

===========================字符串=================================
字符串:是存储在内存中连续字节中的一系列字符
C++处理字符串的方式有两种:	
	1.C-风格字符串:以空字符(null character)\0结尾，其ASCII码值为0，用来标记字符串结尾
	2.基于string类库的方法
字符串常量(string constant):又叫字符串字面量，以双引号括起的字符串，可以用来将字符数组初始化为字符串
用引号括起的字符串隐式地包含结尾空字符
	EX:'S'	字符常量		"S" 字符串常量，实际表示字符串所在的内存地址

字符串输入:cin使用空白符(换行、空格、制表符)定界字符串，cin在获取字符串时只读取一个单词，剩余内容留在输入队列中
 
 cin:面向行的类成员函数，getline(),get(),读取一行直到换行符，getline()读取并丢弃换行符，get()将换行符保留在输入队列中
 面向行的输入:getline()
1.getline()读取整行，通过换行符确定结尾,cin.getline(),读取并丢弃换行符
	该函数具有两个参数:	(1)存储输入行内容的数组名称	(2)要读取的字符数
	在读取指定数量的字符或遇到换行符时停止读取
2.get()读取整行，通过换行符确定结尾，cin.get()，将换行符留在输入队列中
	get()变体(1):与getline()接收同样的参数，将换行留在输入队列中
	get()变体(2):不接收任何参数，读取整行
	可以将cin的两个成员函数拼接起来，因为cin.get(name,SIZE)成员函数返回cin对象，可以继续调用其他成员函数
3.输入空行问题:get()读取空行后将设置失效位(failbit),接下来的输入将被阻断，使用cin.clear()恢复输入
4.输入字符串比分配的空间长:getline()和get()会将余下的字符留在输入队列中，getline()会设置失效位，并关闭后面的输入
cin读取内容时，会将回车键产生的换行符留在输入队列中
===========================字符串=================================

===========================string类=================================
字符串对象:string类
使用string类需要包含头文件string，string类位于名称空间std中
string对象的使用方式与使用字符数组相同:
	1.使用C风格的字符串来初始化string对象
	2.使用cin读取输入流存储到string对象中
	3.使用cout显示string对象
	4.可以使用数组表示法访问string对象中的字符
string对象与char数组的主要区别:可以已将string对象声明为简单变量，而不是数组
从理论上将，可以讲char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体
string类的赋值、拼接、附加:
	(1)可以将一个string对象赋值给另一个对象，char数组不可以	string  str1,str2;str1 = str2;
	(2)可以用操作符+将两个string对象合并起来		str3 = str1 + str2;
	(3)可以用操作符+=将一个字符串附加到另一个字符串		str3 += str2;
string类对象处理:包含头文件cstring(string.h)，可以使用strcpy(),strcat()
string类方法:size()//查看字符串字母个数str.size();
strlen()从数组第一个元素开始计算字节数，直到遇到空字符，无论是否超出数组边界
===========================string类=================================

===========================结构=================================
创建结构:
	(1)定义结构描述，描述并标记能够存储在结构中的数据类型、属性
	(2)创建结构对象
	(3)结构中的每一项称为结构成员
	(4)C++允许声明结构变量时省略struct关键字
	(5)访问类成员函数是从访问结构成员衍生而来
	(6)可以使用string类对象类型的变量作为结构成员
	(7)可以创建结构数组，与创建基本数组方式相同
结构属性:
	(1)作为参数传递给函数
	(2)将一个结构赋值(=)给另一个结构，成员赋值(memberwiseassignment)
	(3)可以在定义结构时声明结构变量并初始化
	(4)可以定义无标记的结构，并声明一个结构变量
	(5)可以用初始化数组规则和初始化结构规则来初始化结构数组
结构中的位字段:
	(1)C++允许使用占用特定位的结构成员
	(2)类型(整型或枚举)、成员名、冒号、数值(指定使用的位数)	struct tag{unsigned int SN:4;unsigned int 4;};
	(3)可以使用无名称的位字段来提供间距
	(4)每个成员成为位字段(bit field)
===========================结构=================================

===========================共用体=================================
共用体是一种数据格式，可以存储不同的数据类型，但只能同时存储其中一种类型
语法:
	(1)与结构相似，但含义不同	union call{int in_val;float float_val;double double_val};
	(2)可以使用call存储int、float、double，但不能同时存储，只能存储其中一种
属性:
	(1)匿名共用体(anonymous union)没有名称，其成员位于相同地址
	(2)结构体中的匿名共用体成员被视为结构体成员，但是共用体成员具有相同的地址，且同一时间只有一个成员是活动的
	(3)共用体的长度取决于最大成员的长度
	(4)共用体可以节省空间
===========================共用体=================================

===========================枚举=================================
枚举(enum)工具提供了创建符号常量的方式 
语法:
	(1)可以像结构声明一样声明枚举	enum spec{red,blue};//枚举成员称为枚举量
属性:
	(1)不进行强制类型转换的情况下，可以赋值已定义的值给枚举变量
	(2)枚举只有赋值操作符，不可以使用“+”等操作符
	(3)枚举常量是整型，可以被提升为int类型，int类型不能转换为枚举类型
	(4)只使用枚举常量，不创建枚举变量，可以省略枚举类型名
	(5)可以显式地设置枚举量的值
	(6)可以创建多个相同值的枚举常量
枚举的取值范围:
	(1)枚举上限:找出枚举中的最大值，枚举上限就是比最大值大的最小的2的幂，并将其值减一
	(2)枚举下限:如果最小值不小于0，下限为0;否则查找方式与上限相同，加上负号		最小枚举量为-6，则比它小的最小的2的幂为-8,下限位-7
 ===========================枚举=================================

===========================指针和自由存储空间=================================
指针存储的是地址
*操作符被称为间接值(indirect value)或解除引(dereferencing)用操作符
初始化指针时，系统只为指针分配内存，不为指针所指向的数据分配内存
		
		使用new操作符分配内存
变量是在编译阶段就已经确定名称和内存的数据
使用new来分配内存:程序运行时分配内存
new操作符根据类型大小找到一块正确的内存，并返回该内存块的地址
	int * p = new int;//为指针分配一块int大小的内存
数据对象:为数据分配的内存块，可以是结构体、基本类型......
new需要指明合适的指针类型和内存类型
内存耗尽:没有足够的内存分配空间，new将返回0,0在C++中称为空指针(null pointer)，除了无法分配内存，返回0，还可能发生bad_addloc异常

		使用delete释放内存
只能用delete释放new分配的内存，并且不会删除指向那块内存的指针，对空指针使用delete是安全的
	int * p = new int;
	delete p;

		使用new来创建动态数组
静态联编(static binding):在编译时为数组分配内存，数组在编译时加入程序
动态联编(dynamic binding):使用new操作符，程序运行时，需要数组则创建，否则不创建，还可以确定数组长度，运行时分配
动态数组(dynamic array):动态联编创建的数组称为动态数组
创建动态数组:将数组元素类型和个数告诉new:	int * p = new int [10];//创建10个int元素的int数组，返回第一个元素的地址
释放动态数组:delete [] p;//[]指明释放的是p指向的数组内存
new和delete规则:
	(1)不可以使用delete释放不是new分配的内存
	(2)不可以使用delete释放同一内存两次
	(3)使用new [] 为数组分配内存，使用delete []释放
	(4)使用new []为一个实体分配内存，使用delete释放
	(5)对空指针使用delete是安全的
	使用动态数组
可以将指向动态数组的指针当做数组名称使用，并使用下标访问数组元素，数组表示法访问数组元素
	int * p = new int [10];		p[0];		p[1];

		指针数组和指针算术
指针与数组基本等价的原因在于指针算数(pointer arithmetic)和C++内部处理数组的方式
将指针变量增加1，增加的量等于指针所指向类型的大小
C++将数组名解释为地址
使用数组和指针表示法时，C++都执行转换:
	arrayname[i] == *(arrayname + i);	pointername[i] == *(pointername + i);
指针与数组的区别:
	(1)可以修改指针的值，不可以修改数组名的值，数组名为常量
	(2)sizeof(数组)得到数组长度，sizeof(指针)得到指针长度，而不是其所指向的数据长度
指针:
	(1)声明指针:	int * p;
	(2)指针赋值:	p = &a;
	(3)解除指针引用:	*p;	p[0];指针表示法，数组表示法
	(4)区分指针和指针所指向的值:	p	*p;
	(5)数组名:C++将数组名视为数组第一个元素的地址
	(6)指针算数:指针加1，表示增加所指向的类型大小，可以讲两个指针相减，得到指针间隔数，整数
	(7)数组的静态联编和动态联编:数组声明为静态联编	//int arr[10];	new操作符创建数组，动态联编	int * p = new int [10]; 使用delete [] p;	释放空间
	(8)数组表示法和指针表示法:	arr[0];	p[0];	

		指针和字符串
在cout和多数C++表达式中，char数组名、指向char的指针以及引号括起的字符串常量都将被解释为字符串第一个字符的地址
cout中的字符串常量，只发送字符串的第一个字符的地址
编译器在内存中留出一些空间存储程序源代码中所有用引号括起的字符串
(1)C++中，字符串字面值都将被设置为常量
(2)有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值
(3)要在cout中显示字符串的地址，必须将字符串指针转换为另一种类型的指针
strcpy()复制字符串函数不检查目标数组容量，超出数组边界，覆盖后面的内存
strncpy()接收第三个参数，要赋值的最大字符数，到达目标结尾之前，目标数组已满，不会添加空字符;复制成功后，目标未满，会自动添加空字符
		new创建动态结构
new创建结构:(1)创建结构(2)访问其成员
.操作符用于结构实体		->操作符用于结构指针
	inflatable * ps = new inflatable;
	(*ps).price; ps->price;
	
	自动存储、静态存储、动态存储
1.自动存储:在函数内部定义的常规变量使用自动存储空间，称为自动变量，他们所属的函数被调用时自动产生，函数结束时，自动消亡
	自动变量为局部变量，作用域为它所属的代码块
	代码块中定义的自动变量，该变量仅在程序执行该代码块中的代码时存在
2.静态存储:整个程序执行期间都存在的存储方式，使变量称为静态变量:(1)使用static关键字(2)在函数外面定义变量
3.动态存储:使用new操作符创建的内存空间，使用delete操作符释放内存，他们管理一个内存池，C++中称为自由存储空间，这部分内存空间与自动存储和静态存储内存是分开的
	动态存储的数据的声明周期不完全受到程序或函数的生命周期控制
===========================指针和自由存储空间=================================
