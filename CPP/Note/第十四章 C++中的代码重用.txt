第十四章 C++中的代码重用

1.公有继承机制可以实现代码重用
2.(1)可以使用类成员是另一个类的对象实现
	这种方法称为包含(containment)、组合(composition)、层次化(layering)
  (2)使用私有或保护继承
3.包含、私有继承和保护继承用于实现has-a关系,新的类包含另一个类的对象
4.多重继承使用能够使用两个或更多的基类派生出新的类,将基类的功能组合在一起
5.类模板可重用代码:类模板使我们能够使用通用术语定义类,然后使用模板创建针对特定类型定义的特殊类

14.1 包含对象成员的类
1.类成员可以是常规类型(int、float、double、char *)的,也可以是另一个类对象
	eg:	使用C++标准库的String对象表示类的字符串属性、使用valarray表示动态分配内存的数组

14.1.1 valarray类简介
1.valarray类是由头文件valarray支持的
2.这个类用于处理数值或具有类似特性的类,它支持诸如将数组中所有元素的值相加、
	以及在数组中查找最大值和最小值等操作
3.valarray类被定义为模板类,以便能够处理不同的数据类型
4.模板特性意味着声明对象时,必须指定具体的数据类型
	eg:	声明valarray对象,在valarray后面加上尖括号并在其中指明数据类型
		valarray<int> q_values;//int array
		valarray<double> weights;//double array
5.valarray用法,使用valarray类对象,构造函数及其他类方法
	eg:	double gpa[5] = {3.1,3.5,3.8,2.9,3.3};
		valarray<double> v1;//double array size 0
		valarray<int> v2(8);//八个int元素的数组
		valarray<int> v3(10,8);//8个int元素的数组,每个元素都设置为值10
		valarray<double> v4(gpa,4);//4个元素的数组,初始化为gpa数组的前四个值
	可以创建长度为0的空数组、指定长度的空数组、所有元素都被指定值初始化的数组、
	以及用常规数组中的值进行初始化的数组
6.valarray类方法
	(1)operator[] :通过下标访问数组元素
	(2)size():	返回数组中包含元素的个数
	(3)sum():	返回所有元素的和
	(4)max():	返回最大的元素
	(5)min():	返回最小的元素
	
14.1.2 Student类的设计
1.可以通过公有继承姓名、分数类多重公有继承来派生学生类,学生类与分数、姓名类不是is-a模型,
	学生不是分数也不是考试成绩,学生与分数、姓名的关系是has-a关系
	学生有姓名和考试成绩
2.用于建立has-a关系的C++技术是组合(包含),即创建一个包含其他类的对象
	eg:	将Student类声明为
		class Student
		{
		private:
			string name;//string object
			valarray<double> scores;//valarray<double> object
			...
		};
	Student类可以通过string、valarray对象的公有接口访问及修改其数据
	Student类外只能通过其公有接口访问及修改其数据
	Student类获得了其成员对象的实现,但没有继承接口
3.接口和实现
	(1)公有继承类可以继承接口,可能还有实现(基类的纯虚函数提供接口,但不提供实现)
	(2)获得接口是is-a关系的组成部分,
	(3)使用组合,类可以获得实现,但不能获取接口
	(4)不继承接口是has-a关系的组成部分
4.has-a关系,类对象不自动获得被包含对象的接口,被包含对象的接口可能对当前类对象时没有意义的
	可以在当前类对象的成员函数内部使用被包含对象的成员函数

14.1.3 Student类范例
	(1).explicit用于构造函数关闭参数类型到类类型的转换,防止隐式转换
	(2).使用const防止方法修改数据
1.初始化被包含的对象
	(1)使用成员初始化列表初始化对象成员
	(2)使用成员初始化列表初始化派生类对象的基类部分
	(3)使用初始化列表初始化内置类型
	(4)初始化列表仅能用于构造函数
	(5)继承的对象,构造函数使用初始化列表通过类名调用特定的基类构造函数
		对于成员对象,构造函数则使用成员名
		eg:	Student(const char & str,const double * pd,int n):name(str),scores(pd,n){}
		因为构造函数初始化的是成员对象,而不是继承的对象,在初始化列表中使用成员名,而不是类名
	(6)C++要求在构建对象的其他部分之前,先构建继承对象的所有成员
		省略初始化列表,C++将使用成员对象类的默认构造函数
	(7)初始化列表的初始顺序:初始化列表初始化多个项目时,这些项目被初始化的顺序为它们被声明的顺序
		而不是它们在初始化列表中的顺序
		eg:	Student(const char * str,const double * pd,int n):scores(n),name(str){}
			name先声明则先初始化
	(8)如果类的一个成员使用另一个成员的值进行初始化,则初始化的顺序就很重要
2.使用被包含对象的接口
	(1)被包含对象的接口不是公有的,但可以在类方法中使用它
	(2)当前类可以使用当前类的公有方法,被包含类可以在当前类内部使用其所属类的方法
3.使用新的Student类

14.2 私有继承
	(1)另一种实现has-a关系的方式--私有继承
	(2)使用私有继承,基类的公有成员和保护成员将成为派生类的私有成员
		基类方法将不会成为派生类的公有接口的一部分,但可以在派生类成员中使用它们
	(3)公有继承,基类的公有方法将成为派生类的公有方法,is-a关系,派生类继承基类的接口
		私有继承,基类的公有方法将成为派生类的私有方法,has-a关系的一部分,派生类不继承基类的接口
	(4)包含将对象做为一个命名的成员对象添加到类中,私有继承将对象做为一个未被命名的继承对象添加到类中
	(5)使用术语子对象(subobject)来表示通过继承或包含添加的对象
	(6)私有继承提供的特性与包含相同,获得实现但不获得接口,私有继承也可以实现has-a关系
	(7)使用私有继承使用关键字private而不是public来定义类
		private是默认值,省略代表为私有继承
		eg:	class Studen:private std::string,private std::valarray<double>
			{
			public:
				...
			};
	(8)使用多个基类的继承称为多重继承(multiple inheritance,MI)
		公有MI将导致一些问题,必须使用额外的句法规则来解决它们
	(9)包含与私有继承的区别[1]
		包含需提供显式命名的对象成员
		私有继承提供无名称的子对象成员
1.初始化基类组件
	(1)构造函数使用成员初始化列表句法,它使用继承类的构造函数而不是类成员
		eg:	typdef std::valarray<double> ArrayDb;
			做为成员对象的初始化方法
			Student(const char * str,double * pd,int n):name(str),scores(pd,n){...}
			做为继承类的初始化方法
			Student(const char * str,double * pd,int n):std::string(str),ArrayDb(pd,n){...}
		这是包含和私有继承的第二个区别[2]
2.访问基类的方法
	(1)使用私有继承时,只能在派生类的方法中使用基类的方法
	(2)使用包含时,使用对象名来调用方法,
		使用私有继承时,使用类名及作用域解析操作符来调用基类方法
		eg:	[1]包含的调用方法
				typdef std::valarray<double> ArrayDb;
				string name;
				ArrayDb scores;
				调用
				name.size();
				scores.sum() / scores.size();
			[2]私有继承的调用方法
				typdef std::valarray<double> ArrayDb;
				if(ArrayDb::size() > 0)
				{
					return ArrayDb::sum() / ArrayDb.size();
				}
				else
				{
					return 0;
				}
3.访问基类对象
	(1)使用作用域解析操作符可以访问基类方法
		使用基类本身的对象,可以使用强制类型转换,将派生类转换为基类
	(2)指针this为调用方法的对象
		eg:	const std::string & Name()const
			{
				return (const std::string &)*this;
			}
4.访问基类的友元函数
	(1)友元不属于类,不能使用类名限定访问
		可以显式地转换为基类来调用正确的函数
		eg:	ostream & operator<< (ostream & os,const Student & stu)
			{
				os << "Scores for " << (const string &)stu << endl;
			}
	(2)私有继承中,不进行显式强制类型转换时,不能将指向派生类的引用或指针赋给基类引用或指针
		公有继承也需要将stu进行显式强制转换,否则与当前类友元匹配形成递归调用
		os << stu;
	(3)多重继承时,编译器无法确定转换为哪一个基类,如果多个基类都提供了相同的函数
5.使用修改后的Student类
6.使用包含还是私有继承
	(1)既可以使用包含,也可以使用私有继承来建立has-a关系
	(2)包含易于理解,类声明中包含表示被包含类的显式命名对象,代码可通过名称来引用这些对象
		继承使得关系更抽象,且会引起问题,从多个基类继承时,包含同名方法的独立基类、共享祖先的独立基类
		包含可以包含多个同类的子对象,继承只能使用一个这样的对象,且对象没有名称
	(3)私有继承提供的特性比包含多,类的保护成员在派生类中是可用的,在继承结构外是不可用的
		如果使用包含将这样的类包含在另一个类中,后者将不是派生类,位于继承层次外,不能访问保护成员
		通过继承得到的是派生类,它能够访问基类的保护成员
	(4)需要重新定义虚函数的情况下,需要使用私有继承
		派生类可以重新定义虚函数,包含类不能
		使用私有继承,重新定义的函数将只能在类中使用,而不是公有的
	(5)通常,应使用包含建立has-a关系
		如果新类需要访问原有类的保护成员,或需要重新定义虚函数,则应使用私有继承
7.保护继承
	(1)保护继承是私有继承的变体
		在列出基类时使用protected关键字
		eg:	class Student:protected std::valarray<double>,protected std::string
			{
			};
	(2)使用保护继承时,基类的公有成员和保护成员都将成为派生类的保护成员
	(3)和私有继承相似,基类的接口在派生类中可用,在继承结构外是不可用的
	(4)从派生类派生出的类,私有继承和保护继承的区别:
		[1]私有继承时,第三代类将不能使用基类的接口,因为基类的公有方法在派生类中将变为私有的
		[2]使用保护继承时,基类的公有方法在派生类中将变为受保护的,第三代派生类中可以使用它们
	(5)不同种类的继承
		特征				公有继承				保护继承				私有继承
		公有成员变成		派生类的公有成员		派生类的保护成员		派生类的私有成员
		保护成员变成		派生类的保护成员		派生类的保护成员		派生类的私有成员
		私有成员变成		只能通过基类接口访问	只能通过基类接口访问	只能通过基类接口访问	
		能否隐式向上转换	是						是(只能在派生类中)						否
8.使用using重新定义访问权限
	(1)使用保护派生或私有派生时,基类的公有成员将成为保护成员或私有成员
		在派生类外使用基类访问,通过定义使用基类方法的派生类公有方法
		eg:	double Student::sum()const
			{
				return ArrayDb::sum():
			}
	(2)在派生类的公有部分使用using声明来指出可以使用的基类成员,该方法在私有派生情况下也可行
		eg:	class Studen:private std::string,std::valarray<double>
			{
			public:
				using std::valarray<double>::min;
				using std::valarray<double>::max;
			};
			ada // array of Student
			cout << ada[i].max() << endl;
			上述声明使得valarray的min、max方法可用,将像类的公有方法
			注意:using声明只使用成员名----没有圆括号、函数特征标、返回类型
		eg: using std::valarray<double>::operator[];
			using声明仅适用于继承,不适用于包含
	(3)老式方法使私有继承的基类的方法可用
		在派生类的公有部分重新声明基类的方法,将方法名放在派生类的公有部分
		eg:	class Studen:private std::string,std::valarray<double>
			{
			public:
				std::valarray<double>::operator[];//只使用名称声明
			};
			注意:该方法即将摒弃

14.3 多重继承
1.MI描述的是有多个直接基类的类,与单继承一样,公有MI表示is-a关系
	eg:	class SingingWaiter:public Waiter,public Singer
		{
		...
		};
2.必须使用关键字public限定每一个基类,否则编译器将默认视为private私有派生
	eg:	class SingingWaiter:public Waiter,Singer//Singer is private base
		{
		...
		};
3.私有MI和保护MI表示has-a关系
4.MI可能遇到的问题:
	(1)从两个不同基类继承同名方法
	(2)从两个或更多相关基类继承同一个类的多个实例

14.3.1 有多少Worker
	(1)从Waiter和Singer派生出SingingWaiter派生类
		Waiter和Singer均公有派生自Worker
		class SingingWaiter:public Waiter,public Singer{...};
		SingingWaiter将包含两个Worker组件
	(2)这种情况下将基类指针指向派生类将产生二义性
		eg:	SingingWaiter ed;
			Worker * pw = &ed;//ed中的基类结构中的Singer和Waiter各包含一个Woker组件,产生二义性
			这种赋值将把基类指针设置为派生类对象中的基类对象的地址
			ed中包含两个Worker对象,有两个地址可供选择,应使用类型转换来指定对象
			Worker * pw1 = (Waiter *)&ed;
			Worker * pw2 = (Singer *)&ed;
			这将使得使用基类指针来引用不同的对象(多态性)复杂化
	(3)使用虚基类解决派生对象中的相同基类组件冲突
			
			
			