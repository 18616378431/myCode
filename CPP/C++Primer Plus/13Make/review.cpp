//13 复习题
//1.
//基类的公有成员称为派生类公有成员
//基类的保护成员称为派生类的保护成员
//基类的私有成员被继承,但不能直接访问

//2.
//不能继承构造函数、析构函数、赋值操作符、友元

//3.
//如果返回类型位void,则不能进行链式赋值,可单个赋值
//方法返回对象而不是引用,该方法的执行速度将减慢,
//返回时需要调用相应对象的复制构造函数复制对象

//4.
//派生类的构造函数通过初始化列表先调用基类的构造函数,然后执行派生类的构造函数进行初始化
//按派生顺序进行调用构造函数,最早的基类的构造函数最先被调用
//析构函数按相反方向进行调用,先析构派生类后析构基类

//5.
//需要,每个类都需要有自己的构造函数,如果没有新数据成员,构造函数可以为空,但必须存在

//6.
//调用派生类方法,它取代基类的定义
//仅当派生类没有重新定义基类方法或使用作用域解析操作符时,才会调用基类方法
//应当把所有需要重新定义的成员函数声明为虚函数

//7.
//当派生类使用new或new []初始化类指针成员时,应显式定义赋值操作符

//8.
//可以将派生类对象的地址赋给基类,因为基类指针或引用可以指向派生类,向上强制转换
//只有通过显式强制转换才可以将基类指针或引用赋给派生类,向下强制转换

//9.
//可以将派生类对象赋给基类对象,派生类中新增的数据成员不会传递给基类
//程序将使用基类的赋值操作符
//基类对象赋给派生类,仅当派生类定义了转换操作符(将基类引用做为唯一参数的构造函数)
//或使用基类为参数的赋值操作符时,基类对象才可以赋给派生类对象

//10.
//基类引用或指针可以指向派生类

//11.
//按值传递对象将调用复制构造函数
//由于形参是基类对象,将调用基类的复制构造函数,复制构造函数以基类引用为参数,
//该引用可以指向做为参数传递的派生类对象
//结果是生成一个新的基类对象,其成员对应于派生类对象的基类部分

//12.
//按引用传递可以确保函数从虚函数受益,使函数内的对象方法调用根据其指向类型而调用
//按引用传递对象可以节省内存和时间(对于大型对象)
//按值传递可以保护原始对象数据,可以将按引用传递对象设置为const引用

//13.
//ph->head();
//a.常规非虚方法:将调用基类方法
//b.虚方法:将调用派生类方法
//虚函数:根据指针或引用指向的类型决定调用哪个方法

//14.
//(1)这种情况不适合is-a模型,公有继承不适用
//(2)派生类的方法定义隐藏了基类的方法定义,两个方法的特征标不同
//(3)派生类使用了基类私有数据
//(4)派生类私有成员未进行初始化
//(5)派生类构造函数未调用基类构造函数初始化基类部分