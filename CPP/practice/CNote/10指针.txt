指针		const
1.使用const可以创建数组常量、指针常量以及指向常量的指针.
2.可以将普通数组或只读数组元素的地址赋给指向常量的指针.
3.只有普通数组元素的地址可以赋给普通指针.只读数组元素地址不可以赋给普通指针
int ar[4][2] = {{1,2},{3,4},{5,6},{7,8}};//普通数组
const int arar[4][2] = {{1,2},{3,4},{5,6},{7,8}};//只读数组，不可修改数组元素数值
int * p;//普通指针
const int *p1;	//常量指针
4.可以用const来声明和初始化指针，以使指针不会指向别处，但是可以修改指针所指向地址内存储的数据的数值
const double * p;
5.可以使用两个const来创建指针，以使这个指针既不可以更改所指向的地址，也不可以修改所指向的数据.
const double * const p;

====================================================
指向多维数组的指针
int zippo[4][2] = {{2,4},{6,8},{1,3},{5,7}};
zippo[m][n] = *(*(zippo + m) + n);
pz[m][n] = *(*(pz + m) + n);

====================================================
指针的兼容性
1.不同类型的指针不可以互相赋值
int * p;
double * p1;
(EX:
int * pt;
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2;		//指向指针的指针
________________________
pt = &ar1[0][0];		//指向int
pt = ar1[0];			//指向int
pt = ar1;			//非法
pa = ar1;			//指向int
pa = ar2;			//非法
p2 = &pt;			//指向int
*p2 = ar2[0];			//指向int
p2 = ar2;			//非法
)
2.把const指针赋给非const指针是非法的
int  * p1;
const int * p2;
const int ** pp2;
p1 = p2;		//非法，将常量指针赋给普通指针
p2 = p1;		//合法,将普通指针赋给常量指针
pp2 = &p1;		//非法，将普通指针赋给const指针

=========================================================
函数和多维数组
将多数数组传递给函数:

int junk[3][4] = {{2,4,5,8},{3,5,6,9},{12,10,8,6}};
数组中接受传递数组的定义方式:
(1)void somefunction(int (* pt)[4]);
(2)void somefunction(in pt[][4]);

EX:函数原型语法，三种方法等价
调用函数:sum_rows(junk,ROWS);
(1)void sum_rows(int ar[][COLS],int rows);
(2)void sum_cols(int [][COLS],int);
(3)int sum2d(int (*ar)[COLS],int rows);
注：
声明N维数组指针时，除最左边外的方括号可以留空，其他都需要填写数值，首方括号表示这是一个指针，其他方括号描述的是所指对象的数据类型
EX:
int sum_cols(int ar[][2][3][4][5],int rows);
int sum_cols(int (*ar)[2][3][4],int rows);		//ar是一个指针，ar指向							//一个2 X 3 X 4的int数组
