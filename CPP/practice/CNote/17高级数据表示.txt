17高级数据表示

用C表示多种数据类型
抽象数据类型(Abstract data type,ADT)
进一步学习malloc()函数

C实现通常将int类型和指针类型都存储为整数
算法(alogorithm)
队列、列表、二叉搜索树
OOP(面向对象)

/*********************************************研究数据表示*********************************************/
在黑白屏时代，可以使用计算机中的1位(0或1)表示一个像素(开或关)，因而称为位图(bitmapped)
彩色显示需要不止一位
每像素用8位，可以表示256种颜色
每像素用16位，可以表示65535中颜色
每像素用24位，可以表示16 777 216色
每像素用32位，可以表示2 147 483648色
数据压缩:
	有损的(lossless)
	无损的(lossy)
/*********************************************研究数据表示*********************************************/

/*********************************************从数组到链表*********************************************/
结构本身不能含有同类结构，但是可以含有指向同类结构的指针，这样的定义是定义一个链表的基础
链表是一个列表，其中每一项都包含如何找到下一项的地址
程序将当前结构的指向下一个项的指针设置为NULL
为了记录第一个结构的存储位置，需要一个头指针(head pointer)
由指针指向数据项链表中的第一项
head、current、prev:创建链表的基本指针
【显示列表】
	current = head;
	使用指针符号(->)访问结构成员
	重复整个过程，直到current被设为空
【创建列表】
	1.使用malloc()函数为一个结构分配足够的空间
	2.存储这个结构的地址
	3.把正确的信息复制到这个结构
		current = (FILM *)malloc(sizeof(FILM));
		if(head == NULL)
			head = current;
		else
			prev->next = current;
		current->next = NULL;
		为结构的成员赋值
【清理列表】
	//FILM * nt = (FILM *)malloc(sizeof(FILM));
	current = head;
	while(current != NULL)
	{
		nt->next = current->next;
		free(current);
		current = nt->next;
	}
/*********************************************从数组到链表*********************************************/

/*****************************抽象数据类型ADT********************************/
抽象数据类型(abstract data type)
一个类型指定两类信息:一个属性集和一个操作集
	EX:int类型的属性是它表示一个整数值，因此它拥有整数的属性，可以进行加、减、乘、除、取模运算
定义一个新的数据类型:首先提供存储数据的方式，然后提供操作数据的方式
定义新的类型的方法:
	1.为类型的属性和可对类型执行的操作提供一个抽象的描述，这个描述不应受任何实现及编译语言的约束
		这样一种正式的抽象描述被称为抽象数据类型(ADT)
	2.开发一个实现该ADT的编程接口，说明如何存储数据，并描述用于执行所需操作的函数集合
	3.编写代码来实现这个接口

【变得抽象】
列表(list):可以向列表末尾添加新的项目，并且能显示列表内容
非正式但抽象的列表定义:列表是一个能保存项目序列并且可以对其应用任何列表操作中列出的操作的对象
列表操作:
	1.把列表初始化为空列表
	2.向列表末尾添加一个项目
	3.确定列表是否为空
	4.确定列表是否已满
	5.确定列表中有多少个项目
	6.访问列表中的每一个项目，以执行相应任务
	7.在列表的任何一个位置插入项目
	8.在列表中删除一个项目
	9.取出列表的一个项目(不改变列表)
	10.替换列表中的一个项目
	11.在列表中搜索一个项目
列表类型:
	类型名称				简单列表
	
	类型属性:				可保存一个项目序列
	类型操作:				把列表初始化为空列表
						确定列表是否为空
						确定列表是否已满
						确定列表中的项目个数
						向列表末尾添加项目
						遍历列表，处理列表中的每个项
						清空列表

【构造接口】
简单列表的接口有两部分:一、描述数据如何表示，二、描述实现ADT操作的函数
在列表实现中，每一个链接被称为一个节点(node)，每一个节点包含形成列表内容的信息和指向下一个节点的指针
	#define TSIZE 45
	struct film{
		char title[TSIZE];
		int rating;
	}:
	typedef struct film Item

	typedef struct node{
		Item item;
		struct node * next;
	}Node;
定义List类型
	(1)	typedef Node * List;
		List movies;
	(2)	typedef struct list{
		Node * head;//列表头指针
		int size;//列表项目数
	}List;
【数据实现】(1)movies = NULL;(2)movies.next = NULL;movies.size = 0;
【数据隐藏】只需要直到该接口操作的作用，不需要直到具体的实现细节，叫做数据隐藏
数据隐藏是一种对更高级编程隐藏数据表示细节的艺术
提供操作列表的函数原型注意三点:
	1.操作:
	2.操作前:
	3.操作后:
函数使用指向列表的指针作为参数

列表的大小可受内存数量的限制,判断列表是否已满可以为一个新的项目分配空间
	分配成功，则未满，释放分配的空间以供项目使用，否则列表已满
/*****************************抽象数据类型ADT********************************/

/*****************************队列ADT********************************/
用抽象数据类型方法进行C语言编程:
	1.以抽象通用的方式描述一个类型，包括操作
	2.设计一个函数接口表示这种新类型
	3.编写具体代码以实现这个接口
【定义队列抽象数据类型】
队列(queue)是具有两个特护属性的列表:
	1.新的项目只能添加到列表尾处
	2.项目只能从列表开始处被移除
队列是一种"先进先出"的数据形式，类似于买电影票，队尾排队，队首离队
队列类型:
	类型名称				队列
	类型属性:				可保存一个规则的项目序列
	类型操作:				把队列初始化为空队列
						确定队列是否为空
						确定队列是否已满
						确定队列中的项目数量
						向队尾添加项目
						从队列首端删除和恢复项目
						清空队列
【定义接口】
初始化队列:InitializeQueue(Queue * pq);
是否为空:BOOL QueueIsEmpty(const Queue * pq);
是否已满:BOOL QueueIsFull(const Queue * pq);
项目数量:unsigned int QueueItemCount(const Queue * pq);
添加项目:BOOL EnQueue(Item item,Queue * pq);
删除项目:BOOL DeQueue(Item item,Queue * pq);//Item DeQueue(Queue q);
清空队列:void EmptyQueue(Queue * pq);
【实现接口的数据表示】
向队列添加项目:
	1.创建新的节点
	2.把项目复制到新节点
	3.设置新节点的next值为NULL，表明该节点是列表中最后一个节点
	4.设置当前尾节点next指向指针指向新节点，从而将新节点链接到队列中
	5.将尾节点指针end设置为指向新节点，以便找到最后的节点
	6.项目个数加一
从队列首端删除项目:
	1.把项目复制到一个给定的变量中
	2.释放空闲节点使用的内存
	3.重置首指针，使其指向队列中的下一项
	4.如果最后一项被删除，首尾指针均设为空
	5.项目减一
/*****************************队列ADT********************************/

/*****************************链表与数组********************************/
【比较数字和链表】
	数据形式			优点					缺点
	数组				C对其直接支持		编译时决定大小
					提供随机访问			插入和删除元素很费时

	链表				运行时决定大小		不能随机访问
					快速插入和删除元素	用户必须提供编程支持
数组和链表插入和删除元素的过程:
	向【数组】中插入一个元素，必须移动其他元素以便安插新元素，
	新元素离数组头越近，要移动的元素越多
	从数组中删除元素要重新安置大量元素
	向【链表】中插入一个节点，只需分配两个指针，
	从链表中删除一个节点只需重新设置一个指针并释放删除节点使用的内存
访问列表中的成员:
	对数组来说，可以用数组索引直接访问任意元素，这被称为随机访问(random access)
	对链表来说，必须从列表头部开始，逐步移动到所需节点处，这叫做顺序访问(sequential access)
	
在列表中搜索项目，一种算法是从列表头开始顺序搜索列表，这被称为顺序搜索(sequentoal access)
可以对列表进行排序，然后搜索，如果找到排在目标项目后的项目时，还没找到目标项目，终止搜索
对于一个排序的列表使用【折半搜索】(binary search)比顺序搜索更好，折半搜索工作原理:
	要搜索的项目称为目标项目
	列表已经按字母排序，把列表的中间相与目标项相比，
	如果两者相等，搜索结束，
	如果该中间项比目标项靠前，目标项若在列表中，一定在后一半
	如果该中间项比目标相靠后，目标项若在列表中，一定在前一半
	以此类推，继续搜索，直到找到目标项为止
n次比较可以处理2^n - 1个成员的数组
数组随机访问特性，可以使你能从一个位置直接跳到另一个位置，不需要访问两者之间的每一位
链表只支持顺序访问，不能直接跳到链表中点，在链表中不能使用折半搜索(binary search)
【选择数据类型，链表还是数组】
	选择链表较好:如果列表需要频繁的插入和删除元素，因而不断调整大小，并且不需要经常搜索，选择链表
	选择数组较好:如果列表基本稳定只是偶尔插入或删除一些元素，但是需要经常搜索，选择数组
/*****************************链表与数组********************************/

/*****************************二叉搜索树********************************/
二叉搜索树(binary search tree)是一种结合了折半搜索策略的链接结构
数中的每一个节点都包含一个项目和两个指向其他节点(子节点,child node)的指针
构思:每一个节点都有两个子节点
规定:在左节点中的项目是父节点中项目的前序项，在右节点中的项目是父节点中项目的后序项
所有能循其祖先回溯到左节点的项目都是该左节点的父节点项目的前序项，所有以右节点为祖先的项目的都是该右节点的父节点项目的后序项
每一层的节点数都是上一层的二倍
二叉搜索树中每一个节点是其后代节点的根，此节点与其后代节点构成一个子树(subtree)
/*****************************二叉搜索树********************************/

/*****************************二叉树ADT********************************/
【二叉树类型总结】
	类型名称					二叉搜索树
	类型属性:					二叉树或一个空节点集合(空树)，或指定某一节点为根的节点集合
							每个节点有两个作为其后代的树，左子树和右子树
							每一个子树本身又是一个二叉树，
							它的每一个节点包含一个项目，
							它的所有左子树项目排在根项目的前面，
							它的搜索右子树项目排在根项目的后面
	类型操作:					1.把树初始化为空树
							2.确定树是否为空
							3.确定树是否已满
							4.确定树中项目的数量
							5.向树中添加一个项目
							6.从树中删除一个项目
							7.在树中搜索一个项目
							8.访问树中的每一个项目
							9.清空树
实现二叉搜索树最直接的方法是用指针动态链接分配的节点
/*****************************二叉树ADT********************************/















