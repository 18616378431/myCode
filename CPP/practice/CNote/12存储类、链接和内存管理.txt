本章内容
关键字:auto,extern,static,register,const,volatile,restricted
函数:rand(),srand(),time(),malloc(),calloc(),free()
C中变量的作用域和生存周期

/***********************************作用域******************************/
存储时期(storage duration):变量在内存中存储的时间
作用域(scope)和连接(linkage):表明程序的哪些部分可以通过变量名使用该变量
作用域描述了程序中可以访问一个标示符的一个或多个区域
	代码块作用域(block scope):只在定义该变量的代码块内可见，包括函数的形参,C99在for、while、do while中定义的变量均具有代码块作用域
	函数原型作用域:适用于函数原型使用的变量名,从变量定义处到原型声明末尾;函数声明中变量名无意义，主要是类型，但是在声明函数含参变长数组中有意义
	文件作用域(file scope):在所有函数之外定义的变量具有文件作用域,整个文件可见,也叫全局变量(global variable)
	函数作用域(function scope):只适用于goto语句使用的标签，在整个函数中可见，无论哪个代码块
/***********************************作用域******************************/

/***********************************链接******************************/
C变量具有:
代码块作用域和函数原型作用域
	空链接(no linkage):变量有空链接，由代码块或函数原型所私有
文件作用域:
	外部链接(external linkage):在多文件程序的任何地方使用,全局变量具有外部链接
	内部链接(internal linkage):在一个文件内的任何地方使用,使用了static存储类说明符的变量为内部变量
/***********************************链接******************************/

/***********************************存储时期******************************/
1.静态存储时期:程序执行期间一直存在，具有文件作用域的变量具有静态存储时期
2.自动存储时期:具有代码块作用域的变量具有自动存储时期,程序进入定义变量的代码块，为变量分配内存，退出代码块后，分配的内存将被释放;将自动变量使用的内存视为可以重复使用的工作区域或暂存内存
注:	static表明链接类型，并非存储时期;
	所有的文件作用域变量都具有静态存储时期,无论它具有内部链接还是外部链接

/***********************************存储时期******************************/

C使用作用域、链接和存储时期定义5种存储类:
自动、寄存器、具有代码块作用域的静态、具有外部链接的静态、具有内部链接的静态

存储类				时期		作用域	链接		声明方式
自动					自动		代码块	空		代码块内
寄存器				自动		代码块	空		代码块内，使用register关键字
具有外部链接的静态	静态		文件		外部		所有函数之外
具有内部链接的静态	静态	 	文件		内部		所有函数之外，使用static关键字
空连接的静态			静态	 	代码块	空		代码块内，使用static关键字

/**************************自动变量*******************************/
使用自动存储类的变量具有自动存储时期，代码块作用域和空链接
在代码块和函数头部定义的变量都属于自动存储类或使用auto关键字,auto int i;
auto:存储类说明符(storage class specifiler)
内层代码块定义了一个和外层代码块一样的名字的变量，内层代码块中定义的名字是内层代码使用的变量，所在内存位置不同，不是同一个，内层定义覆盖了外部定义，程序运行离开内层代码块后，外部变量重新恢复作用

自动变量的初始化:
				int repid;
				int tents = 5;
tents初始化为5，repid初始值为分配给它的存储空间内先前存储的任意值
/**************************自动变量*******************************/

/**************************寄存器变量********************************/
寄存器变量与自动存储变量相同，具有自动存储时期，代码块作用域，空连接;
通过存储类说明符register声明寄存器变量,无法获得寄存器变量的地址
声明寄存器变量:register int quick;
可以把形式参量请求为寄存器变量：void macho(register int n)
声明为寄存器变量只是一个请求而非命令，编译器要在请求与可用高速内存数量或寄存器数量之间做权衡，请求失败，变量变为普通的自动变量
可以使用register声明的类型是有限的，处理器可能没有足够大的寄存器来存储double类型
/**************************寄存器变量********************************/

/**************************具有代码块作用域的静态变量(空链接静态存储类)**********/
静态变量(static variable)
代码块作用域、静态存储时期、空连接、代码块内static声明
不显示地对静态变量初始化，默认初始化为0
函数参量不可使用static
静态变量和外部变量在程序调入内存中时就已经就位了，并且一直存在
/**************************具有代码块作用域的静态变量**********/

/**************************具有外部链接的静态变量(外部存储类)***********************************/
外部存储类(external storage class)
这类型的变量称为外部变量(external variable)
静态存储时期、文件作用域、外部链接，在所有函数外定义

外部变量初始化
外部变量可以显示地初始化,未显式初始化的外部变量默认初始化为0,同样适用于外部数组
只可以用常量表达式初始化文件作用域变量

C99标准要求编译器识别局部标识符前63个字符和外部标识符前31个字符
过去的要求:编译器识别局部标识符前31个字符和外部标识符前6个字符

int tern = 1;//定义声明(defining declaration)
int main()
{
	extern int tern;//引用声明(referencing declaration),使用在其他地方定义的tern,可能不在同一个文件中
}
外部变量只可以进行一次初始化
/**************************具有外部链接的静态变量***********************************/

/**************************具有内部链接的静态变量***********************************/
静态存储时期、文件作用域、内部链接，static关键字声明在所有函数之外
只可以被同一文件中的函数使用
int traveler = 1;//外部链接
static int try = 1;//内部链接.....int main()......
/**************************具有内部链接的静态变量***********************************/

/**************************多文件***********************************************/
一个文件中定义声明 外部变量,其他文件中通过extern关键字来使用
/**************************多文件***********************************************/

/**************************存储类说明符***************************************/
不可以在一个声明中使用多个存储类说明符
auto:自动存储时期、用于具有代码块作用域的变量声明
register:用于具有代码块作用域的变量声明,请求将该变量存储在寄存器内，以便更快的存取，不可获得变量地址
static:
	用于具有代码块作用域的变量声明时，该变量具有静态存储时期，程序运行期间存在并保留其值;变量具有代码块作用域和空链接
	用于文件作用域的变量声明时，该变量有内部链接
extern:声明在别处已经定义的具有外部链接或内部链接的变量
typedef:与内存存储无关
/**************************存储类说明符***************************************/

/**************************随机函数和静态变量**************************/
stdlib.h提供srand()和rand()
rand()产生的随机数是0~RAND_MAX范围内的整数,RAND_MAX在stdlib.h中定义,通常为INT_MAX
static unsigned long int next = 1;//种子
int rand1(void){next = next * 1103515245 + 12345;return (unsigned int)(next/65536)%32768;}
void srand1(unsigned int seed){next = seed;}
time.h包含time()原型，返回系统当前时间(数值类型),参数为time_t 类型对象，可以传送空指针(0)
根据系统时间提供种子数值#include<time.h> srand1((unsigned int)time(NULL));
/**************************随机函数和静态变量**************************/

/**************************分配内存:malloc()和free()包含于stdlib.h*********************/
程序运行时分配更多的内存,找不到所需空间返回空指针
malloc()
指向char的指针类型\指向void的指针(通用指针)\返回数组指针\返回结构指针
接收一个参数，所需字节数
为请求分配内存，但没有名字，返回那块内存的第一个字节的地址
可以讲返回的地址赋给一个指针来访问那块内存
malloc()创建数组，程序运行时malloc请求一个存储块，一个指针来存储该内存块在内存中的位置
double * ptd;//指向内存块首地址
ptd = (double *)malloc(30 * sizeof(double));//请求30个double值的空间，ptd指向该位置
创建数组的三种方法:
	(1)声明一个数组，用常量表达式指定数组维数,用数组名访问数组元素
	(2)声明一个变长数组，用变量表达式指定数组维数，用数组名访问数组元素
	(3)声明一个指针，调用malloc()，使用该指针访问数组元素

free()
释放先前malloc()分配的内存，接收malloc()返回的地址(即申请的空间的首地址)
分配的内存数量只会增加，只能使用free()释放

exit()
用于在内存分配失败时结束程序,值EXIT_FAILURE(程序异常终止),EXIT_SUCCESS(程序正常终止)(等同于0)

只分配内存，不进行释放将导致程序内存溢出，这类问题被成为内存泄露(memory leak),在函数末尾调用free()
/**************************分配内存:malloc()和free()*********************/

/*************************内存分配calloc()**************************************************/
与malloc()用法相似,接受两个无符号整型参数:(1)所需内存单元的数量(2)每个单元以字节计的大小
返回void指针,存储不同的类型要使用类型指派符
calloc()将内存块中的全部位都置为0
用free()来释放calloc()分配的内存
double * temp;temp = (double *)calloc(100,sizeof(double));
/*************************内存分配calloc()**************************************************/

/*************************动态内存分配与变长数组********************************************/
变长数组(Variable Length Array):自动存储，代码块执行完毕后释放相应内存
malloc()定义二维数组，必须固定一维大小;
int *p[6];p = (int (*)[6])malloc(n * 6 * sizeof(int));//nx6二维数组
/*************************动态内存分配与变长数组********************************************/

/*************************存储类与动态内存分配**************************/
(1)具有外部链接的、具有内部链接的、具有空链接的静态变量
	在程序编译时就已经知道静态存储时期存储类的变量所需的内存数量
	存储在这一部分的数据在程序运行期间一直存在
(2)自动变量
	程序运行进入包含该变量定义代码块时产生，退出这一代码块时终止
	可视为一个堆栈，新变量按顺序加入，按相反顺序移除
(3)动态分配内存的
	在调用malloc(n * sizeof(int))或calloc(n,sizeof(int))时产生，在调用free()时释放
	内存块可以再一个函数中创建，在另一个函数中释放
	内存分布碎片状，活动的内存块之间散布着未使用的字节片
	动态内存往往导致进程比使用堆栈内存慢
/*************************存储类与动态内存分配**************************/

/*************************ANSIC类型限定词********************************/
变量由类型和存储类表征
C90:不变性、易变性(const、volatile)，创建了受限类型(qualified type)
C99:restrict;
限定词是幂等的，一个声明中不止一次的使用限定词，多余的将被忽略
const const const int n = 6;//等同于const int n = 6;
typedef const int zip;
const  zip q = 8;

CONST
带有const声明的变量不可赋值、增量、减量修改变量的值，可以初始化一个const声明变量
(一)在指针和参量声明中使用const
区分:指针本身成为const或者指针指向的值成为const
const float * pf;//指向常量浮点值		等效声明:float const * pf;
//pf指向的值是不可改变的，但是pf本身的值是可以改变的
float * const pf;//pf是一个常量指针
//pf的值不可以改变，但是pf指向的值是可以改变的
const float * const pf;//pf所指向的位置不可以改变，pf所指向位置存储的值也不可以改变
注:*左边的const时指向的数据成为常量，*右边的const使指针成为常量
(二)对全局数据使用const
文件中定义全局常量，其他文件中用extern关键字引用声明
在头文件中定义，需使用static定义静态外部存储类，每个包含该头文件的都有一份定义的拷贝

VOLATILE
告诉编译器该变量除了可被程序改变外还可以被其他代理改变
用于硬件地址和与他并行运行的程序共享数据
(1)一个地址中保存当前系统的时间，无论程序做什么，该地址的值都会随时间改变
(2)一个地址用来接收来自其他计算机的消息
volatile int v1 = x;//v1为volatile值
volatile int * p;//p指向volatile值
将多次使用的变量存储在寄存器中，并且在使用该变量时直接从寄存器中读取,这个过程称为缓存(caching)
const和volatile可以并用
硬件时钟的值不可以被程序改变const
但是可以被程序以外的硬件改变volatile
volatile const int v1;
const volatile int *p;

RESTRICT
通过允许编译器优化某几种代码增强了计算支持
只可用于指针，并标明指针时访问数据对象的唯一且初始的方式
可以作为指针型函数参量的限定词,意味着函数体内没有其他标识符修改指针指向的数据
C99:把字节从一个位置复制到另一个位置
void memcpy(void * restrict s1,const void * restrict s2,size_t n);//访问标识唯一，不重叠
void memmove(void * s1,const void * s2,size_t n);//访问不唯一，可能重叠
/*************************ANSIC类型限定词********************************/








