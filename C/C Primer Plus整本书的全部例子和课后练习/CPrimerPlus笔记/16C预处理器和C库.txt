16C预处理器和C库

预处理指令:#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma
函数:sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_cpy()
类函数宏、条件编译
内联函数

/********************翻译程序****************************/
对程序进行翻译之前，编译器首先把源代码中出现的字符映射到元字符集，
该过程处理多字节字符和C三元字符扩展

宏定义中，反斜杠用来将当前行扩展到下一行，
编译器查找反斜线后紧跟换行符的实例并删除这些实例，
两个物理行转换为一个逻辑行(logical line)

编译器将文本划分成预处理的语言符号(token)序列和空白字符及注释序列

编译器用一个空格字符代表每一个注释
/********************翻译程序****************************/

/********************明显常量#define****************************/
指令的作用域是定义出现的位置到文件末尾
预处理指令从#开始，换行结束，长度限于一行
每个逻辑(#define)行的组成:	第一部分:指令自身
						第二部分:缩略语，即宏(macro),代表值的称为类对象宏(object-like macro)
						第三部分:称为替换列表(replacement list)或主体(body)
从宏变成最终的替换文本的过程称为宏展开(macro expansion)
C编译器在编译时对所有的常量表达式求值,实际的相乘发生在编译阶段
预处理器不进行计算，只按照指令进行文字替换工作
宏定义中可以嵌套其他宏
	EX:#define 'z'//字符常量
	     #define "z"//字符串常量,即z\0
宏定义的主体为字符串时，其中的空格也作为主体的一部分

符号常量优点:	1.记忆值的能力
			2.易更改性
			3.可移植性
const关键字可以创建:全局变量，局部变量，数字常量，数组常量，结构常量
宏常量可以作为指定标准数组大小并作为const值的初始化值
/********************明显常量#define****************************/

/********************语言符号****************************/
系统把宏主体看做语言符号(token)类型字符串，不是字符型字符串
EX:	#define 2*3//一个语言符号
	#deifne 2 * 3//三个语言符号2、*、3
用字符型字符串观点看，空格也是主体的一部分
用语言符号类型观点看，空格只是分隔主体中语言符号的符号
【重定义常量】
	EX:#define LIMIT 20		#define LIMIT 25//重定义
这个过程称为重定义常量(redefining a constant)
ANSI C只允许新定义与旧定义完全相同，即主体具有相同顺序的语言符号
	EX:#define SIX 2*3			#deine SIZ 2 * 3//重定义，相同
/********************语言符号****************************/

/*********************#define中使用参数*************************************/
可以创建外形和作用与函数类似的类函数宏(function-like macro)
	EX:	#define SQUARE(X) X*X		#define PR(X) printf("x is %d.\n",X)
		main:int i = SQUARE(3);
预处理器不进行计算，只是进行字符串替换	EX:SQUARE(2 + 4) = 14;//2 + 4 * 2 + 4
函数调用把参数的值传递给函数，编译前，宏调用把参数的语言符号传递给程序
/*********************#define中使用参数*************************************/

/*********************利用宏参数创建字符串:#运算符********************************/
类函数宏的替换部分中，#符号用作一个预处理运算符，把语言符号转换为字符串，这个过程称为字符串化(stringizing)
EX:	PSQR(x) printf("The square of "#x" is %d.\n",((x)*(x)));
	main:PSQR(y);
/*********************利用宏参数创建字符串:#运算符********************************/

/*********************预处理器的粘合剂:##运算符********************************/
##运算符可以用于类函数宏的替换部分，也可用于类对象宏的替换部分
这个运算符将两个语言符号组合成单个语言符号
EX:		#define XNAME(x) x ## n
		#define PRINT_XN(n) printf("x"#n" = %d.\n",x ## n)
		main:int XNAME(1) = 12;//int x1 =12;
			PRINT_XN(1);
/*********************预处理器的粘合剂:##运算符********************************/

/*********************可变宏:...和__VA_ARGS__********************************/
宏定义的参数列表的最后一个参数为省略号(...)，预定义宏_ _VA_ARGS_ _可以用在替换部分
省略号只能代替最后的宏参数
#define PR(...) printf(__VA_ARGS__)
EX:		#define PR(X,...) printf("Message "#X" : "__VA_ARGS__)
		PR(1,"x = %g,y = %.2f.\n",x,y);
/*********************可变宏:...和__VA_ARGS__********************************/

/****************************宏与函数区别*****************************************/
宏产生内联代码，在程序中产生语句
使用使用宏20次会向程序中插入20行代码，对于函数只增加一份函数的拷贝
函数节约空间，但是程序控制跳入函数随后又返回调用程序，比内联代码花费时间多
宏不检查变量类型(宏处理的是字符型字符串，不是实际值)
	注意:	1.宏名字中不能有空格，主体中可以有
			2.用圆括号括住每个参数，并括住宏的整体定义，可以确保被括起来的部分会被正确分组
			3.用大写字母表示宏函数名，注意副作用
宏可以加快程序运行速度，但要注意副作用，循环嵌套中使用宏有助于加快程序运行速度
/****************************宏与函数区别*****************************************/

/****************************文件包含:#include*****************************************/
预处理器发现#include指令后，就会寻找其后跟的文件名并把这个文件内容包含到当前文件中
被包含的文件文本将替换源代码文件中的#include指令
	#include的两种使用形式
#include<stdio.h>	//文件名放在尖括号中，预处理器在一个或多个系统文件目录中寻找文件
#include"mystuff.h"	//文件名放在双引号中，预处理器先在当前目录中寻找(或文件名指定的其他目录)，然后在标准位置寻找文件
	EX:	#include<stdio.h>//搜索系统目录
		#include"mystuff.h"//先所搜当前目录，然后搜索标准位置
		#include"/usr/bin/p.h"//搜索指定目录下的文件
stdio.h头文件包含:EOF、NULL、getchar()、putchar()
头文件(header file):	.h后缀
使用头文件(header file):
	头文件一般包含的信息
	1.明显常量:stdio.h包含EOF,NULL,BUFSIZE
	2.宏函数:getchar()通常定义为getc(stdin),getc()为较为复杂的宏
	3.函数声明:string.h包含处理字符串的函数strstr()
	4.结构模板定义:标准I/O函数使用FILE结构，该结构包含文件及文件相关缓冲区相关信息，头文件stdio.h包含FILE结构声明
	5.类型定义:可以使用指向FILE的指针作为参数调用标准I/O函数，通常stdio.h使用#define或typedef使得FILE代表指向FILE结构的指针,类似的size_t,time_t
可以使用头文件声明多个文件共享的外部变量
需要头文件的情况:使用具有文件作用域、内部链接和const限定词的变量或数组
使用const可以避免值被修改，使用static后，每个包含该有文件的文件都获得一份该常量的副本
/****************************文件包含:#include*****************************************/

【其他预处理指令】#undef、#if、#ifdef、#ifndef、#else、#elif、#endif、#line、#error、#pragma

/****************************************#undef指令*************************************/
#undef:关闭前面的#define定义，取消未定义的宏也是合法的
	#deifne LIMIT 400	//宏定义
	#undef LIMT		//关闭定义
/****************************************#undef指令*************************************/

/****************************************已定义:C预处理器的观点*************************************/
	已定义:由预处理器定义，由#define指令创建的宏名，并且没有使用#undef关闭该定义，则标识符为已定义
	未定义:标识符不是一个宏，是其他如一个具有文件作用域的C变量，预处理器将该标识符视为未定义
	EX:		#define LIMT 100	//已定义
			#define GOOD		//已定义
			#define A(X) ((-(X)) * (X))//A是已定义的
			int q;
			#undef GOOD		//GOOD未定义
#define宏的作用域由定义位置开始直到文件结尾或#undef指令关闭该定义
_ _DATE_ _、_ _FILE_ _//这些宏被认为是已定义的并且不可取消
/****************************************已定义:C预处理器的观点*************************************/

/****************************************条件编译*************************************/
一、#ifdef、#else、#endif
	EX:#ifdef MAVIS				//如果标识符已定义
			#include"horse.h"		//执行该部分至#else或#endif
			#define STABLES 5
		#else					//未定义则执行#else和#endif之间的部分
			#include"cow.h"
			#define STABLES 5
		#endif
#endif必须存在，这些条件结构可以嵌套，类似于if else语句
二、#ifndef指令
#ifndef用来定义此前未定义的常量
	EX:	#ifndef SIZE//arrays.h
			#define SIZE 100
		#endif
		
		#include"arrays.h"//SIZE定义为100

		#define SIZE 10
		#include"arrays.h"//SIZE定义为10
#ifndef通常用于防止多次包含同一文件
	EX:	#ifndef THINGS_H_
			#define THINGS_H_
			//文件内容
		#endif
标准C头文件使用#ifndef计数避免多次包含
标识符命名规则:以文件名大写字母、下划线替代句点字符、用下划线做前缀或后缀
	EX:检查stdio.h
		#ifndef _STDIO_H_
			#define _STDIO_H_
			//文件内容
		#endif//C标准使用下划线前缀，平常使用应避免
#if和#elif指令
	EX:	#if SYS = 1
			#include"a.h"
		#elif SYS = 2
			#include"b.h"
		#elif SYS = 3
			#include"c.h"
		#else
			#include"d.h"
		#endif
新实现提供另一种方法来判断名字是否已经定义
#if defined(VAX):
	defined是一个预处理器运算符，如果defined的参数已经定义过，defined返回1，否则返回0
优点是可以喝#elif一起使用
	EX:	#if defined(IBMPC)
			#include"a.h"
		#elif defined(VAX)
			#include"b.h"
		#elif defined(MAC)
			#include"c.h"
		#else
			#include"mac.h"
		#endif
条件编译可以使程序的移植更容易，在文件开头改变几个关键定义，就可以为不同系统设置不同值并包含不同文件
/****************************************条件编译*************************************/

/**********************************预定义宏***********************************/
	宏						意义
	_ _DATE_ _				代表预处理的日期(Mmm dd yyyy格式的字符串)
	_ _FILE_ _				代表当前源文件名称的字符串
	_ _TIME_ _				源文件编译时间，格式为"hh: mm: ss: "
	_ _LINE_ _				代表当前源代码文件中的行号的整数
	_ _STDC_ _				设置为1，表示该实现遵循C标准
	_ _STDC_HOSTED_ _		为本机环境设置为1，否则为0
	_ _STDC_VERSION_ _		为C99时设置为199909L
C99标准提供一个名为_ _func_ _的预定义标识符，_ _func_ _为一个代表函数名的字符串
该标识符具有函数作用域，而宏本质上具有文件作用域，_ _func_ _为C语言预定义的标识符，不是预定义宏
/**********************************预定义宏***********************************/

/**********************************#line和#error***********************************/
#line:用于重置由_ _LINE_ _和_ _FILE_ _宏报告的行号和源文件名称
	EX:	#line 1000//将行号重置为1000
		#line 10 "cool.c"//将行号重置为10，源文件名称重置为cool.c
#error:使预处理器发出一条错误信息，该消息包含指令中的文本,中断编译过程
	EX:	#if __STDC_VARSION__ != 199901L
			#error Not C99
		#endif
/**********************************#line和#error***********************************/

/**********************************#pragma***********************************/
可以用命令行参数或IDE菜单修改编译器的某些设置，也可以用#pragma将编译器指令置于源代码中
	EX:开发C99时启用对C9X的支持
		#pragma c9x on
C99提供了_Pragma()预处理器运算符，_Pragma将字符串转换为常规的编译指示
	EX:	_Pragma("nonstandertreatmenttypeB on")转换为
		#pragma nonstandertreatmenttypeB on
该运算符没有使用#符号，可以作为宏展开的一部分
	EX:	#define PRAGMA(X) _Pragma(X)
		#define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)
		use:LIMRG(on)
_Pragma完成字符析构(destringizing)工作，将字符串中的转义序列转换成它所代表的字符
	EX:	_Pragma("user_bool\"true\"false")
		#pragma user_bool "true "false
/**********************************#pragma***********************************/

/*************************************内联函数*******************************/

内联函数(inline function):把函数定义为内联函数将建议编译器尽可能快地调用该函数
内联函数可以简化函数的调用机制，但是这样的做法是否会生效取决于实现
创建内联函数的方法:在函数声明中使用函数说明符inline,首次使用内联函数在文件中对该函数定义，该定义也作为函数原型
	EX:#include<stdio.h>
		inline void eatLine(){while(getchar() != '\n')continue;}//内联函数的定义和原型是写在一起的
		int main(){eatLine();return 0;}//调用
编译器看到内联函数会将函数体嵌入调用位置，如同在调用处键入了函数体
内联函数没有预留给它的单独代码块，所以不能取得内联函数的地址，内联函数不会在编译器中显示
取得内联函数的地址，编译器会产生该函数的外部定义(EX:将函数名作为参数传递)
内联函数的定义和调用必须在同一文件中，内联函数具有内部链接
多文件公用一个内联函数，在头文件中定义内联函数，使用该函数的文件包含头文件
C允许混合使用内联函数和外部函数定义
	EX:	a.c	inline double squear(double);
			double square(double x){return x * x;}//内联函数的外部函数定义
			int main(){double q = square(1.3);return 0}//使用自身的内联函数
		b.c	extern double square(double);//引用声明
			double square(double x){double y;y = x * x;return y;}
			void spam(double v){double kv = square(v);}//使用a中的外部函数
		c.c	extern double square(double);//引用声明
			void masp(double w){double kw = square(w);}//使用a中的外部函数
C允许在包含内联函数定义的文件中放置外部函数声明
	EX:	1.c	extern double square(double);//声明为外部函数
			inline double square(double);//声明为内联函数
			double square(double x){return x * x;}
			int main(){double q = square(1.3) + square(1.5);return 0;}
		2.c	extern double square(double);
			double square(double x){return x * x;}
编译器可以随意使用内联函数定义或外部函数定义，两次调用可以使用不同的定义
/*************************************内联函数*******************************/

/***************************************C库***********************************/
访问C库:如何访问C库依赖于实现
	一、通常可以在不同位置找到库函数
	EX:getchar()通常在stdio.h文件中被定义为宏，strlen()通常保存在库文件中
	二、不同的系统使用不同的方法搜索这些函数
		(1)自动访问:声明所使用函数的类型和包含适当的头文件即可实现自动访问
		(2)文件包含:如果函数定义为宏，可以使用#include指令包含拥有该定义的文件，EX:ctype.h头文件中包含去顶字符类型的函数
		(3)库包含:程序编译的某些阶段需要制定库选项
				区别库包含和头文件包含:头文件提供函数声明或原型，库选项告诉系统去哪里找函数代码
size_t类型定义为sizeof()运算符返回的无符号整数类型，通常为unsigned int或unsigned long
stddef.h包含size_t类型的typedef或#define定义
其他文件(stdio.h)通过包含stddef.h来包含这个定义
ANSI C使用void类型的指针作为通用指针，需要使用指向不同类型的指针时可以用void指针
	EX:fread()的第一个实际参数可能是指向不同类型数组的指针，形参为void指针，编译器自动选择适当类型
fread(void * restrict ptr,size_t size,size_t nmemb,FILE * restrict stream);

/***************************************C库***********************************/

/***************************************数学库***********************************/
math.h头文件提供有关数学计算的函数
角度单位为弧度:1弧度= 180/π = 57.296度
	【数学库函数】
	原型						描述
double acos(double x)			返回余弦值为x的角度值(x到π弧度)
double asin(double x)			返回正弦值为x的角度值(-π/2到π/2弧度)

double atan(double x)			返回正切值为x的角度值(-π/2到π/2弧度)
double atan2(double y,double x)	返回值正切值为y/x的角度值(-π到π弧度)

double cos(double x)			返回x的余弦值，x单位为弧度
double sin(double x)				返回x的正弦值，x单位为弧度

double tan(double x)				返回x的正切值，x单位 为弧度

double exp(double x)				返回x的指数函数的值(e的x次方)

double log(double x)				返回x的自然对数值
double log10(double x)			返回x以10为底的对数值

double pow(double x,double y)		返回x的y次幂

double sqrt(double x)			返回x的平方根
double fabs(double x)			返回x的绝对值

double ceil(double x)				返回不小于x的最小整数值
double floor(double x)			返回不大于x的最大整数值

atan()不能区分角度相同方向相反的线，atan()返回弧度，不是度
弧度角度的转换:弧度x180/pi
pi的值为4*atan(1)
/***************************************数学库***********************************/

/***************************************通用工具库stdlib.h***********************************/
通用工具库包含随机数产生函数、搜索和排序函数、转换函数、内存管理函数
rand、srand、malloc、free
一、atexit()
	该函数接受一个函数指针参数
	atexit()把作为参数的函数注册在调用exit()函数时执行的函数列表中
	列表中最多可放32个函数，并且按先进后出的顺序执行添加到函数列表中的函数
	由atexit()注册的函数的类型应该为不接受任何参数的void函数，通常他们执行内部处理任务
	更新程序的监视文件或重置环境变量
	:::::::main函数终止时会隐式地调用exit()函数
二、exit()
	exit()执行atexit()指定的函数后会进行一些资深清理工作
	1.刷新所有输出流
	2.关闭所有打开的流
	3.关闭通过标准I/O函数tempfile()创建的临时文件
	4.exit()将控制返回给主机和环境，并向主机报告终止状态
	5.main以外的函数使用exit()也会终止程序
	6.main中使用exit()等价于return关键字

【qsort()函数】快速排序
一、使用qsort
	对一个数据对象数组进行排序
	qsort()	ANSI原型
	void qsort(void * base,size_t nmemb,size_t size,int (*compar)(const void *,const void *));
	第一个参数:指向要排序数组的指针
	第二个参数:要排序的项目数量
	第三个参数:每个元素的大小sizeof(double),由于qsort将第一个参数转换为void*，丢失数组元素大小信息，需要用第三个参数传递
	第四个参数:执行的比较函数，类型为指向函数的指针
				比较函数中，如果第一个参数大于第二个参数，比较函数返回整数
				第一个参数等于第二个参数，比较函数返回0
				第一个参数小于第二个参数，比较函数返回负数
二、定义compar()比较函数
	int (*compar)(const void *,const void *)
	指向排序函数的指针，返回值为int类型，并且接受两个参数，参数类型均为指向const void类型的指针
	排序过程中，qsort将进行比较的两个元素的地址传递给比较函数
	比较函数内，应将参数的类型转换为指向对应数组元素类型的指针

可以将指向任何类型的指针赋值给void *
在把void *指针赋值给一个指针或另一个类型时，C++需要强制转换，C不需要
/***************************************通用工具库***********************************/

/***************************************诊断库assert.h***********************************/
程序终止函数abort()定义在stdlib.h中
assert()宏的作用:用于标识出程序中某个条件应为真的关键位置,并在条件为假时调用abort()语句终止程序

由头文件assert.h支持的诊断库是用于辅助调试程序的小型库，由宏assert()构成
该宏接受整数表达式(关系表达式、逻辑表达式)作为参数
如果结果为假，宏assert()向标准错误流stderr写一条消息并调用abort()终止程序
如果assert终止程序，会显示失败的判断、包含该判断的文件名和行号
assert可以自动识别文件及发生问题的行号
还可以无需改变即可开启或禁用assert()宏的机制
排除程序错误后，可以在包含assert.h语句之前定义宏:#define NDEBUG，编译器将禁用所有的assert()语句
再次使用诊断库，去掉assert.h之前的宏定义即可
/***************************************诊断库assert.h***********************************/

/***************************************string.h库中的memcpy()、memmove()***********************************/
memcpy()、memmove()均从s2指向的位置赋值n字节数据到s1指向的位置，均返回s1
函数原型:
	memcpy(void * restrict s1,const void * restrict s2,size_t n);
	memmove(void * s1,const void * s2,size_t n);
二者区别:
	1.memcpy不考虑内存区域是否重叠，memmove()考虑内存重叠的问题
	2.使用memcpy必须考虑内存重叠的问题
因参数类型为void *，这两个函数可以对任何类型的数据进行操作
接收void *类型的指针导致函数无法知道要赋值的数据类型
所以由第三个参数指定要复制的字节数
	EX:memcpy(s1,s2,10 * sizeof(double));
/***************************************string.h库中的memcpy()、memmove()***********************************/

/***************************************可变参数:stdarg.h***********************************/
stdarg.h提供建立可变参数函数的相关宏
可变参数函数的使用:
	1.在函数原型中使用省略号
	2.在函数定义中创建一个va_list变量，用于存储参数
	3.用宏将该变量初始化为一个参数列表
	4.用宏访问这个参数列表
	5.用宏完成清理工作
	6.函数原型应具有一个参量列表，并且省略号必须位于最后
	7.可变参数的函数省略号前的参数代表接收的可变参数个数，ANSI使用parmN代表该参量
		EX:int fill(int lim,...);
声明:stdarg.h中声明的va_list类型代表一种数据对象，该数据对象用于存放省略号部分代表的参量
初始化:va_start()宏将参数列表复制到va_list变量中，该宏接收两个参数:va_list类型变量和参量parmN
访问:使用va_arg()宏，该宏接收两个参数:一个va_list类型变量和一个参数类型(double,int)
		第一次调用获得第一个参数，第二次调用获得下一个参数，参数类型指定返回值的类型
		实际参数的类型必须与说明符的类型一致，获得参数过程不会像赋值那样进行类型的自动转换
		va_arg()不提供回退访问前一个参数的方法
		C99提供了va_copy()函数为制作va_list类型变量的副本
		该宏接收两个类型均为va_list类型的参数，将第二个参数复制到第一个参数中
		以便通过这个副本仍然可以访问前面访问过的变量
完成清理:使用va_end()宏，该宏接收一个va_list类型的变量作为参数

	EX:	double sum(int lim,...)//lim为参量parmN，用于指定可变参数列表中的参数个数
		{
			double tic;
			int toc;

			va_list ap;//声明用于存放参数的变量
			va_start(ap,lim);//将参数列表复制到ap变量中,将ap初始化为参数列表
			tic = va_arg(ap,double);//获得第一个参数
			toc = va_arg(ap,int);//获得第二个参数
			va_end(ap);//清理，释放为变量分配的内存
		}
/***************************************可变参数:stdarg.h***********************************/

//clock()函数，在time.h中定义,原型:clock_t clock(void);返回处理器时间，无法得到返回-1
//time.h定义的CLOCKS_PER_SEC为每秒的处理器时间单位个数
