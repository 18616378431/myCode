/******************************文件输入和输出***********************************************/
ANSIC文件两种视图:
	二进制视图:文件中每个字节都可以被程序访问
	文本视图:读取文件时，将行尾的本地环境表示法映射为C视图
			输出时，将C视图中的行尾表示法映射为文本视图
C程序使用/n表示结尾
C程序以文本视图模式处理一个MS-DOS文件时，将/r/n转换为/n
C程序以文本文件模式处理Macintosh文件时，将/r转换为/n

MS-DOS:文本文件用/r/n标识结束
Macintosh:文本文件用/r标识结束

C程序自动打开3个文件:标准输入(standard input)、标准输出(standard output)、标准错误输出(standard error output)

标准I/O相对于低级I/O:
	(1)标准I/O包中包含很多专用函数，可以方便地处理I/O问题
	(2)对输入输出进行了缓冲

/********************************fopen()***************************************************/
fopen():两个参数，第一个参数为文件的字符串地址,第二个参数是指定文件的打开模式的一个字符串
					fopen()函数的模式字符串
	模式字符串								意义
	r							打开一个文本文件，可以读取文件
	w							打开一个文本文件，可以写入文件，先将文件长度截为零，如果文件不存在则创建
	a							打开一个文本文件，可以写入文件，下个已有文件末尾追加写入，不存在则创建
	r+							打开一个文件，可以进行更新，即可以读取写入文件
	w+							打开一个文件，可以进行更新(读取写入)，将文件长度截为零，不存在则创建
	a+							打开一个文件，可以进行更新(读取写入)，向已有文件尾部追加内容，不存在则创建，写入时只能在尾部追加内容

使用二进制模式打开文件，与之前模式相同
	rb
	wb
	ab
	rb+,r+b
	wb+,w+b
	ab+,a+b

fopen()函数成功打开一个文件后返回文件指针(file pointer),fp包含文件I/O使用的缓冲区信息、当前缓冲区的缓冲能力、以及所使用的文件
文件打开失败，函数返回空指针NULL，磁盘已满、存取权限不够、文件名非法、硬件问题都会导致fopen()打开文件失败
/********************************fopen()***************************************************/

/**************************getc()、putc()********************************/
getc();一个参数为文件指针,获取文件中的字符
ch = getc(fp);//获得fp所指向文件的第一个字符
putc();两个参数，一个参数为要写入到文件中的字符，第二个参数为文件指针(即要写入的文件)
putc(ch,fp);//将字符ch写入FILE指针fp指向的文件
/**************************getc()、putc()********************************/

/**************************文件结尾*************************************/
在尝试读入字符时发现已经到达文件结尾，getc()返回一个特殊EOF值
C程序只有在读取超出文件结尾以后才会发现文件结尾
/**************************文件结尾*************************************/

/**************************fclose()*****************************************/
fclose(fp);关闭fp指定的文件，并刷新缓冲区
文件关闭成功返回0，否则返回EOF
磁盘已满、磁盘被移走、出现I/O错误都会导致fclose()关闭文件失败
/**************************fclose()*****************************************/

/**************************标准文件指针*****************************************/
标准文件		文件指针FILE	设备
标准输入		stdin			键盘
标准输出		stdout		显示器
标准错误		stderr		显示器
/**************************标准文件指针*****************************************/

/**************************文件I/O******************************************/
fprintf()、fscanf()、fgets()、fputs()、rewind()

rewind()函数接收一个文件指针参数，将文件指针指定为文件开始处

fprintf()、fscanf():与printf()相似，需要第一个参数来指定文件
fprintf()向文件中写入数据、fscanf()从文件中读取数据

fgets():接受三个参数
第一个为存储输入的地址(数组名或指针)，第二个为整数，表示输入的最大字符数，第三个为文件指针，指向要读取的文件
fgets(char * _buf,int _MAX_COUNT,FILE * _file)
fgets()读取所遇到的换行符后的一个字符，或者读取比字符串最大长度少1个字符或者读取到文件结尾
	然后fgets()向读取数据的末尾添加一个空字符，构成一个字符串，读取了完整的一行未到末尾或空字符，读入换行符
	遇到EOF返回NULL，据此检查文件结尾，否则返回传递给他的地址值
	fgets()每次读取指定的字符个数，未遇到文件结尾继续读取
fputs():接收两个参数，一字符串地址，二文件指针
	将字符串地址指针所指的字符串写入文件指针指向的文件
	输出时不自动添加换行符
fputs(char *_buf,FILE *_file);
/**************************文件I/O******************************************/

/**************************随机存取fseek()、ftell()****************************************/
fseek():接收三个参数，返回int，在fopen()打开的文件中将文件指针移动到任意字节处
	第一个参数为文件指针(*file)
	第二个参数为偏移量(offset),表示从起点开始偏移的距离，类型为long，正数前移，负数后移，0不动
	第三个参数为模式用来标识起点	
		      模式		     偏移量起始点
		SEEK_SET		文件开始
		SEEK_CUR		当前位置
		SEEK_END		文件末尾
		EX:
			fseek(fp,0L,SEEK_SET);//找到文件的开始处
			fseek(fp,10L,SEEK_SET);//文件的第10个字节处
			fseek(fp,0L,SEEK_CUR);//文件的当前位置
			fseek(fp,2L,SEEK_CUR);//文件的当前位置前移2字节
			fseek(fp,0L,SEEK_END);//文件的结尾处
			fseek(fp,-10L,SEEK_END);//从文件的结尾处回退10字节
	正常移动，fseek()返回0,有错误出现，移至文件末尾之后，返回-1

ftell():以long类型值返回文件的当前位置
	返回距离文件开始处的字节数目确定位置
	文件的第一个字节距离文件开始处距离为0
ftell()可以作为fseek()的第二个参数
/**************************随机存取fseek()、ftell()****************************************/

/************************二进制模式和文本模式********************************/
MS-DOS以Ctrl+Z标识文件结尾
	文本模式，C可以将Ctrl+Z识别为文件结尾
	二进制模式，C将Ctrl+Z当做文件中的一个字符
	以/r/n表示文本文件中的换行，文本模式打开文件，C将/r/n视为/n
Macintosh以/r表示行结尾
/************************二进制模式和文本模式********************************/

/**********************fgetpos()、fsetpos()**********************************/
fseek(),ftell()限制文件大小在long类型值范围内
较大文件定位函数:fgetpos();fsetpos();使用fpos_t(file position type 文件定位类型)代表文件位置
fpos_t不是基本类型，通过其他类型定义
fpos_t类型变量或数据对象可以指定文件中的一个位置，不是数组类型
ANSI C定义了fpos_t的使用方法
fgetpos函数原型:
fgetpos(FILE * restrict stream,fpos_t * restrict pos);被调用时，函数在pos所指位置放置一个fpos_t值，这个值描述了文件中的一个位置;
成功返回0，失败返回非0
fsetpos函数原型:
fsetpos(FILE * stream,const fpos_t * pos);被调用时，该函数使用pos所指向的位置的fpos_t值设定文件指针移动到该值所示位置;
成功返回0，失败返回非0,fpos_t值由fgetpos()函数获取
/**********************fgetpos()、fsetpos()**********************************/

/***********************I/O内幕、工作原理*********************************/
fopen()打开一个文件的同时创建了一个缓冲区和一个包含文件和缓冲区相关信息的数据结构
该数据结构包含:
	文件位置指示器、
	错误指示器、
	文件结尾指示器、
	一个指向缓冲区开始位置的指针、
	文件标识符、
	一个记录实际复制到缓冲区的字节数的计数器
函数读取最后一缓冲区的最后一个字节后，会将文件结尾指示器的值设置为真，下次被调用的输入函数返回EOF
/***********************I/O内幕、工作原理*********************************/

/***********************************其他标准I/O函数******************************************/
int ungetc(int c,FILE *fp);将指定字符放回到输入流中;EX:ch= getchar();ungetc(ch,stdin);
int fflush(FILE *fp);将缓冲区中任何未写的数据发送到由fp指定的输出文件中,这个过程成为刷新缓冲(flushing a buffer),如果fp为空指针，将刷新掉所有输出缓冲
int setvbuf(FILE * restrict fp,char * restrict buf,int mode,size_t size);
建立一个标准I/O使用的替换缓冲区，打开文件未进行任何操作时，可以调用该函数，
fp指定流，buf指向将使用到的存储区,
buf值不为NULL则必须创建这个缓冲区，为NULL则函数自动为自己分配缓冲区，
size为指定数组大小，
mode为刷新模式:
	_IOFBF(完全缓冲，缓冲区满时刷新)
	_IOLBF(行刷新，缓冲区满或新行写入时刷新)
	_IONBF(无刷新);
成功指定返回0，否则返回非0
/***********************************其他标准I/O函数******************************************/

/************************二进制I/O:fread()、fwrite()******************************************/
size_t类型是根据标准C类型定义的，是sizeof()运算符返回的类型，通常为unsingned int，可以选择为其他类型
fwrite原型:
size_t fwrite(const void * _str,size_t _Size,size_t _Count,FILE * _file);
一要写入的数据块的地址，二要写入数据块的大小，三要写入数据块的数目，四要写入的文件
返回成功写入的项目数，通常与_Count值相等，由写入错误，返回值小于_Count
文件中全部数据都以字符编码形式解读，该文件包含文本数据
数据部分或全部以二进制形式数字数据解读，该文件包含二进制数据
fread原型:读取fwrite()写入的文件数据，DstBuf为读入文件数据的内存存储地址，即存储读入的数据的内存块地址
size_t fread(void * DstBuf,size_t _ElementSize,size_t _count,FILE * _file);
/************************二进制I/O:fread()、fwrite()******************************************/

/***************************int feof(FILE *file)、int ferror(FILE * file)************************/
区分文件结尾和文件错误
如果最近一次输入调用检测到文件结尾，feof()返回非0值，否则返回0;
如果发生读写错误，ferror()返回非0值，否则返回0;
/***************************int feof(FILE *file)、int ferror(FILE * file)************************/

/**************使用二进制I/O进行随机存取*******************/
计算偏移量，在文件中定位
/**************使用二进制I/O进行随机存取*******************/



