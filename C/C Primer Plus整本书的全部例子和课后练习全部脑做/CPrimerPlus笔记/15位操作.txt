15位操作

运算符:~、&、|、^、>>、<<、&=、!=、^=、>>=、<<=
二进制、十进制、十六进制计数法
用于处理一个值中个别位的两个C工具:位运算符和位字段
6个作用于位的位运算、字段(field)数据形式

/*********************二进制数、位和字节*********************/
二进制:基于2的幂，以2为基数表示的数字称二进制(binary number)
十进制:基于10的幂，以10为基数表示的数字称为十进制
在描述存储器芯片和数据传输率时使用的字节为8位，从左到右位号7~0
字节中，位7称为高位(high-order bit)，0称为低位(low-order bit)，每位对应一个特定的指数
一字节中，最大的二进制数是11111111，最小的二进制数是00000000(0)
一个字节可以存储的数值范围是0~255，共256个可能的值
通过改变对位模式的解释方式，一个字节可以存储-128~+127之间的整数，共256个值
EX:unsigned char用一个字节表示0~255，signed char用一个字节表示-128~+127之间的值
	【有符号整数的几种表示方式】
符号量表示法(sign-magnitude):一字节中，保留1位高位表示数的符号，余下7位表示数,范围是-127~+127,这种方法有-0和+0
二进制补码(two's-complement):与符号量表示法的区别在于去顶该负数值的方法
	二进制补码方法是从一个9位组合100000000(256的二进制表示)减去一个负数位组合
	注意，负数位的组合看做无符号进行运算,所得结果是该数值的数量，再将其加上负号，则为负数
	该方法表示的范围是-128~+127
	EX:10000000(无符号128，有符号的-0),100000000(256) - 10000000(无符号128) = 10000000(128，负数的数值)
	**对一个二进制补码数去相反数，最简单的方法是反转每一位(0变1,1变0),然后加1;
	EX:1是00000001,-1是11111110 + 1 = 11111111
二进制反码(one's-complement):通过反转位组合中的每一位形成一个负数
	EX:00000001是1，11111110是-1,二进制反码也有一个-0:11111111,表示范围是-127~+127
	【二进制浮点数】
一、二进制小数
	二进制小数中，以2的幂作为分母,二进制小数.101代表:1 / 2 + 0 / 4 + 1 / 8，从2的1次幂开始递增
二、浮点数表示法
	数字的实际值是二进制小数部分乘以2的指定次幂
	EX:用4乘以一个浮点数，指数增加了2，二进制小数不变;
	     用一个不是2的次幂的数乘以一个浮点数，回改变二进制小数，可能改变指数部分
/*********************二进制数、位和字节*********************/

/*********************其他基数*********************/
八进制(octal):以8为基数的数制系统，该系统中可以使用0到7
	EX:八进制数(451)代表:4 x 8^2 + 5 x 8^1 + 1 x 8^0  = 297(以10为基数的数值)
	每一个八进制位对应3个二进制位:
		0	000
		1	001
		2	010
		3	011
		4	100
		5	101
		6	110
		7	111
	EX:0377可以表示二进制:000	011	111	111即11	111	111，舍去第一个0
	注意，内部的0不能舍去
	缺点:一个三位的八进制数要用9位的二进制数表示
十六进制(hexadecimal / hex):以16为基数的系统,该系统使用16的幂，可以使用的数字是0~15
	因为没有单独的阿拉伯数字表示10~15，使用字母A~F(可以小写)来表示
	EX:A3F(C中0xA3F),10 x 16^2 + 3 x 16^1 + 15 x 16^0 = 2623(十进制)
	一个16进制位对应于一个4位的二进制数，两个16进制数恰好等于8位字节
	第一个16进制位表示高4位，第二个16进制位表示低4位
	EX:0xC2	1100 0010	二进制值11010101可以看做1101	0101即0xD5
	对应关系:
	十进制		十六进制		二进制
	0			0			0000
	1			1			0001
	2			2			0010
	3			3			0011
	4			4			0100
	5			5			0101
	6			6			0110
	7			7			0111
	8			8			1000
	9			9			1001
	10			A			1010
	11			B			1011
	12			C			1100
	13			D			1101
	14			E			1110
	15			F			1111
/*********************其他基数*********************/

/*********************C的位运算符*********************/
【位逻辑运算符】
	4个位运算符用于整型数据，包括char，
	将这些运算符成为位运算符是因为他们对每位进行操作，而不影响左右两侧的位
	区分位运算符与常规逻辑运算符(&& || !)，常规逻辑运算符对整数数值操作
一、二进制反码/按位取反符号:~
	一元运算符~将每个1变为0,0变1
	~(1001 1010) = (0110 0101)
	该运算符不改变原始数据的数值
	unsigned char val = 2;(0000 0010)
	~val = 1111 1101(253)
二、位与(AND):&
	二进制运算符&通过将两个操作数逐位进行比较
	产生一个新值，对于每个位，只有两个操作数对应的位都为1是结果才为1
	EX:	(10010011) & 
		(00111101)结果为:00010001
	【位与赋值运算符:&=】
	val &= 0377	等价于	val = val & 0377
三、位或(OR): |
	二进制运算符|通过将两个操作数逐位进行比较
	产生一个新值，对于每个位，如果其中任意操作数对应的位为1，结果就为1
	EX:	(10010011) | 
		(00111101)结果为:10111111
	【位或赋值运算符:|=】
	val |= 0377	等价于	val = val | 0377
四、位异或:^
	二进制运算符^对两个操作数逐位进行比较
	对于每位，如果操作数中有一个对应的位为1(但两个操作数对应的位不同时为真)
	则结果为1
	EX:	(10010011)^
		(00111101)结果为10101110
	【位异或赋值运算符:^=】
	val ^= 0377	等价于	val = val ^ 0377
【用法:掩码】
掩码是某些位设置为(1)开某些位设置为(0)关的位组合
	MASK	=	0000 0010//掩码
					&
	flags		=	1001 0110
				0000 0010
	flags &= MASK;
	flags = 0000	0010;
	0xff		二进制1111 1111	八进制0377
【用法:打开位】
将操作数的某一位设置为(1)开，其他位保持不变
	flags		=	1001 0100	//打开flags的1位
					|
	MASK	=	0000 0010	//其他位保持不变
			flags	1001 0110
	或flags |= MASK;flags = 1001 0110;
【用法:关闭位】
将掩码按位取反，和flags做位与运算
	MASK	=	0000 0010//关闭位1
		~MASK	1111 1101
					&
	flags		=	1001 0110
			flags	1001 0100
	flags &= ~MASK;
【用法:位转置】
转置(toggling):一个位表示如果该位打开，则关闭该位;如果该位关闭，则打开该位
可以使用异或(^)运算符转置一个位
b是一个位，b为1，1^b = 0,b为0,1^b = 1;无论b是0或1，0^b为b
对应掩码位为1的位置被转置，对应掩码位为0的位置不变
flag ^= MASK;
(0000 0010)^
(1001 0110)=
(1001 0100)
【用法:查看一位的值】
先屏蔽flag中其他位，在将flag中的位1与MASK比较
先将flag和MASK做位与运算，得出掩码后的结果，在和MASK比较
if((flag & MASK) == MASK)
	puts("WOW");
【移位运算符】将位向左或向右移
一、左移:<<
	左移操作符<<将其左操作数的值的每位向左移动，移动的位数由右操作数指定
	空出的位用0填充，丢弃移出左操作数左端的位
	EX:	(1000 1010) << 2//每位向左移动2位
		(0010 1000)
		该操作产生一个新值，但不改变左操作数的值
	【左移赋值运算符:<<=】
		int stonk = 1;
		int onkoo;
		onkoo = stonk << 2;//将4赋值给onkoo，stonk的值仍为1
		stonk <<= 2;变量stonk每位左移2位，并将新值赋给stonk,stonk = 4
二、右移:>>
	右移操作符<<将其左操作数的值的每位向右移动，移动的位数由右操作数指定
	空出的位用0填充，丢弃移出左操作数右端的位
	对于unsigned 类型数值，用0填充左端空出的位置
	对于有符号类型，结果以来于机器(空出的位可能用0填充，或用符号位的副本填充)
	EX:	(1000 1010) >> 2//有符号
		(0010 0010)//某些系统用0填充
		(1110 0010)//用左端符号位的副本填充
		对于无符号值
		(1000 1010) >> 2//无符号
		(0010 0010)//所有系统上的结果
	【右移赋值运算符:>>=】
		int sweet = 16;
		int coosw;
		coosw = sweet >> 3;//结果为2，sweet仍为16
		sweet >>= 3;//结果为2，sweet为2
【用法:移位运算符】
	可以提供快捷、高效(依赖于硬件)的对2的幂的乘法和除法
	number << n		number乘以2的n次幂
	number >> n		若number非负,number除以2的n次幂
移位运算符也可用于从较大的单位中提取多组比特位
	EX:	使用unsigned long代表颜色的值，其中低位字节存储红色亮度，下一字节存储绿色亮度，高位字节存储蓝色亮度
		将每种颜色的亮度存储在各自的unsigned char中:
		#define BYTE_MASK 0xff		//1111 1111
		unsigned long color = 0x002a162f
		unsigned char red,blue,green;
		red = color & BYTE_MASK;
		green = (color >> 8) & BYTE_MASK;
		blue = (color >> 16) & BYTE_MASK;
移位运算符中		int i = M >> n;//右移结果为M 除以 2 的 n次方
				int i = M << n;//左移结果为M 乘以 2 的 n次方
/*********************C的位运算符*********************/

/*********************位字段****************************/
位字段是一个singned int 或 unsigned int中一组相邻的位
位字段由一个结构声明建立，该结构声明为每个字段提供标签，并决定字段宽度
struct {
	unsigned int autfd:1;
	unsigned int bldfc:1;
	unsigned int undln:1;
	unsigned int itals:1;
}prnt;//4个一位字段
可以为结构的每个字段赋值
总位数超出unsigned int 的大小，将会使用下一个unsigned int 的存储位置
不允许一个字段跨越两个unsigned int 之间的边界，编译器自动地移位一个这个月的字段定义
使字段按unsigned int 边界对齐，这样会在第一个unsigned int 中留下一个未命名空的洞
可以未命名的字段填充未命名的洞，站位数为该字节中剩余无法使用到的位个数

【位字段和位运算符】

/*********************位字段****************************/



